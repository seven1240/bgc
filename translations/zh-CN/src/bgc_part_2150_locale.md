```
<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 区域设置和国际化

【区域设置】

_本地化_ 是使您的应用程序能够在不同的地区（或国家）良好运行的过程。

正如你可能知道的那样，不是每个人都使用相同的字符作为小数点或千位分隔符……或货币。

这些区域有名称，您可以选择其中一个来使用。例如，美国的区域设置可能会写成:

100,000.00

而在巴西，相同的数字可能会用逗号和小数点互换的方式写成:

100.000,00

这使得更容易编写代码，以便轻松移植到其他国家！

嗯，有点。事实证明，C 只有一个内置的区域设置，而且是有限的。规范在这里确实有很多模糊性；很难完全做到可移植性。

但我们会尽力而为！

## 设置区域设置，快速且肮脏

对于这些调用，包含了【`locale.h`头文件】`<locale.h>`。

基本上，在声明特定区域设置方面，你可以做到的就是一个。如果你要进行某种区域设置，这可能是你想要做的事情:

【`setlocale()`函数】

``` {.c}
setlocale(LC_ALL, "");  // 使用这个环境的区域设置来进行所有操作
```

您应该调用这个函数，以便程序能够以您当前的区域设置进行初始化。

更详细地讲，还有一件事可以做且保持可移植性:

``` {.c}
setlocale(LC_ALL, "C");  // 使用默认的 C 区域设置
```

但这在每次启动程序时默认会被调用，所以没有太多需要自己执行。

在第二个字符串中，您可以指定系统支持的任何区域设置。这完全取决于系统，因此会有所不同。在我的系统上，我可以指定这样:
```

``` {.c}
setlocale(LC_ALL, "en_US.UTF-8");  // 非便携！
```

然后就能正常工作了。但这仅在系统具有完全相同的区域设置名称时才是便携的，你无法保证这一点。

通过将第二个参数设为空字符串（`""`），你在告诉C，“嘿，弄清楚这个系统上的当前区域设置是什么，这样我就不用告诉你了。”

[i[`setlocale()` 函数]>]

## 获取货币区域设置

[i[区域设置-->货币]<]

因为移动绿色纸币被承诺为获得幸福的关键^["这颗行星有一个问题，或者说曾经有一个问题，那就是：大部分居住在这颗行星上的人大部分时间都不快乐。有很多关于这个问题的解决方案，但多数都与小额绿色纸币的流动有关，这很奇怪，因为总体而言，并不是小额绿色纸币让人不快乐。” ---《银河系漫游指南》，道格拉斯·亚当斯]，让我们谈谈货币区域设置。在撰写便携代码时，你需要知道如何输入货币符号，对吧？无论是 "$", "€", "¥" 还是 "£"。

[i[`localeconv()` 函数]<]

在不至于发疯的情况下，你要如何写出这段代码呢？幸运的是，一旦调用了 `setlocale(LC_ALL, "")`，你只需调用 `localeconv()` 来查找它们：

``` {.c}
struct lconv *x = localeconv();
```

这个函数返回一个指向静态分配的 `struct lconv` 结构的指针，其中包含你正在寻找的所有重要信息。

以下是 `struct lconv` 的字段及其含义。

首先，一些约定。"_p_" 表示"正数"，"_n_" 表示"负数"，而"int_" 表示"国际"。尽管很多这些都是`char`类型或者`char*`类型，大多数（或者它们所指向的字符串）实际上被当作整数处理^[记住`char`只是一个字节大小的整数]。

在我们继续之前，请了解`CHAR_MAX`（来自`<limits.h>`）是`char`类型可以保存的最大值。许多接下来的`char`值使用这个值来指示该值在给定的区域设置中是不可用的。

|字段|描述|
|-----|-----------|
|`char *mon_decimal_point`|表示货币的小数点字符，例如 `"."`。|
|`char *mon_thousands_sep`|表示货币的千位分隔符字符，例如 `","`。|
|`char *mon_grouping`|货币的分组描述（详见下方）。|
|`char *positive_sign`|表示货币正值的符号，例如 `"+"` 或 `""`。|
|`char *negative_sign`|表示货币负值的符号，例如 `"-"`。|
|`char *currency_symbol`|货币符号，例如 `"$"`。|
|`char frac_digits`|在打印货币金额时，小数点后打印的位数，例如 `2`。|
|`char p_cs_precedes`|如果在非负货币金额前放置`currency_symbol`，则为`1`，如果在后面放置则为`0`。|
|`char n_cs_precedes`|如果在负货币金额前放置`currency_symbol`，则为`1`，如果在后面放置则为`0`。|
|`char p_sep_by_space`|确定`currency symbol`与非负金额之间的分隔（详见下方）。|
|`char n_sep_by_space`|确定`currency symbol`与负金额之间的分隔（详见下方）。|
|`char p_sign_posn`|确定非负值`positive_sign`的位置。|
|`char p_sign_posn`|确定负值`positive_sign`的位置。|
|`char *int_curr_symbol`|国际货币符号，例如 `"USD "`。|
|`char int_frac_digits`|`frac_digits`的国际值。|
|`char int_p_cs_precedes`|`p_cs_precedes`的国际值。|
|`char int_n_cs_precedes`|`n_cs_precedes`的国际值。|
|`char int_p_sep_by_space`|`p_sep_by_space`的国际值。|
|`char int_n_sep_by_space`|`n_sep_by_space`的国际值。|
|`char int_p_sign_posn`|`p_sign_posn`的国际值。|
|`char int_n_sign_posn`|`n_sign_posn`的国际值。|

### 货币数字分组

好的，这是一个有趣的话题。`mon_grouping` 是一个 `char*`，所以你可能会认为它是一个字符串。但在这种情况下，实际上它是一个 `char` 数组。它应该要以 `0` 或 `CHAR_MAX` 结尾。

这些值描述了如何分组货币数字的集合，是小数点左边（整数部分）的分组方式。

例如，我们可能有：

``` {.default}
  2   1   0
 --- --- ---
$100,000,000.00
```

这些是每三位一组。第0组（小数点左边）有3位数字。第1组（往左边的下一组）有3位数字，最后一个也有3位。

所以我们可以从右边（小数点）往左边描述这些组，用一组整数值表示各组的大小：

``` {.default}
3 3 3
```

这适用于最多到$100,000,000的数值。

但如果我们有更大的值怎么办？我们可以继续添加 `3`...

``` {.default}
3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
```

但那太疯狂了。幸运的是，我们可以指定 `0` 表示重复前一个组的大小：

``` {.default}
3 0
```

这意味着每3位重复一次。这样就能处理$100, $1,000, $10,000, $10,000,000, $100,000,000,000等数值。

你可以通过这些来表示一些奇怪的分组方式。

例如：

``` {.default}
4 3 2 1 0
```

将表示：

``` {.default}
$1,0,0,0,0,00,000,0000.00
```

还有一个可能出现的值是 `CHAR_MAX`。这表示不需要再进行分组，并且可以出现在数组的任何位置，包括第一个值。

``` {.default}
3 2 CHAR_MAX
```

将表示：

``` {.default}
100000000,00,000.00
```

例如。

而只需在第一个数组位置上放置 `CHAR_MAX`，就表示不需要任何分组。

### 分隔符和符号位置

所有`sep_by_space`变体处理货币符号周围的空格。有效值为：

|值|描述|
|:--:|------------|
|`0`|货币符号与数值之间没有空格。|
|`1`|用空格将货币符号（和符号，如果有的话）与数值分开。|
|`2`| 如果符号与货币符号相邻，用空格将符号与货币符号分开，否则用空格将符号与数值分开。|

`sign_posn`变体由以下值确定：

|值|描述|
|:--:|------------|
|`0`| 在数值和货币符号周围加上括号。|
|`1`| 将符号字符串放在货币符号和数值之前。|
|`2`| 将符号字符串放在货币符号和数值之后。|
|`3`| 将符号字符串直接放在货币符号前面。|
|`4`| 将符号字符串直接放在货币符号后面。|

### 示例数值

当我在我的系统上获取数值时，我看到的结果（分组字符串显示为单个字节值）：

``` {.c}
mon_decimal_point  = "."
mon_thousands_sep  = ","
mon_grouping       = 3 3 0
positive_sign      = ""
negative_sign      = "-"
currency_symbol    = "$"
frac_digits        = 2
p_cs_precedes      = 1
n_cs_precedes      = 1
p_sep_by_space     = 0
n_sep_by_space     = 0
p_sign_posn        = 1
n_sign_posn        = 1
int_curr_symbol    = "USD "
int_frac_digits    = 2
int_p_cs_precedes  = 1
int_n_cs_precedes  = 1
int_p_sep_by_space = 1
int_n_sep_by_space = 1
int_p_sign_posn    = 1
int_n_sign_posn    = 1
```

注意我们之前如何将宏 `LC_ALL` 传递给 `setlocale()`... 这表明可能存在一些变体，允许您更精确地设置要设置的语言环境的哪些 _部分_。

让我们看看你可以看到的这些值：

|宏|描述|
|----|--------------|
|[i[`setlocale()` 函数-->`LC_ALL` 宏]]`LC_ALL`|设置以下所有内容为给定的区域设置。|
|[i[`setlocale()` 函数-->`LC_COLLATE` 宏]]`LC_COLLATE`|控制 `strcoll()` 和 `strxfrm()` 函数的行为。|
|[i[`setlocale()` 函数-->`LC_CTYPE` 宏]]`LC_CTYPE`|控制字符处理函数的行为^[除了 `isdigit()` 和 `isxdigit()`。]。|
|[i[`setlocale()` 函数-->`LC_MONETARY` 宏]]`LC_MONETARY`|控制 `localeconv()` 返回的值。|
|[i[`setlocale()` 函数-->`LC_NUMERIC` 宏]]`LC_NUMERIC`|控制 `printf()` 函数族的小数点。|
|[i[`setlocale()` 函数-->`LC_TIME` 宏]]`LC_TIME`|控制 `strftime()` 和 `wcsftime()` 时间和日期打印函数的时间格式化。|

通常会看到 [i[`setlocale()` 函数-->`LC_ALL` 宏]] `LC_ALL` 被设置，但是，嘿，至少你有选择。

另外，我要指出 [i[`setlocale()` 函数-->`LC_CTYPE` 宏]] `LC_CTYPE` 也是非常重要的一个，因为它涉及到宽字符，这是一个我们稍后会讨论的重要问题。

[i[Locale]>]