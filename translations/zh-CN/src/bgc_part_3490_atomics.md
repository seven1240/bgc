<!--
Beej的C指南

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 原子型变量 {#chapter-atomics}

> _"他们都尝试过失败了吗？"_ \
> _"哦，不是的。" 她摇了摇头。"他们尝试过并且死去了。"_
>
> --- 保罗·亚特里德斯 和 盖厄斯·海伦·莫希亚姆修女，《沙丘》

[i[原子变量]<]

这是使用C进行多线程编程中更具挑战性的方面之一。
但我们会尽量简单地进行讲解。

基本上，我将会讨论原子变量的更直观用法，它们是什么，以及它们的工作原理等等。而且我会提到一些对你可用的更为复杂的路径。

但我不会深入探讨这些路径。不仅仅是因为我对此了解甚少，而且我想如果你知道你需要它们，你本身已经比我更懂。

即使在基础方面也有一些奇怪的东西。所以大家系好安全带，因为堪萨斯将要消失。

## 检测是否支持原子操作

[i[`__STDC_NO_ATOMICS__` 宏]<]

原子操作是一个可选功能。有一个宏 `__STDC_NO_ATOMICS__`，如果你 _没有_ 原子操作的话，它的值为`1`。

这个宏在C11之前可能不存在，所以我们应该用 `__STDC_VERSION__` 来检测语言版本^[`__STDC_VERSION__` 宏在早期的C89版本中可能不存在，所以如果你担心这个问题，请用`#ifdef`来检查。]。

``` {.c}
#if __STDC_VERSION__ < 201112L || __STDC_NO_ATOMICS__ == 1
#define HAS_ATOMICS 0
#else
#define HAS_ATOMICS 1
#endif
```

[i[`__STDC_NO_ATOMICS__` 宏]>]

[i[原子变量-->编译]<]

如果这些测试通过，那么你就可以安全地包含 `<stdatomic.h>`，这是本章其余内容基于的头文件。但如果没有原子操作支持，这个头文件甚至可能不存在。

在一些系统上，你可能需要在编译命令行的最后添加 `-latomic`，以便使用头文件中的任何函数。

## 原子变量

这是原子变量的工作原理的_部分_内容：

如果你有一个共享的原子变量，并且你从一个线程向其写入数据，那么在另一个线程中，这个写入将会是_全有或全无_的。

也就是说，另一个线程将会看到整个写入过程，比如说一个32位的数值。并不是其中的一半。一个线程没有办法在另一个线程进行原子多字节写入的_中间_插入。

这就像在获取和设置那个变量时有一个小锁。（或许是有的！参见下面的[无锁原子变量](#lock-free-atomic)。）

在这里，你可以通过使用互斥锁来锁定你的临界区而不使用原子操作来解决问题。只是有一类_无锁数据结构_总是允许其他线程继续执行，而不是被互斥锁阻塞……但是从头开始正确地创建这些数据结构很困难，这是本指南范围之外的内容，不幸的是。

这只是故事的一部分。但这是我们将开始的部分。

在继续之前，如何声明一个变量是原子的？

首先，包括`stdatomic.h`头文件。

这为我们提供了`atomic_int`等类型。

然后我们可以简单地声明变量为该类型。

但让我们演示一下，我们有两个线程。第一个线程运行一段时间，然后将一个变量设置为特定值，然后退出。另一个线程则一直运行直到看到该值被设置，然后退出。

``` {.c .numberLines}
#include <stdio.h>
#include <threads.h>
#include <stdatomic.h>

atomic_int x;   // 原子性的力量！哇哈哈哈！

int thread1(void *arg)
{
    (void)arg;

    printf("线程1：睡眠1.5秒\n");
    thrd_sleep(&(struct timespec){.tv_sec=1, .tv_nsec=500000000}, NULL);

    printf("线程1：设置x为3490\n");
    x = 3490;

    printf("线程1：退出\n");
    return 0;
}

int thread2(void *arg)
{
    (void)arg;

    printf("线程2：等待3490\n");
    while (x != 3490) {}  // 在此自旋

    printf("线程2：得到3490--退出！\n");
    return 0;
}

int main(void)
{
    x = 0;

    thrd_t t1, t2;

    thrd_create(&t1, thread1, NULL);
    thrd_create(&t2, thread2, NULL);

    thrd_join(t1, NULL);
    thrd_join(t2, NULL);

    printf("主线程：线程已完成，所以x应该是3490\n");
    printf("主线程：果然，x == %d\n", x);
}
```

第二个线程在原地自旋，查看标志并等待它被设置为值`3490`。而第一个线程则做这个。

然后我得到这个输出：

``` 
线程1：睡眠1.5秒
线程2：等待3490
线程1：设置x为3490
线程1：退出
线程2：得到3490--退出！
主线程：线程已完成，所以x应该是3490
主线程：果然，x == 3490
```

瞧，妈妈！我们从不同线程访问变量而不使用互斥锁！这多亏了原子变量的原子性。

你可能会想知道如果`x`是一个普通的非原子`int`会发生什么。在我的系统上，它仍然能正常工作... 除非我进行了一个优化构建，在这种情况下会阻塞在第2个线程，等待看到3490被设置。[当进行优化时，我的编译器将`x`的值放入一个寄存器，以加快`while`循环的速度。但是寄存器无法知道变量在另一个线程中已更新，因此它永远不会看到`3490`。这与原子性中的“全有或全无”部分没有实际关系，而更多关联到下一节中的同步方面。]

但这只是故事的开头。下一部分将需要更多的思考，并与所谓的“同步”有关。

## 同步

故事的下一部分涉及到一个关于一个线程中的特定内存写入何时对另一个线程可见的问题。

你可能会认为，写入会立即可见，对吧？但实际上并不会。有很多事情可能出错。甚至是奇怪的错误。

编译器可能会重新排列内存访问，以至于当你认为你设置一个相对于另一个的值时，这个假设并不正确。即使编译器没有这样做，你的CPU也可能会临时完成这个操作。或者也许这个架构的某些方面导致在一个CPU上的写入被延迟直到它们出现在另一个CPU上之前。

好消息是，我们可以将所有这些潜在问题归结为一个：未同步的内存访问可能会因观察的线程不同而以不同的顺序出现，就好像代码行本身已经被重新排列一样。

举个例子，在下面的代码中，`x`的写入和`y`的写入哪个先进行？

``` {.c .numberLines}
int x, y;  // 全局变量

// ...

x = 2;
y = 3;

```c
printf("%d %d\n", x, y);
```

答案：我们不知道。编译器或 CPU 可能会悄悄地反转第 5 和第 6 行，我们对此一无所知。该代码将以单线程的方式运行，就好像按照代码顺序执行一样。

在多线程场景下，我们可能会有类似以下伪代码：

```c
int x = 0, y = 0;

thread1() {
    x = 2;
    y = 3;
}

thread2() {
    while (y != 3) {}  // 自旋
    printf("x 现在是 %d\n", x);  // 2？...还是 0？
}
```

线程 2 的输出是什么呢？

如果 `x` 在 `y` 被赋值为 `3` _之前_ 被赋值为 `2`，那么我期望输出将非常明智地是：

```c
x 现在是 2
```

但是，有些东西可能耍诡计，重新排列第 4 和第 5 行代码，导致我们在打印时看到 `x` 的值为 `0`。

换句话说，除非我们以某种方式说，“从这一点开始，我期望另一个线程中的所有先前写入对这个线程可见”。

两个线程在它们同意共享内存状态时会进行 _同步_。正如我们所看到的，它们并不总是与代码一致。那么它们如何达成一致呢？

使用原子变量可以强制达成一致^[在我另有说明之前，我通常是在谈论关于 _顺序一致_ 操作。对这是什么意思我们稍后会详细讨论。]。如果一个线程对原子变量进行写入，它就在说：“未来任何读取此原子变量的人也将看到我对内存进行的所有更改（无论是原子的还是非原子的），包括原子变量本身”。

或者，更通俗地说，让我们围坐在会议桌旁，确保我们就共享内存中哪些值持有什么观点达成一致。您同意您做出的对内存的更改，一直到并包括在原子存储之后，将对我进行对同一原子变量的加载后可见。

因此，我们可以轻松修复我们的示例：

``` {.c .numberLines}
int x = 0;
atomic int y = 0;  // 使 y 成为原子变量

thread1() {
    x = 2;
    y = 3;             // 写入时同步
}

thread2() {
    while (y != 3) {}  // 读取时同步
    printf("x is now %d\n", x);  // 2，完毕。
}
```

因为线程在 `y` 上同步，所以所有在线程 1 中发生的写入，在从 `y` 读取之后，在线程 2 中是可见的（在 `while` 循环中）。

这里有几点重要事项需要注意：

1. 没有进程休眠。同步操作不会导致进程阻塞。两个线程都会全速运行直到退出。即使一个线程被卡在自旋循环中，也不会阻塞其他线程运行。

2. 当一个线程读取另一个线程写入的原子变量时，同步就会发生。因此，当线程 2 读取 `y` 时，线程 1 中的所有先前内存写操作（即设置 `x`）将对线程 2 可见。

3. 请注意 `x` 不是原子的。这没关系，因为我们不是在 `x` 上同步的，并且在线程 1 中写入 `y` 时的同步意味着线程 2 中所有先前的写入（包括 `x`）将对其他线程可见……如果那些其他线程读取 `y` 来进行同步。

强制进行此同步操作是低效的，比起仅使用常规变量会慢得多。这就是为什么除非特定应用程序需要，我们才不使用原子变量。

这就是基础知识。让我们更深入地了解吧。

[i[原子变量-->同步]<]

## 获取和释放

[i[原子变量-->获取]<]
[i[原子变量-->释放]<]

更多术语！现在学习这些将会很有益处。当一个线程读取一个原子变量时，称为获取操作。

当一个线程写入一个原子变量时，被称为一个_release_操作。

这些是什么？让我们将它们与您已经了解的原子变量术语进行对应：

**读取 = 载入 = 获取**。就像比较一个原子变量或者读取它以将其复制到另一个值中一样。

**写入 = 存储 = 发布**。就像将一个值赋给一个原子变量一样。

当使用具有获取/释放语义的原子变量时，C语言详细说明了可能发生的情况。

获取/释放构成了我们刚才讨论的同步的基础。

当一个线程获取一个原子变量时，它可以看到另一个线程设置的值，而该值是由释放相同变量的线程写入的。

换句话说：

当一个线程读取一个原子变量时，它可以看到另一个线程写入相同变量的值。

同步发生在获取/释放对之间。

更多细节：

通过特定原子变量的读取/载入/获取：

* 所有（原子或非原子）在另一个线程中在该线程写入/存储/释放该原子变量之前发生的写入，现在在该线程中是可见的。

* 其他线程设置的原子变量的新值也在该线程中可见。

* 当前线程中的任何变量/内存的读取或写入不能被重排序以在此获取之前执行。

* 获取在代码重排序方面作为一个单向屏障。当前线程中的读取和写入可以从获取之前移动到获取之后。但更重要的是对于同步，没有任何读取或写入可以从获取之后移动到获取之前。

通过特定原子变量的写入/存储/释放：

- 当前线程中发生在此发布之前的所有写操作（无论是原子还是非原子操作）将对已读取/加载/获取相同原子变量的其他线程可见。
- 由此线程写入此原子变量的值也对其他线程可见。
- 当前线程中任何变量/内存的读取或写入均不得重新排序以发生在此发布之后。
- 当涉及到代码重排序时，此发布充当单向屏障：当前线程中的读取和写入可从发布之后移动到之前。但更重要的是为了同步，没有内容可以从发布之前移动到之后。

总之，这就是将内存从一个线程同步到另一个线程的方法。第二个线程可以确保变量和内存是按程序员预期的顺序编写的。

在上面的示例中，`thread2` 在获取 `a` 后可以确保 `x` 和 `y` 的值，因为它们是在 `thread1` 发布原子变量 `a` 之前设置的。

但 `thread2` 无法确定 `z` 的值，因为它是在发布之后发生的。也许将 `z` 的赋值移到了 `a` 的赋值之前。

重要说明：释放一个原子变量对不同原子变量的获取没有影响。每个变量都与其他变量隔离。

[原子变量-->获取]
[原子变量-->释放]

## 顺序一致性

[原子变量-->顺序一致性]

你还坚持得住吗？我们已经讲完了关于原子操作更简单用法的重点内容。既然我们甚至不打算在这里讨论更复杂的用法，你可以稍微放松一下。

“顺序一致性”被称为“内存排序”。有许多内存排序，但顺序一致性是C语言提供的最稳定的。它也是默认的。你必须特意选择其他内存排序。

到目前为止我们讨论的一切都发生在顺序一致性的范围内。

我们已经谈到编译器或CPU如何可以在单线程中重新排列内存读写，只要遵循“好像”的规则。

我们已经看到如何通过在原子变量上同步来抑制这种行为。

让我们再正式一点。

如果操作是“顺序一致的”，这意味着到最后，当一切都结束时，所有的线程都可以踱步而来，打开他们选择的饮料，都同意内存变化发生的顺序，这个顺序是由代码指定的。

如果其他人说：“但是_B_在_A_之前发生了吧？”，那些线程中的其它人会说： “_A_明显在_B_之前发生了”。他们在这里都是朋友。

特别是，在一个线程内，不能将任何获取和释放重新排序。这是关于其他内存访问如何可以在它们周围重新排序的规则附加规则。

这个规则对于原子加载/获取和存储/释放的进展提供了额外的合理性层面。

C语言中的每个其他内存顺序都涉及重新排序规则的放宽，无论是用于获取/释放还是其他内存访问，无论是否是原子操作都是如此。如果您真的知道自己在做什么并且需要提高速度，您可以这样做。这里有一群龙...

稍后会详细介绍，但现在让我们专注于安全和实用。

原子赋值和运算符

原子变量上的某些运算符是原子的，而另一些则不是。

让我们从一个反例开始：

``` {.c}
atomic_int x = 0;

thread1() {
    x = x + 3;  // 非原子操作！
}
```

因为在赋值的右侧读取了 `x`，并且左侧实际上进行了写入，这是两个操作。另一个线程可能会在中间插入，并使你感到不快。

但是你可以使用简写 `+=` 来获得原子操作：

``` {.c}
atomic_int x = 0;

thread1() {
    x += 3;   // 原子的！
}
```

在这种情况下，`x` 会被原子地增加 `3`---没有其他线程会插入到中间。

特别是以下运算符是具有顺序一致性的原子读-修改-写操作，因此可以毫无顾虑地使用它们。（在示例中，`a` 是原子的。）

``` {.c}
a++       a--       --a       ++a
a += b    a -= b    a *= b    a /= b    a %= b
a &= b    a |= b    a ^= b    a >>= b   a <<= b
```

自动同步的库函数

迄今为止，我们已经讨论了如何使用原子变量进行同步，但事实证明还有一些库函数可以在幕后执行一些有限的同步。

``` {.c}
call_once()      thrd_create()       thrd_join()
mtx_lock()       mtx_timedlock()     mtx_trylock()
malloc()         calloc()            realloc()
aligned_alloc()
```

**`call_once()`**---与特定标志的所有后续`call_once()`调用同步。这样，后续调用可以放心，如果另一个线程设置了标志，它们将会看到它。

**`thrd_create()`**---与新线程的开始同步。新线程可以确保它将看到父线程在`thrd_create()`调用之前的所有共享内存写入。

**`thrd_join()`**---当一个线程结束时，它与这个函数同步。调用`thrd_join()`的线程可以确保它可以看到所有后来线程的共享写入。

**`mtx_lock()`**---在相同互斥量上的早期`mtx_unlock()`调用会与此调用同步。这种情况最类似于我们已经讨论过的获取/释放过程。`mtx_unlock()`在互斥变量上执行一个释放操作，确保任何随后使用`mtx_lock()`进行获取的线程可以看到临界区域中的所有共享内存更改。

**`mtx_timedlock()`**和**`mtx_trylock()`**---类似于`mtx_lock()`的情况，如果此调用成功，早期的`mtx_unlock()`调用会与此调用同步。

**动态内存函数**：如果您分配内存，它会与先前释放相同内存的操作同步。并且对该特定内存区域的分配和释放以一个所有线程都同意的单一总序发生。我认为这里的想法是，如果选择，释放可以擦除该区域，并且我们希望确保后续的分配不会看到未擦除的数据。如果还有其他情况，请告诉我。
```

## 原子类型说明符、限定符

让我们放缓脚步，看看我们有哪些可用的类型，以及如何甚至可以创建新的原子类型。

首先，让我们看看内置的原子类型以及它们是如何`typedef`为的。（剧透：`_Atomic`是一种类型限定符！）

|原子类型|完整写法等价|
|-|-|
|原子布尔类型|_Atomic _Bool|
|原子字符类型|_Atomic char|
|原子有符号字符类型|_Atomic signed char|
|原子无符号字符类型|_Atomic unsigned char|
|原子短整型|_Atomic short|
|原子无符号短整型|_Atomic unsigned short|
|原子整型|_Atomic int|
|原子无符号整型|_Atomic unsigned int|
|原子长整型|_Atomic long|
|原子无符号长整型|_Atomic unsigned long|
|原子长长整型|_Atomic long long|
|原子无符号长长整型|_Atomic unsigned long long|
|原子16位字符类型|_Atomic char16_t|
|原子32位字符类型|_Atomic char32_t|
|原子宽字符类型|_Atomic wchar_t|
|原子最小宽度为8位整型|_Atomic int_least8_t|
|原子最小宽度为8位无符号整型|_Atomic uint_least8_t|
|原子最小宽度为16位整型|_Atomic int_least16_t|
|原子最小宽度为16位无符号整型|_Atomic uint_least16_t|
|原子最小宽度为32位整型|_Atomic int_least32_t|
|原子最小宽度为32位无符号整型|_Atomic uint_least32_t|
|原子最小宽度为64位整型|_Atomic int_least64_t|
|原子最小宽度为64位无符号整型|_Atomic uint_least64_t|
|原子最快宽度为8位整型|_Atomic int_fast8_t|
|原子最快宽度为8位无符号整型|_Atomic uint_fast8_t|
|原子最快宽度为16位整型|_Atomic int_fast16_t|
|原子最快宽度为16位无符号整型|_Atomic uint_fast16_t|
|原子最快宽度为32位整型|_Atomic int_fast32_t|
|原子最快宽度为32位无符号整型|_Atomic uint_fast32_t|
|原子最快宽度为64位整型|_Atomic int_fast64_t|
|原子最快宽度为64位无符号整型|_Atomic uint_fast64_t|
|原子指针整型|_Atomic intptr_t|
|原子无符号指针整型|_Atomic uintptr_t|
|原子大小类型|_Atomic size_t|
|原子指针差值类型|_Atomic ptrdiff_t|
|原子最大整型|_Atomic intmax_t|
|原子最大无符号整型|_Atomic uintmax_t|

在需要的地方随意使用它们！如果有帮助的话，它们与在C++中找到的原子别名是一致的。

但如果你想要更多呢？

你可以通过类型限定符或类型说明符实现。

首先，类型说明符！它是关键字`_Atomic`，后面跟着括号中的类型^[显然C++23将把它添加为宏。]---适用于与`typedef`一起使用：

``` {.c}
typedef _Atomic(double) atomic_double;

atomic_double f;
```

类型说明符的限制：您要使其具有原子性的类型不能是数组或函数类型，也不能是已经是原子性的或其他已修饰过的类型。

接下来，类型限定符！它是关键字`_Atomic` _不带_括号中的类型。

所以这些做类似的事情^[规范指出它们在大小、表示和对齐方面可能有所不同。]：

``` {.c}
_Atomic(int) i;   // 类型说明符
_Atomic int  j;   // 类型限定符
```

事实是，你可以在后者中包含其他类型的限定符：

``` {.c}
_Atomic volatile int k;   // 有资格的原子变量
```

限定符的限制：您要使其具有原子性的类型不能是数组或函数类型。

原子标志如下，是所有符合规范的实现中唯一保证是无锁的原子类型。在典型的桌面/笔记本电脑世界中，其他较大的类型可能是无锁的。

幸运的是，我们有几种方法可以确定特定类型是无锁原子还是非无锁原子。

首先，一些宏---您可以在编译时使用这些宏与 `#if` 相结合。它们适用于有符号和无符号类型。

|原子类型|无锁宏|
|-|-|
|`atomic_bool`|[i[`ATOMIC_BOOL_LOCK_FREE` 宏]]`ATOMIC_BOOL_LOCK_FREE`|
|`atomic_char`|[i[`ATOMIC_CHAR_LOCK_FREE` 宏]]`ATOMIC_CHAR_LOCK_FREE`|
|`atomic_char16_t`|[i[`ATOMIC_CHAR16_T_LOCK_FREE` 宏]]`ATOMIC_CHAR16_T_LOCK_FREE`|
|`atomic_char32_t`|[i[`ATOMIC_CHAR32_T_LOCK_FREE` 宏]]`ATOMIC_CHAR32_T_LOCK_FREE`|
|`atomic_wchar_t`|[i[`ATOMIC_WCHAR_T_LOCK_FREE` 宏]]`ATOMIC_WCHAR_T_LOCK_FREE`|
|`atomic_short`|[i[`ATOMIC_SHORT_LOCK_FREE` 宏]]`ATOMIC_SHORT_LOCK_FREE`|
|`atomic_int`|[i[`ATOMIC_INT_LOCK_FREE` 宏]]`ATOMIC_INT_LOCK_FREE`|
|`atomic_long`|[i[`ATOMIC_LONG_LOCK_FREE` 宏]]`ATOMIC_LONG_LOCK_FREE`|
|`atomic_llong`|[i[`ATOMIC_LLONG_LOCK_FREE` 宏]]`ATOMIC_LLONG_LOCK_FREE`|
|`atomic_intptr_t`|[i[`ATOMIC_POINTER_LOCK_FREE` 宏]]`ATOMIC_POINTER_LOCK_FREE`|

这些宏有趣地可以有 _三_ 种不同的值：

|值|含义|
|-|-|
|`0`|永远不是无锁的。|
|`1`|_有时_ 是无锁的。|
|`2`|总是无锁的。|

等一下——某物怎么可能“有时”是无锁的？这只是意味着在编译时不知道答案，但在运行时可能知道。也许答案取决于你是在正宗的英特尔还是 AMD 上运行此代码，或者类似的情况^[我突然编的这个例子。也许在英特尔/AMD 上没关系，但在其他地方可能很重要，讨厌！]。

但你总可以在运行时用 [`atomic_is_lock_free()` 函数] `atomic_is_lock_free()` 函数测试。此函数如果特定类型当前是原子的，则返回 true 或 false。

那么我们为什么关心呢？

无锁是更快的，所以也许有一个速度问题，你会以另一种方式编码。或者也许你需要在信号处理程序中使用原子变量。

### 信号处理程序和无锁原子

如果你在信号处理程序中读写共享变量（静态存储期或 `_Thread_Local`），那就是未定义行为 [哎呀！]... 除非你执行以下操作之一：

1. 写入 `volatile sig_atomic_t` 类型的变量。

2. 读取或写入无锁原子变量。

据我所知，无锁原子变量是从信号处理程序中获取信息的少数方法之一。

该规范在我看来有点模糊，特别是关于在信号处理程序中获取或释放原子变量时的内存顺序。C++说，这是有道理的，即这些访问与程序的其他部分是无序的^[C++详细说明，如果信号是调用 [i[`raise()`函数]] `raise()` 的结果，它在 `raise()` 之后有序。]。毕竟，信号可以在任何时候被触发。所以我认为C的行为是类似的。

【信号处理程序-->使用无锁原子变量】
【原子变量-->使用信号处理程序】

## 原子标志 {#atomic-flags}

【原子变量-->原子标志】
【`atomic_flag`类型】

标准只保证有一个类型是无锁原子的：`atomic_flag`。这是一个用于[flw[测试和设置|测试和设置]]操作的不透明类型。

它可以是 _set_ 或 _clear_。你可以使用以下方式将其初始化为空：

【`ATOMIC_FLAG_INIT`宏】

``` {.c}
atomic_flag f = ATOMIC_FLAG_INIT;
```

【`ATOMIC_FLAG_INIT`宏】

【`atomic_flag_test_and_set()`函数】

你可以使用 `atomic_flag_test_and_set()` 原子地设置标志，它会设置标志并返回其先前状态作为一个 `_Bool` 类型（设置为 true）。

【`atomic_flag_clear()`函数】

你可以使用 `atomic_flag_clear()` 原子地清除标志。

以下是一个示例，初始化标志为空，设置两次，然后再次清除。

``` {.c}
#include <stdio.h>
#include <stdbool.h>
#include <stdatomic.h>

atomic_flag f = ATOMIC_FLAG_INIT;

int main(void)
{
    bool r = atomic_flag_test_and_set(&f);
    printf("Value was: %d\n", r);           // 0

    r = atomic_flag_test_and_set(&f);
    printf("Value was: %d\n", r);           // 1

```c
    atomic_flag_clear(&f);
    r = atomic_flag_test_and_set(&f);
    printf("Value was: %d\n", r);           // 0
}
```

[[`atomic_flag_clear()` 函数]]>]
[[`atomic_flag_test_and_set()` 函数]]>]
[[原子变量-->原子标志>]>
[[`atomic_flag` 类型]>

## 原子`struct`s 和 `union`s

[[原子变量-->`struct` 和 `union`]]

使用 `_Atomic` 修饰符，你可以创建原子的`struct`和`union`！相当惊人。

如果里面的数据不是很多（即一小部分字节），生成的原子类型可能是无锁的。可以用 `atomic_is_lock_free()` 进行测试。

```c
#include <stdio.h>
#include <stdatomic.h>

int main(void)
{
    struct point {
        float x, y;
    };

    _Atomic(struct point) p;

    printf("Is lock free: %d\n", atomic_is_lock_free(&p));
}
```

有一个注意点：你不能访问原子`struct`或`union`的字段... 那么有什么意义呢？嗯，你可以将整个`struct`原子化地 _复制_ 到一个非原子变量中，然后使用它。你也可以相反地原子化复制。

```c
#include <stdio.h>
#include <stdatomic.h>

int main(void)
{
    struct point {
        float x, y;
    };

    _Atomic(struct point) p;
    struct point t;

    p = (struct point){1, 2};  // 原子复制

    //printf("%f\n", p.x);  // 错误

    t = p;   // 原子复制

    printf("%f\n", t.x);  // 成功！
}
```

你也可以声明一个`struct`，其中个别字段是原子的。关于原子类型是否允许在位域上，这是由实现定义的。

[[原子变量-->`struct` 和 `union`]]

## 原子指针

[[原子变量-->指针]]

在指针的情况下，这里关于 `_Atomic` 的放置有一个注意事项。

首先，指向 atomic 类型的指针（即，指针的数值不是原子的，但它指向的东西是原子的）：

第一段代码注释做解释

其次，指向非原子值的 atomic 指针（即，指针的数值本身是原子的，但它指向的东西不是原子的）：

第二段代码注释做解释

最后，指向原子值的 atomic 指针（即，指针和它指向的东西都是原子的）：

第三段代码注释做解释

## 内存顺序

我们已经讨论了顺序一致性，这是其中合理的一种。但还有许多其他类型：

|`memory_order`|描述|
|-|-|
|[i[`memory_order_seq_cst` 枚举类型]]`memory_order_seq_cst`|顺序一致性|
|[i[`memory_order_acq_rel` 枚举类型]]`memory_order_acq_rel`|获取/释放|
|[i[`memory_order_release` 枚举类型]]`memory_order_release`|释放|
|[i[`memory_order_acquire` 枚举类型]]`memory_order_acquire`|获取|
|[i[`memory_order_consume` 枚举类型]]`memory_order_consume`|消费|
|[i[`memory_order_relaxed` 枚举类型]]`memory_order_relaxed`|松散|

您可以利用特定的库函数指定其他内存顺序。例如，您可以像这样给 atomic 变量加上一个值：

第四段代码注释做解释

或者您可以使用这个库函数执行相同的操作：

第五段代码注释做解释

原子地将5加到x上；默认为顺序一致性。
```
[i[`atomic_fetch_add()`函数]>]

或者您可以使用显式内存顺序执行相同的操作：

[i[`atomic_fetch_add_explicit()`函数]<]

``` {.c}
atomic_int x = 0;

atomic_fetch_add_explicit(&x, 5, memory_order_seq_cst);
```

但如果我们不想要顺序一致性呢？您想要获取/释放（acquire/release）替代方案是出于某种原因吗？只需指定名称：

``` {.c}
atomic_int x = 0;

atomic_fetch_add_explicit(&x, 5, memory_order_acq_rel);
```

[i[`atomic_fetch_add_explicit()`函数]>]

我们将分解不同的内存顺序，如下所示。除非您知道自己在做什么，否则请不要对除顺序一致性之外的任何内容进行调整。很容易出错，导致罕见且难以重现的故障。

### 顺序一致性

[i[原子变量-->顺序一致性]<]
[i[内存顺序-->顺序一致性]<]

* 加载操作获取（请参见下文）。
* 存储操作释放（请参见下文）。
* 读改写操作先获取再释放。

此外，为了保持获取和释放的总顺序，获取和释放不会相互重排。（获取/释放规则不禁止释放后跟获取的重排。但顺序一致性规则会禁止。）

[i[内存顺序-->顺序一致性]>]
[i[原子变量-->顺序一致性]>]

### 获取（Acquire）

[i[原子变量-->获取]<]
[i[内存顺序-->获取]<]

这是对原子变量进行加载/读取操作时发生的情况。

* 如果另一个线程释放了此原子变量，则该线程执行的所有写操作在此线程中现在可见。

* 在此加载操作之后发生的内存访问不能在它之前重排。

### 获得

这是在原子变量的存储/写操作中发生的情况。

- 如果另一个线程稍后获取此原子变量，则在其原子写操作之前的所有内存写操作将对该另一个线程可见。
- 在释放之前发生的内存访问在其之后无法重排序。

### 释放

这只适用于读改写操作。它将获取和释放合并为一个操作。

- 读取时发生获取。
- 写入时发生释放。

### 松散

没有规则；就是无政府状态！每个人都可以随意重新排列一切！狗和猫生活在一起---大混乱！

实际上，还是有一个规则。原子读写操作仍然是要么全都执行，要么全都不执行。但是这些操作可以随意重新排序，并且线程之间没有任何同步。

有一些使用这种内存顺序的用例，你可以通过一点搜索找到，比如简单的计数器。

你可以在进行了一堆松散写入操作后使用一个栅栏来强制同步。

## 栅栏

了解原子变量的释放和获取是如何发生的吗？

嗯，实际上可以在没有原子变量的情况下进行释放或获取操作。

这就是所谓的"栅栏"。所以如果你想要一个线程中的所有写入对其他地方都可见，你可以在一个线程中设置一个释放栅栏，在另一个线程中设置一个获取栅栏，就像原子变量的工作方式一样。

由于在栅栏上并不真正存在消耗操作^[因为消耗操作是所有依赖于获取的原子变量值的操作，而栅栏上并没有原子变量。]，`memory_order_consume` 被视为一个获取操作。

你可以在栅栏上使用任何指定顺序：

[`atomic_thread_fence()` 函数]

``` {.c}
atomic_thread_fence(memory_order_release);
```

[`atomic_thread_fence()` 函数]
[`atomic_signal_fence()` 函数]

还有一种轻量级版本的栅栏可用于信号处理程序，称为`atomic_signal_fence()`。

它的工作方式与`atomic_thread_fence()`完全相同，除了：

- 它仅处理同一线程中值的可见性；与其他线程没有同步。

- 不会发出硬件栅栏指令。

如果你想确保非原子操作（和松弛的原子操作）的副作用在信号处理程序中可见，你可以使用这个栅栏。

这个想法是信号处理程序在_本_线程中执行，而不是另一个线程，因此这是一种更轻量级的方式来确保信号处理程序外部的更改在其中可见（即它们没有被重新排序）。

## 参考

如果你想了解更多关于这方面的内容，请参考一些帮助我逐步深入了解它的东西：

- Herb Sutter的_`atomic<>` Weapons_演讲：
  - [fl[第1部分|https://www.youtube.com/watch?v=A8eCGOqgvH4]]
  - [fl[第2部分|https://www.youtube.com/watch?v=KeLBd2EJLOU]]

* [fl[Jeff Preshing的材料|https://preshing.com/archives/]]，尤其是：
  * [fl[无锁编程简介|https://preshing.com/20120612/an-introduction-to-lock-free-programming/]]
  * [fl[获取和释放语义|https://preshing.com/20120913/acquire-and-release-semantics/]]
  * [fl[_Happens-Before_关系|https://preshing.com/20130702/the-happens-before-relation/]]
  * [fl[_Synchronizes-With_关系|https://preshing.com/20130823/the-synchronizes-with-relation/]]
  * [fl[C++11中`memory_order_consume`的用途|https://preshing.com/20140709/the-purpose-of-memory_order_consume-in-cpp11/]]
  * [fl[您可以执行任何类型的原子读取-修改-写入操作|https://preshing.com/20150402/you-can-do-any-kind-of-atomic-read-modify-write-operation/]]

* CPPReference:
  * [fl[内存顺序|https://en.cppreference.com/w/c/atomic/memory_order]]
  * [fl[原子类型|https://en.cppreference.com/w/c/language/atomic]]

* Bruce Dawson的[fl[无锁编程注意事项|https://docs.microsoft.com/en-us/windows/win32/dxtecharts/lockless-programming]]

* 在[r/C_Programming|https://www.reddit.com/r/C_Programming/]上乐于助人且知识渊博的人们

[i[原子变量]>]