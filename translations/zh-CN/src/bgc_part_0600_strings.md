# 字符串

终于！字符串！有什么比这更简单的吗？

好吧，事实证明在C中字符串其实并不是字符串。没错！
它们是指针！当然是了！

就像数组一样，在C中字符串几乎不存在。

但让我们来看看——这其实并不是什么大不了的事。

## 字符串字面量

在开始之前，让我们讨论一下C中的字符串字面量。这些是用双引号（`"`）括起来的字符序列。
（单引号用于括起字符，是完全不同的东西。）

举例：

``` {.c}
"Hello, world!\n"
"This is a test."
"When asked if this string had quotes in it, she replied, \"It does.\""
```

第一个字符串末尾有一个换行符——这是一个很常见的情况。

最后一个字符串中嵌入了引号，但你注意到每个引号前面都有（我们说"转义为"）一个反斜杠（`\`），表示字符串中的字面引号就在这个位置。这是C编译器区分打印双引号和字符串末尾的双引号的方法。

## 字符串变量

现在我们知道如何创建一个字符串字面量，让我们将它赋给一个变量，这样我们就可以对其进行操作了。

``` {.c}
char *s = "Hello, world!";
```

看看这个类型：指向`char`的指针。字符串变量`s`实际上指向该字符串中的第一个字符，即`H`。

我们可以使用`%s`（表示"字符串"）格式说明符打印它：

``` {.c}
char *s = "Hello, world!";

printf("%s\n", s);  // "Hello, world!"
```

## 字符串变量作为数组

另一个选项是这个，和上面的`char*`用法几乎等效：

``` {.c}
char s[14] = "Hello, world!";
```

// 或者，如果我们足够懒惰，让编译器为我们计算长度：

char s[] = "Hello, world!";
```

这意味着您可以使用数组表示法来访问字符串中的字符。
让我们正好这样做，以便在同一行打印字符串中的所有字符：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    char s[] = "Hello, world!";

    for (int i = 0; i < 13; i++)
        printf("%c\n", s[i]);
}
```

请注意，我们使用格式说明符 `%c` 来打印单个字符。

另外，请注意。如果我们将`s`的定义更改为 `char*` 类型，程序仍然可以正常工作：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    char *s = "Hello, world!";   // 这里是 char*

    for (int i = 0; i < 13; i++)
        printf("%c\n", s[i]);    // 但仍然在这里使用数组...?
}
```

而且，我们仍然可以使用数组表示法来完成打印输出的任务！这很令人惊讶，但这仅仅是因为我们还没有讨论数组/指针的等价性。但这又是另一个暗示，即数组和指针在根本上是相同的。
[i[字符串变量-->作为数组]]>

## 字符串初始化器

[i[字符串-->初始化器]]>
我们已经看到了使用字符串字面量初始化字符串变量的一些示例：

``` {.c}
char *s = "Hello, world!";
char t[] = "Hello, again!";
```

但这两种初始化方式略有不同。一个字符串字面量，类似于整数字面量，其内存由编译器自动管理！对于整数，即固定大小的数据块，编译器可以很容易地管理它。但字符串是一个可变长度的“野兽”，编译器通过将其投放到一个内存块中，并给您一个指向它的指针来驯服它。

这个指针指向字符串所放置的位置。通常，这个位置是在远离程序其余内存的地方 - 只读存储器 - 这与性能和安全相关的原因。

``` {.c}
char *s = "Hello, world!";
```

因此，如果你尝试用这个去改变字符串：

``` {.c}
char *s = "Hello, world!";

s[0] = 'z';  // 不好的消息：试图改变一个字符串字面量！
```

行为是未定义的。可能根据你的系统，会导致崩溃。

但是声明为一个数组就不同了。编译器不把这些字节存放在另一个地方，它们就在附近。这是一个可改变的字符串的 _拷贝_ -- 我们可以随意修改：

``` {.c}
char t[] = "Hello, again!";  // t是字符串的数组拷贝
t[0] = 'z'; //  没问题

printf("%s\n", t);  // "zello, again!"
```

所以记住：如果你有一个指向字符串字面量的指针，不要试图去改变它！如果你用双引号中的字符串初始化一个数组，那实际上不是一个字符串字面量。
[i[Strings-->initializers]>]

## 获取字符串长度

[i[Strings-->getting the length]<]
你不能，因为C不会自动追踪字符串长度。当我说“不能”的时候，实际上意味着“可以”^[尽管确实C不会追踪字符串的长度。]。在`<string.h>`中有一个叫做`strlen()`的函数，可以用来计算任何字符串的长度（以字节为单位）^[如果你使用基本字符集或8位字符集，你习惯于一个字符占用一个字节。然而，并非所有的字符编码都是如此。]。

``` {.c .numberLines}
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = "Hello, world!";

    printf("The string is %zu bytes long.\n", strlen(s));
}
```

`strlen()`函数返回 `size_t` 类型，这是一个整数类型，所以你可以用它进行整数运算。我们用 `%zu` 来打印 `size_t`。

上面的程序打印:

``` {.default}
该字符串有13个字节长。
```

太棒了！所以确实可以获得字符串的长度！
[i[Strings-->获取长度]>]

但是...如果C没有在任何地方跟踪字符串的长度，那它如何知道字符串有多长呢？

## 字符串终止

[i[Strings-->终止]<]
C对字符串的处理与许多编程语言略有不同，事实上，与几乎所有现代编程语言都不同。

在创建新语言时，你基本上有两种选项来存储内存中的字符串：

1. 存储字符串的字节以及表示字符串长度的数字。

2. 存储字符串的字节，并用一个特殊字节标记字符串的结尾，这个特殊字节称为_终止符_。

如果你希望字符串长度超过255个字符，选项1至少需要两个字节来存储长度。而选项2只需要一个字节来终止字符串。因此在那里节省了一点空间。

当然，如今似乎很荒谬担心节省一个字节（或3个字节---许多编程语言很乐意让你的字符串长度可以达到4吉字节）。但在过去那是一件大事。

因此C选择了第二种方式。在C中，"字符串"由两个基本特征定义：

* 指向字符串中第一个字符的指针。
* 在指针之后的内存中至少有一个零值字节（或`NUL`字符^[这不同于`NULL`指针，当在谈论字符时我会将其缩写为`NUL`。]）来表示字符串的结尾。

在C代码中，`NUL`字符可以用`\0`来表示，尽管你通常不必这样做。

当你在代码中使用双引号括起来的字符串时，`NUL`字符会被自动、隐含地包括在其中。

``` {.c}
char *s = "Hello!";  // 实际上在后台是"Hello!\0"
```

因此，现在让我们编写自己的 `strlen()` 函数来统计字符串中的 `char` 直到找到一个 `NUL` 为止。

该过程是沿着字符串查找一个单个的 `NUL` 字符，同时计数^[稍后我们会学习使用指针算术来更简洁地完成此任务。]:

``` {.c}
int my_strlen(char *s)
{
    int count = 0;

    while (s[count] != '\0')  // 用单引号表示单个字符
        count++;

    return count;
}
```

这基本上是内置的 `strlen()` 完成工作的方式。[i[Strings-->终止]>]

## 复制字符串

[i[Strings-->复制]<]
你不能通过赋值操作符 (`=`) 来复制一个字符串。这只会复制指向第一个字符的指针...所以最终你会得到两个指向同一字符串的指针：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    char s[] = "Hello, world!";
    char *t;

    // 这只是复制了指针，而不是字符串本身！
    t = s;

    // 我们修改了 t
    t[0] = 'z';

    // 但打印 s 会显示修改！
    // 因为 t 和 s 指向同一字符串！

    printf("%s\n", s);  // "zello, world!"
}
```

如果你想复制一个字符串，你必须一次复制一个字节---但使用 `strcpy()` 函数会更容易^[还有一个更安全的函数叫做 `strncpy()`，你可能应该使用它，但我们稍后会讲到。]。

在复制字符串之前，请确保有足够的空间用来存放复制后的字符串，即将存放字符的目标数组至少要和要复制的字符串一样长。

``` {.c .numberLines}
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s[] = "Hello, world!";
    char t[100];  // 每个字符占用一个字节，所以有足够的空间

    // 这里会复制字符串！
    strcpy(t, s);

    // 我们修改 t
    t[0] = 'z';

    // s 保持不变，因为它是一个不同的字符串
    printf("%s\n", s);  // "Hello, world!"

    // 而 t 已经被改变
    printf("%s\n", t);  // "zello, world!"
}
```

请注意，在 `strcpy()` 中，目标指针是第一个参数，源指针是第二个参数。我记得这个顺序的助记词是，如果赋值运算符 `=` 对字符串起作用，那么你会将 `t` 和 `s` 摆放的顺序，源在右边，目标在左边。