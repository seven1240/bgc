# 字符串

[字符串]终于到了！字符串有什么能比这更简单的吗？

哎呀，原来在 C 语言中字符串并不是真正的字符串。是的！
它们其实是指针！当然啦！

就像数组一样，在 C 语言中，字符串几乎不存在。

但是让我们来看看——其实这并没那么复杂。

## 字符串文字

[字符串文字]在开始之前，让我们谈谈 C 语言中的字符串文字。
这些是用**双引号**(`"`)括起的一系列字符。
（单引号用来表示字符，是完全不同的东西。）

举例：

``` {.c}
"Hello, world!\n"
"This is a test."
"When asked if this string had quotes in it, she replied, \"It does.\""
```

第一个在结尾有一个换行符——这是很常见的情况。

最后一个例子中嵌入了引号，但你会发现每个引号前面都有（我们称之为“转义”）一个反斜杠（`\`），这表示一个字面上的引号应该出现在字符串的这个位置。这是 C 编译器区分打印引号和字符串末尾的引号的方法。[字符串文字]

## 字符串变量

[字符串变量]既然我们知道如何创建一个字符串文字，让我们把它分配给一个变量以便我们对其进行操作。

``` {.c}
char *s = "Hello, world!";
```

注意：这个类型是指向 `char` 的指针。字符串变量 `s` 其实是指向字符串中第一个字符的指针，也就是 `H`。

我们可以使用 `%s`（代表“字符串”）格式指示符打印它：

``` {.c}
char *s = "Hello, world!";

printf("%s\n", s);  // "Hello, world!"
```
[字符串变量]

## 将字符串变量作为数组

[将字符串变量-->作为数组]
另一种选择是使用数组，几乎等同于上面的 `char*` 用法：

``` {.c}
char s[14] = "Hello, world!";
```

```markdown
// 或者，如果我们懒得动手算，就让编译器替我们搞定长度：

char s[] = "Hello, world!";
```

这意味着你可以使用数组索引来访问字符串中的字符。让我们就是这么做，将字符串中所有字符在同一行打印出来：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    char s[] = "Hello, world!";

    for (int i = 0; i < 13; i++)
        printf("%c\n", s[i]);
}
```

请注意，我们使用格式说明符`%c`来打印单个字符。

另外，看看这个。如果我们将`s`的定义更改为`char*`类型，程序仍然可以正常工作：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    char *s = "Hello, world!";   // 这里是char*

    for (int i = 0; i < 13; i++)
        printf("%c\n", s[i]);    // 但这里仍然使用数组...？
}
```

即便如此，我们仍然可以使用数组索引来完成打印输出的工作！这有些令人惊讶，但这仅仅是因为我们还没有讨论过数组和指针的等价性。但这也是另一个提示，数组和指针本质上是相同的。
[i[字符串变量-->作为数组]]>

## 字符串初始化器

[i[字符串-->初始化器]]>
我们已经看过一些用字符串文字初始化字符串变量的例子：

``` {.c}
char *s = "Hello, world!";
char t[] = "Hello, again!";
```

但这两种初始化方式是微妙不同的。类似于整数文字，字符串文字的内存是由编译器自动管理的！对于整数，即固定大小的数据，编译器可以很容易地管理。但字符串是一个变长的怪兽，编译器通过将其扔进一块内存中并给你一个指针来驯服它。
```

这个指针指向了字符串的存放位置。通常情况下，那个位置是在远离程序内存的地方 -- 只读内存 -- 这是为了性能和安全性考虑。

``` {.c}
char *s = "Hello, world!";
```

所以，如果你试图改变这个字符串：

``` {.c}
char *s = "Hello, world!";

s[0] = 'z';  // 坏消息：尝试改变一个字符串常量！
```

行为是未定义的。可能会导致系统崩溃，这取决于你的系统。

但是，如果将它声明为数组就不一样了。编译器不会把这些字节放在街区的另一边，它们就在附近。这个是字符串的一个可变的_拷贝_ -- 我们可以随意改变它：

``` {.c}
char t[] = "Hello, again!";  // t是字符串的一个数组拷贝 
t[0] = 'z'; // 没问题

printf("%s\n", t);  // "zello, again!"
```

所以请记住：如果你有一个指向字符串常量的指针，不要试图改变它！如果你使用双引号来初始化一个数组，那实际上并不是字符串常量。
[i[字符串-->初始化]>]

## 获取字符串长度

[i[字符串-->获取长度]<]
你不能，因为C语言不会为你追踪。当我说"不能"的时候，实际上是指"能"^[虽然C语言确实不会追踪字符串的长度。]。在`<string.h>`头文件中有一个叫做`strlen()`的函数，可以用来计算任何字符串的长度（以字节为单位）^[如果你使用基本字符集或8位字符集，你习惯一个字符等于一个字节。但在某些字符编码中并不成立]。

``` {.c .numberLines}
#include <stdio.h>
#include <string.h>

int main(void)
{
    char *s = "Hello, world!";

    printf("The string is %zu bytes long.\n", strlen(s));
}
```

`strlen()` 函数返回 `size_t` 类型，这是一个整数类型，所以你可以用它来做整数运算。我们用 `%zu` 来打印 `size_t`。

上述程序打印：

``` {.default}
字符串长度为13个字节。
```

太棒了！所以确实可以获取字符串的长度了！
[i[Strings-->获取长度]>]

但是... 如果C不在任何地方跟踪字符串的长度，它是如何知道字符串有多长的呢？

## 字符串终止符

[i[Strings-->终止]<]
C对字符串的处理方式与许多编程语言有所不同，实际上与几乎所有现代编程语言都不同。

当你设计一门新的语言时，在内存中存储字符串基本上有两种选择：

1. 存储字符串的字节以及表示字符串长度的数字一起。
   
2. 存储字符串的字节，并使用一个特殊字节作为字符串的结束标志，这个特殊字节叫做“终止符”。

如果你希望有超过255个字符的字符串，选择第1种方式至少需要两个字节来存储长度。而第2种方式只需要一个字节来终止字符串。因此这里可以节省一些空间。

当然，如今似乎不必为节省一个字节（或3个字节）而担忧了——很多编程语言愿意让你拥有长达4GB的字符串。但是在过去，这是很重要的。

因此C选择了第2种方式。在C中，“字符串”由两个基本特征定义：

- 指向字符串第一个字符的指针。
- 指向该指针后内存中某处的值为零的字节（或`NUL`字符^[这与`NULL`指针不同，当谈到字符时我会缩写为`NUL`，而指针则用`NULL`。]），表示字符串的结束。

在C代码中，`NUL`字符可以用`\0`来表示，尽管你通常不必这样做。

在你的代码中，如果把字符串用双引号括起来，`NUL`字符会自动、隐式地包含在其中。

``` {.c}
char *s = "Hello!";  // 实际上是在背后"Hello!\0"
```

因此，有了这个背景，让我们写一个自己的 `strlen()` 函数来计算字符串中的字符数，直到找到一个`NUL`。

具体过程是查看字符串，找到单个`NUL`字符时进行计数^[稍后我们将学习如何通过指针运算更优雅地实现。]：

``` {.c}
int my_strlen(char *s)
{
    int count = 0;

    while (s[count] != '\0')  // 使用单引号表示单个字符
        count++;

    return count;
}
```

这基本上是内置的 `strlen()` 是如何完成任务的方法。
[i[Strings-->termination]>]

## 复制字符串

[i[Strings-->copying]<]
你不能通过赋值运算符(`=`)来复制字符串。这只会复制第一个字符的指针… 因此最终你会有两个指向同一个字符串的指针：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    char s[] = "Hello, world!";
    char *t;

    // 这么做只是复制了指针，没有复制字符串！
    t = s;

    // 我们修改了 t
    t[0] = 'z';

    // 但打印 s 会显示修改！
    // 因为 t 和 s 指向同一个字符串！

    printf("%s\n", s);  // "zello, world!"
}
```

如果你想复制一个字符串，你必须逐个字节地复制它---但使用 `strcpy()` 函数会更容易^[有一个较安全的函数叫做 `strncpy()`，你应该使用它，但我们稍后再讨论。]。

在你复制字符串之前，确保有足够的空间来存放，也就是说，用于保存字符的目标数组的长度至少要和你复制的字符串一样长。

``` {.c .numberLines}
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s[] = "Hello, world!";
    char t[100];  // 每个字符占一个字节，所以有足够的空间

    // 这里拷贝了字符串！
    strcpy(t, s);

    // 我们修改 t
    t[0] = 'z';

    // 而 s 保持不变，因为它是另一个字符串
    printf("%s\n", s);  // "Hello, world!"

    // 但是 t 已经被改变
    printf("%s\n", t);  // "zello, world!"
}
```

请注意，`strcpy()` 中，目标指针是第一个参数，来源指针是第二个参数。我用来记住这一点的助记法是如果赋值 `=` 适用于字符串的话，你会怎样放置 `t` 和 `s` ，来源在右，目标在左。
[i[Strings-->copying]>][i[Strings]>]