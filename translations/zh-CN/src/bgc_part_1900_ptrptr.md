<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 指针 III：指向指针的指针及更多

在这里，我们将涵盖一些中级和高级指针用法。如果你对指针还不熟悉，那么在开始学习这些内容之前，请复习之前关于[指针](#pointers)和[指针算术](#pointers2)的章节。

## 指向指针的指针

[i[指针-->指向指针]<]

如果你可以有一个指向变量的指针，而变量本身可以是一个指针，那么你能否拥有一个指向变量的指针，而这个变量本身是一个指针呢？

是的！这就是指针的指针，它存储在指针-指针类型的变量中。

在我们深入讨论之前，我想先尝试一下对指向指针的工作原理有个直观的感受。

记住，指针只是一个数字。它是一个代表计算机内存中索引的数字，通常这个索引指向我们由某种原因感兴趣的值。

这个指针，即一个数字，必须要存储在某个地方。而那个地方就是内存，就像其他所有东西一样^[关于只存储在寄存器中的值存在一些技术细节，但是对于我们的目的可以安全地忽略这一点。此外，C规范对于这些"寄存器"的事情除了`register`关键字外，并无进一步说明，其描述并未提及寄存器。]。

但因为它存储在内存中，所以它必须有一个存储的索引，对吧？指针必须有一个在内存中存储它的索引。这个索引也是一个数字。它是指针的地址。它是指向这个指针的指针。

让我们从早期章节中的指向`int`的普通指针开始：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int x = 3490;  // 类型：int
    int *p = &x;   // 类型：指向int的指针

    printf("%d\n", *p);  // 3490
}
```

足够简单，对吧？我们有两种类型：`int` 和 `int*`，我们设置 `p` 指向 `x`。然后在第8行我们可以解引用 `p` 并输出值 `3490`。

不过，就像我们说的，我们可以有一个指向任何变量的指针......那么这意味着我们可以有一个指向 `p` 的指针吗？

换句话说，这个表达式是什么类型的？

``` {.c}
int x = 3490;  // 类型: int
int *p = &x;   // 类型: 指向 int 的指针

&p  // <-- p 的地址是什么类型的？即指向 p 的指针？
```

如果 `x` 是一个 `int`，那么 `&x` 就是一个我们存储在 `p` 中的 `int` 的指针，而 `p` 的类型是 `int*`。明白了吗？ (重复这段直到理解为止！)

因此 `&p` 是一个指向 `int*` 的指针，也就是指向指向 `int` 的指针。即 "`int`-指针-指针"。

懂了吗？(重复上一段直到理解为止！)

我们用两个星号表示这种类型：`int **`。让我们看看它是如何运作的。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int x = 3490;  // 类型: int
    int *p = &x;   // 类型: 指向 int 的指针
    int **q = &p;  // 类型: 指向指向 int 的指针

    printf("%d %d\n", *p, **q);  // 3490 3490
}
```

让我们为上述值假设一些虚构的地址作为示例，看看这三个变量在内存中可能会是什么样子。下面的地址值仅供示例，由我随意编造:

|变量|存储地址|存储的值|
|-|-|-|
|`x`|`28350`|`3490`---代码中的值|
|`p`|`29122`|`28350`---`x` 的地址！|
|`q`|`30840`|`29122`---`p` 的地址！|

实际上，让我们在我的电脑上^[在你的电脑上很可能会得到不同数字]尝试一下，用 `%p` 打印出指针的值，我会以实际引用再次显示同样的表格(以十六进制打印)。

```c
/* 
* 请看一下这些地址是相同的，除了最后一个字节，所以专注于这些。
* 在我的系统上，`int` 占4个字节，这就是为什么我们会从 `x` 到 `p` 见到地址增加了4，然后从 `p` 到 `q` 增加了8。在我的系统上，所有指针都是8个字节。
* 是 `int*` 还是 `int**` 重要吗？一个比另一个多几个字节吗？不！记住所有指针都是地址，即内存中的索引。在我的机器上，可以用8个字节表示一个索引... 不管存储在该索引上的是什么。
* 现在看看我们在前一个示例的第9行所做的事情：我们 _双重解引用_ 了 `q` 以得到我们的 `3490`。
* 这就是关于指针和指向指针的重要部分：
    - 使用 `&` 可以获取任何东西的指针（包括指针！）
    - 使用 `*` 可以获取指针指向的东西（包括指针！）
* 因此，您可以将 `&` 视为用于创建指针的操作符，而 `*` 则是反操作符---它与 `&` 相反---用于获取指针指向的内容。
* 从类型的角度来看，每次使用 `&`，都会将另一个指针级别添加到类型中。

|如果具有|那么执行|结果类型为|
|:-|:-:|:-|
|`int x`|`&x`|`int *`|
|`int *x`|`&x`|`int **`|
|`int **x`|`&x`|`int ***`|
|`int ***x`|`&x`|`int ****`|

* 每次使用间接引用（`*`）时，都会执行相反的操作：
*/ 
```  
```c
```

将markdown中的内容翻译为简体中文：

|如果拥有|那么运行|结果类型为|
|:-|:-:|:-|
|`int ****x`|`*x`|`int ***`|
|`int ***x`|`*x`|`int **`|
|`int **x`|`*x`|`int *`|
|`int *x`|`*x`|`int`|

请注意，你可以使用多个`*`来快速解引用，就像我们在上面的示例代码中看到的`**q`一样。每个`*`都会剥去一个间接引用的级别。

|如果拥有|那么运行|结果类型为|
|:-|:-:|:-|
|`int ****x`|`***x`|`int *`|
|`int ***x`|`**x`|`int *`|
|`int **x`|`**x`|`int`|

一般来说，`&*E == E`^[即使`E`是`NULL`，结果仍然是相同的，奇怪吧]。解引用会"撤销"取地址操作。

但是`&`不是这样工作的---你只能一次做一次，必须将结果存储在一个中间变量中：

``` {.c}
int x = 3490;     // 类型: int
int *p = &x;      // 类型: int *，指向int的指针
int **q = &p;     // 类型: int **，指向指针的指针
int ***r = &q;    // 类型: int ***，指向指针的指针的指针
int ****s = &r;   // 类型: int ****，你懂的
int *****t = &s;  // 类型: int *****
```

[i[指针-->指向指针]>]

### 指针指针和 `const`

[i[指针-->指向指针，`const`]<]

如果你还记得，声明一个指针的方式如下：

``` {.c}
int *const p;
```

意味着你不能修改`p`。尝试`p++`会导致编译时错误。

但是`int **`或`int ***`又是怎样的呢？`const`放在哪里，意味着什么？

让我们从简单的部分开始。紧挨变量名称的`const`是指该变量。因此，如果你想要一个不可更改的`int***`，你可以这样做：

``` {.c}
int ***const p;

p++;  // 不被允许
```

但是接下来就有点奇怪了。

如果我们有这种情况：

``` {.c .numberLines}
int main(void)
{
    int x = 3490;
    int *const p = &x;
    int **q = &p;
}
```

我编译时得到一个警告：

``` {.default}
warning: initialization discards ‘const’ qualifier from pointer target type
    7 |     int **q = &p;
      |               ^
```

这是怎么回事？编译器告诉我们，在这里我们有一个变量是`const`，然后我们把它的值赋给了另一个同样不是`const`的变量。"`const`性"被丢弃了，这可能不是我们想要的。

变量`p`的类型是`int *const p`，所以`&p`的类型是`int *const *`。然后我们尝试把这个值赋给`q`。

但是`q`是`int **`！第一个`*`上`const`性不同的类型！所以我们得到了一个警告，告诉我们`p`的`int *const *`中的`const`被忽略和丢弃了。

我们可以通过确保`q`的类型至少和`p`一样`const`来解决这个问题。

``` {.c}
int x = 3490;
int *const p = &x;
int *const *q = &p;
```

现在一切正常了。

我们甚至可以使`q`更加`const`。像上面这样，我们说："`q`本身不是`const`，但它指向的东西是`const`。"但我们也可以使它们两个都`const`：

``` {.c}
int x = 3490;
int *const p = &x;
int *const *const q = &p;  // 更多的const！
```

这也是有效的。现在我们既不能修改`q`，也不能修改`q`指向的指针。

[i[指针-->指向指针，`const`]>]

## 多字节值 {#multibyte-values}

[i[指针-->到多字节值]<]

```c
// 我们之前在各种地方已经有点暗示过了，但很明显并不是每个值都能存储在单个字节的内存中。有些东西占据多个字节的内存（假设它们不是 `char`）。您可以用 `sizeof` 来确定占据多少字节。而且您可以通过使用标准的 `&` 运算符来确定内存中对象的第一个字节的地址，它总是返回第一个字节的地址。

// 另一个有趣的事实！如果您遍历任何对象的字节，您会得到它的“对象表示”。内存中具有相同对象表示的两个东西是相等的。

// 如果要遍历对象表示，应该使用指向 `unsigned char` 的指针。

// 让我们制作我们自己的版本 [fl[`memcpy()`|https://beej.us/guide/bgclr/html/split/stringref.html#man-memcpy]] ，实现以下功能：

void *my_memcpy(void *dest, const void *src, size_t n)
{
    // 为 src 和 dest 创建本地变量，但类型为 unsigned char

    const unsigned char *s = src;
    unsigned char *d = dest;

    while (n-- > 0)   // 对于给定数量的字节
        *d++ = *s++;  // 将源字节复制到目标字节

    // 大多数复制函数都返回指向 dest 的指针，以便为调用者提供方便

    return dest;
}

//（这里有一些后递增和后递减的好例子供您学习。）

// 需要注意的是，上面的版本可能比系统提供的版本效率低一些。

// 但您可以将任何指针传递给它，并且它将复制这些对象。可以是 `int*`，`struct animal*` 或其他任何类型。
```

让我们做另一个示例，打印出一个`struct`的对象表示字节，这样我们就能看到里面是否有任何填充以及填充的是什么值^[您的C编译器不一定会添加填充字节，而添加的任何填充字节的值是不确定的]。

``` {.c .numberLines}
#include <stdio.h>

struct foo {
    char a;
    int b;
};

int main(void)
{
    struct foo x = {0x12, 0x12345678};
    unsigned char *p = (unsigned char *)&x;

    for (size_t i = 0; i < sizeof x; i++) {
        printf("%02X\n", p[i]);
    }
}
```

这里有一个`struct foo`，它的构造方式应该会鼓励编译器注入填充字节（尽管这并非必须）。然后我们获得了指向`struct foo`变量`x`的第一个字节的`unsigned char *`。

接着，我们只需要知道`sizeof x`，就可以循环遍历相应数量的字节，打印出值（以十六进制便于查看）。

运行这段代码会输出一堆数字。我已经在下面的注释中标出了存储值的位置：

``` {.default}
12  | x.a == 0x12

AB  |
BF  | 填充字节，有着“随机”值
26  |

78  |
56  | x.b == 0x12345678
34  |
12  |
```

在所有系统中，`sizeof(char)`都是1，并且我们可以看到输出顶部的第一个字节保存了我们存储在那里的值`0x12`。

然后我们有一些填充字节——对我来说，这些在每次运行时都会有所变化。

```c
最后，在我的系统上，`sizeof(int)` 是4，我们可以看到这4个字节在末尾。注意它们跟十六进制值`0x12345678`中的字节是相同的，但以相反顺序显示^[这会根据架构而变化，但我的系统是小端的，这意味着数字的最低有效字节首先存储。大端系统会先有`12`，然后是`78`。但规范对这种表示并没有做出规定。]。

这样我们就可以稍微了解内存中更复杂实体的字节情况。

[i[指针-->多字节值]>]

## `NULL`指针和零

[i[`NULL`指针-->零等效性]<]

这些可以互换使用：

* `NULL`
* `0`
* `'\0'`
* `(void *)0`

个人而言，我总是在需要`NULL`时使用`NULL`，但你可能会偶尔看到其他变体。虽然`'\0'`（所有位都设置为零的字节）也会相等，但将其与指针进行比较有些奇怪；你应该将`NULL`与指针进行比较。（当然，在字符串处理中，你经常将指针指向的内容与`'\0'`进行比较，这是正确的做法。）

`0`被称为_null指针常量_，当与另一个指针进行比较或分配时，会转换为相同类型的空指针。

[i[`NULL`指针-->零等效性]>]

## 指针作为整数

[i[指针-->作为整数]<]

你可以将指针转换为整数，反之亦然（因为指针只是内存中的索引），但除非在进行一些底层硬件操作时，你可能根本不需要这样做。此类操作的结果是由实现定义的，因此它们不具备可移植性。可能会发生很奇怪的事情。
```

C确实有一个保证：你可以将指针转换为`uintptr_t`类型，然后再将其转换回指针而不会丢失任何数据。

`uintptr_t`在`<stdint.h>`中定义^[这是一个可选特性，所以可能不在那里---但很可能在的]。

此外，如果你想被签名，你可以使用`intptr_t`达到相同效果。

[i[指针-->作为整数]>]

## 将指针转换为其他指针

[i[指针-->转换]<]

只有一种安全的指针转换：

1. 转换为`intptr_t`或`uintptr_t`。
2. 转换到`void*`，再从`void*`转换回来。

两个！两种安全的指针转换。

3. 转换到`char*`（或`signed char*`/`unsigned char*`），再从中转换回来。

三个！三种安全的转换！

4. 转换到`struct`的指针和指向其第一个成员的指针之间的相互转换。

四个！四种安全的转换！

如果你将指针强制转换为另一种类型的指针，然后访问它指向的对象，行为将是未定义的，因为有一个叫做严格别名（strict aliasing）的东西。

普通的别名（aliasing）指的是可以有多种方式访问同一个对象。这些访问点是彼此的别名。

严格别名说你只能通过指向_兼容类型_的指针访问对象。

例如，下面的操作肯定是允许的：

``` {.c}
int a = 1;
int *p = &a;
```

`p`是一个指向`int`的指针，它指向一个兼容类型---即`int`---所以我们没问题。

但以下操作不好，因为`int`和`float`不是兼容类型：

``` {.c}
int a = 1;
float *p = (float *)&a;
```

以下是一个演示程序，用于进行一些别名处理。它接受一个`int32_t`类型的变量`v`，并将其别名为指向`struct words`的指针。该`struct`内含两个`int16_t`。这些类型不兼容，因此我们违反了严格别名规则。编译器会假设这两个指针永远不会指向同一个对象...但我们让它们这样做了。这有点淘气。

让我们看看能否搞破坏。

``` {.c .numberLines}
#include <stdio.h>
#include <stdint.h>

struct words {
    int16_t v[2];
};

void fun(int32_t *pv, struct words *pw)
{
    for (int i = 0; i < 5; i++) {
        (*pv)++;

        // Print the 32-bit value and the 16-bit values:

        printf("%x, %x-%x\n", *pv, pw->v[1], pw->v[0]);
    }
}

int main(void)
{
    int32_t v = 0x12345678;

    struct words *pw = (struct words *)&v;  // 违反严格别名规则

    fun(&v, pw);
}
```

看我如何将这两个不兼容的指针传入`fun()`？一个类型是`int32_t*`，另一个是`struct words*`。

但它们都指向同一个对象：初始化为`0x12345678`的32位值。

因此，如果我们查看`struct words`中的字段，我们应该会看到该数字的两个16位部分。对吧？

在`fun()`循环中，我们递增了指向`int32_t`的指针。就是这样。但因为`struct`指向同一内存，它也将更新为相同的值。

所以让我们运行它并获得以下结果，32位值在左侧，两个16位部分在右侧。它应该匹配^[我打印出了反转的16位值，因为我在一个小端机器上，这样更容易阅读。]：

``` {.default}
12345679, 1234-5679
1234567a, 1234-567a
1234567b, 1234-567b
1234567c, 1234-567c
1234567d, 1234-567d
```

它完成了…_直到明天！_

让我们尝试使用 `-O3` 和 `-fstrict-aliasing` 编译 GCC：

``` {.default}
12345679, 1234-5678
1234567a, 1234-5679
1234567b, 1234-567a
1234567c, 1234-567b
1234567d, 1234-567c
```

它们相差一个！但它们指向同一块内存！这怎么可能呢？答案是：像这样取别名的内存是未定义行为。_一切皆有可能_，只是不是好事。

如果您的代码违反了严格别名规则，它是否工作取决于某人决定如何编译它。这很糟糕，因为那已经超出了您的控制范围。除非您是某种全知全能的神。

不太可能，抱歉。

GCC 可以通过 `-fno-strict-aliasing` 强制不使用严格别名规则。使用 `-O3` 和该标志编译上面的演示程序，会使输出与预期相符。

最后，_类型转换_ 是使用不同类型的指针查看相同数据。在严格别名之前，这种情况非常常见：

``` {.c}
int a = 0x12345678;
short b = *((short *)&a);   // 违反了严格别名规则
```

如果您想相对安全地进行类型转换，请参阅[Union和类型转换](#union-type-punning)部分。

[i[Pointers-->casting]>]

## 指针差异 {#ptr_differences}

[i[Pointers-->subtracting]<]

从指针算术部分您了解到，您可以将一个指针减去另一个指针^[假设它们指向同一数组对象]，以获得它们之间的元素数量差异。

现在这个差异的类型取决于实现，因此可能会因系统而异。

[i[`ptrdiff_t` 类型]<]

为了更具可移植性，您可以将结果存储在 `<stddef.h>` 中定义的 `ptrdiff_t` 类型的变量中。

``` {.c}
int cats[100];

int *f = cats + 20;
int *g = cats + 60;
```

```c
ptrdiff_t d = g - f;  // difference is 40
```

[`ptrdiff_t`类型-->打印]
您可以通过在整数格式说明符前加上`t`来打印它：

``` {.c}
printf("%td\n", d);  // 打印十进制：40
printf("%tX\n", d);  // 打印十六进制：28
```

[`ptrdiff_t`类型-->打印]
[`ptrdiff_t`类型]
[指针-->减法]

## 函数指针

[指针-->函数]

函数只是内存中的一系列机器指令，所以我们完全可以获取函数的第一条指令的指针。

然后调用它。

将函数指针作为参数传递给另一个函数可能会很有用。第二个函数可以调用传入的任何内容。

然而，使用这些东西的棘手之处在于，C 需要知道指向函数的变量的类型。

而且它真的很想知道所有的细节。

比如“这是一个指向接受两个 `int` 参数并返回 `void` 的函数的指针”。

您如何将所有这些写下来以便声明一个变量？

事实证明，它看起来非常像函数原型，只是多了一些括号：

``` {.c}
// 声明 p 为一个指向函数的指针。
// 该函数返回一个浮点数，并接受两个 int 作为参数。

float (*p)(int, int);
```

还请注意，您不必给参数命名。但如果您愿意，也可以；它们只是被忽略。

``` {.c}
// 声明 p 为一个指向函数的指针。
// 该函数返回一个浮点数，并接受两个 int 作为参数。

float (*p)(int a, int b);
```

现在我们知道如何声明一个变量了，那么我们如何知道要赋什么值进去呢？如何获取函数的地址？

原来有一种快捷方式类似于获取数组的指针一样：你只需要引用裸的函数名而不需要括号。(如果你愿意，可以在前面加上`&`，但这是不必要的，也不符合习惯用法。)

一旦你有了函数的指针，你可以通过添加括号和参数列表来调用它。

我们来做一个简单的示例，我将通过设置一个指向函数的指针来有效地为一个函数取个别名。然后我们将调用它。

这段代码会打印出`3490`：

``` {.c .numberLines}
#include <stdio.h>

void print_int(int n)
{
    printf("%d\n", n);
}

int main(void)
{
    // 将 p 指向 print_int 函数：

    void (*p)(int) = print_int;

    p(3490);          // 通过指针调用 print_int
}
```

注意`p`的类型如何表示`print_int`函数的返回值和参数类型。这是必要的，否则 C 会抱怨不兼容的指针类型。

这里再举一个例子，展示我们如何将一个函数的指针作为参数传递给另一个函数。

我们将编写一个函数，它接受一对整数参数，还有一个操作这两个参数的函数的指针。然后打印结果。

``` {.c .numberLines}
#include <stdio.h>

int add(int a, int b)
{
    return a + b;
}

int mult(int a, int b)
{
    return a * b;
}

void print_math(int (*op)(int, int), int x, int y)
{
    int result = op(x, y);

    printf("%d\n", result);
}

int main(void)
{
    print_math(add, 5, 7);   // 12
    print_math(mult, 5, 7);  // 35
}
```

稍微消化一下。这里的思路是，我们将会把一个函数的指针传递给 `print_math()`，然后它会调用那个函数进行一些数学计算。

```c
// This way we can change the behavior of `print_math()` by passing another
// function into it. You can see we do that on lines 22-23 when we pass in
// pointers to functions `add` and `mult`, respectively.

现在我们可以通过传入另一个函数来改变 `print_math()` 的行为。在第 22-23 行，当我们分别传入函数 `add` 和 `mult` 的指针时，您可以看到我们这样做。

// Now, on line 13, I think we can all agree the function signature of
// `print_math()` is a sight to behold. And, if you can believe it, this
// one is actually pretty straight-forward compared to some things you can
// construct^[The Go Programming Language drew its type declaration syntax
// inspiration from the opposite of what C does.].

现在，在第13行，我认为我们都可以一致认为 `print_math()` 的函数签名令人叹为观止。而且，如果您能相信的话，与您可以构造的某些内容相比，这个实际上相当简单^[《Go 编程语言》从相反的角度汲取了其类型声明语法的灵感]。

// But let's digest it. Turns out there are only three parameters, but
// they're a little hard to see:

但让我们来仔细研究一下。事实证明只有三个参数，但它们有点难以看清：

``` {.c}
//                      op             x      y
//              |-----------------|  |---|  |---|
void print_math(int (*op)(int, int), int x, int y)
```

// The first, `op`, is a pointer to a function that takes two `int`s as
// arguments and returns an `int`. This matches the signatures for both
// `add()` and `mult()`.

第一个参数 `op` 是一个指向接受两个 `int` 类型参数并返回一个 `int` 类型结果的函数的指针。这与 `add()` 和 `mult()` 的签名相匹配。

// The second and third, `x` and `y`, are just standard `int` parameters.

第二和第三个参数 `x` 和 `y` 就是标准的 `int` 类型参数。

// Slowly and deliberately let your eyes play over the signature while you
// identify the working parts. One thing that always stands out for me is
// the sequence `(*op)(`, the parens and the asterisk. That's the giveaway
// it's a pointer to a function.

当您慢慢仔细地看着这个签名时，找出其中的工作部分。对我来说，总是会引人注目的一点是 `(*op)(` 这个序列，括号和星号。这是指它是一个指向函数的指针的特征。

// Finally, jump back to the _Pointers II_ chapter for a
// pointer-to-function [example using the built-in
// `qsort()`](#qsort-example).

最后，跳回到_指针 II_章节，了解指向函数的[利用内置的 `qsort()` 函数的例子](#qsort-example)。

[i[Pointers-->to functions]>]
```