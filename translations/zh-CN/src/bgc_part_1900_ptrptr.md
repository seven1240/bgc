<!-- C语言指针指南

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 指针 III：指向指针及更多

在这里，我们将涵盖一些中级和高级指针用法。如果你还不太了解指针，请在开始学习本章内容之前回顾之前关于[指针](#pointers)和[指针算术](#pointers2)的章节。

## 指向指针的指针

[[指针指针]<]

如果可以有一个指向变量的指针，而且变量可以是一个指针，那么你可以拥有一个指向自身是指针的变量吗？

可以！这就是指向指针的指针，它保存在类型为指针指针的变量中。

在深入研究这个之前，我想让你对指针指针的工作原理有一个直观感受。

记住，指针只是一个数。它是一个代表计算机存储器中的索引的数，通常所指向的存储单元中保存着我们感兴趣的值。

这个指针，也就是一个数，必须被存储在某个地方。而那个地方就是内存，就像其他任何东西一样^[对于只存储在寄存器中的值，这里存在一些细微的问题，但是对于我们的目的，我们可以安全地忽略这些问题。另外，C规范对于“寄存器”除了`register`关键字之外并没有明确说明，`register`关键字的描述并不包含寄存器信息。]。

但是因为它被存储在内存中，它必须有一个存储的索引，对吧？这个指针必须有一个存储在内存中的索引位置。而这个索引也就是一个数。它就是指针的地址。这就是指向指针的指针。

让我们从之前章节中的指向`int`的普通指针开始：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int x = 3490;  // 类型：int
    int *p = &x;   // 类型：指向int的指针

    printf("%d\n", *p);  // 3490
}
```

简单易懂，对吧？我们有两种类型：`int` 和 `int*`，我们设置 `p` 指向 `x`。然后我们可以在第8行取消引用 `p` 并打印出值 `3490`。

但是，正如我们所说，我们可以有一个指向任何变量的指针... 那是否意味着我们可以有一个指向 `p` 的指针呢？

换句话说，这个表达式的类型是什么？

``` {.c}
int x = 3490;  // 类型：int
int *p = &x;   // 类型：指向一个 int

&p  // <-- 指向 p 的地址是什么类型？也就是指向 p 的指针？
```

如果 `x` 是一个 `int`，那么 `&x` 就是我们存储在类型为 `int*` 的 `p` 中的 `int` 的指针。明白了吗？（重复这段直到明白为止！）

因此 `&p` 是一个指向 `int*` 的指针，也就是"指向指向 `int` 的指针"。也就是 "`int`-指针-指针"。

懂了吗？（重复前一段直到懂为止！）

我们用两个星号 `int **` 来表示这种类型。让我们看看它的作用。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int x = 3490;  // 类型：int
    int *p = &x;   // 类型：指向一个 int
    int **q = &p;  // 类型：指向指向 int 的指针

    printf("%d %d\n", *p, **q);  // 3490 3490
}
```

让我们假设上面这些值的地址，作为例子，看看这三个变量在内存中可能是什么样子。下面的地址值仅为例子而我编造的：

|变量|存储在地址|存储的值|
|-|-|-|
|`x`|`28350`|`3490`--- 代码中的值|
|`p`|`29122`|`28350`--- `x` 的地址！|
|`q`|`30840`|`29122`--- `p` 的地址！|

确实，让我们在我的电脑上真正尝试一下^[在您的设备上可能会得到不同的数字]，并用 `%p` 打印出指针的值，我将再次使用实际参考（以十六进制打印）做同样的表格。

|变量|地址|存储的值|
|-|-|-|
|`x`|`0x7ffd96a07b94`|`3490`---从代码中获取的值|
|`p`|`0x7ffd96a07b98`|`0x7ffd96a07b94`---`x`的地址!|
|`q`|`0x7ffd96a07ba0`|`0x7ffd96a07b98`---`p`的地址!|

你可以看到这些地址除了最后一个字节外都是一样的，所以只看这些即可。

在我的系统上，`int` 占用 4 个字节，这就是为什么我们看到从 `x` 到 `p` 地址增加了 4 个字节^[规范中并没有规定始终会按此方式工作，但在我的系统上是如此。]，然后从 `p` 向 `q` 增加了 8 个字节。在我的系统中，所有指针都是 8 个字节。

`int*` 和 `int**` 有区别吗？有一个比另一个多几个字节吗？都没有！记住所有指针都是地址，即内存中的索引。在我的机器上，可以用 8 个字节表示一个索引... 不管该索引存储了什么内容。

现在看一下我们在之前示例的第9行做的事情：我们对 `q` 进行了 _双重引用_ 来返回我们的 `3490`。

这就是指针和指向指针的指针的重要之处：

* 使用 `&` 可以得到任何东西的指针（包括指针本身！）
* 使用 `*` 可以得到指针指向的东西（包括一个指针！）

因此，可以将 `&` 视为用于制作指针的工具，而 `*` 是其相反操作---它与 `&` 的方向相反---用于获取指针指向的内容。

在类型方面，每次使用 `&`，都会向类型中添加另一个指针级别。

|如果有|那么再运行|结果类型是|
|:-|:-:|:-|
|`int x`|`&x`|`int *`|
|`int *x`|`&x`|`int **`|
|`int **x`|`&x`|`int ***`|
|`int ***x`|`&x`|`int ****`|

每次使用解引用 (`*`) 时，它执行相反的操作：

如果你有|那么你运行|结果类型是|
|:-|:-:|:-|
|`int ****x`|`***x`|`int *`|
|`int ***x`|`**x`|`int *`|
|`int **x`|`**x`|`int`|

一般来说，`&*E == E`。[即使 `E` 是 `NULL`，出乎意料地，结果也是如此]。 解除引用操作“撤销”了地址的引用。

但 `&` 的工作方式并不相同---你只能一次执行一个，必须将结果存储在一个中间变量中:

``` {.c}
int x = 3490;     // 类型: int
int *p = &x;      // 类型: int*，指向 int 的指针
int **q = &p;     // 类型: int**，指向指向 int 的指针
int ***r = &q;    // 类型: int***，指向指向指向 int 的指针
int ****s = &r;   // 类型: int****，你明白了
int *****t = &s;  // 类型: int*****
```

[i[指针-->指向指针]>]

### 指针指针和 `const`

[i[指针-->指向指针，`const`]<]

如果你还记得，像这样声明一个指针:

``` {.c}
int *const p;
```

意味着你不能修改 `p`。 尝试 `p++` 会导致编译时错误。

但对于 `int **` 或 `int ***` 等类型，这是如何工作的呢？`const` 放在哪里，意味着什么？

让我们从简单的部分开始。紧挨着变量名的 `const` 指的是那个变量。因此，如果你想要一个无法改变的 `int***`，你可以这样做:

``` {.c}
int ***const p;

p++; // 不允许
```

但这里有一点有点奇怪。

如果我们有这样的情况，会怎样:

``` {.c .numberLines}
int main(void)
{
    int x = 3490;
    int *const p = &x;
    int **q = &p;
}
```

当我编译这段代码时，我收到了一个警告：

``` {.default}
warning: initialization discards ‘const’ qualifier from pointer target type
    7 |     int **q = &p;
      |               ^
```

发生了什么？编译器告诉我们，我们有一个`const`变量，然后将其值分配给另一个不是`const`的变量。这种`const`属性被丢弃了，这可能不是我们想要的。

变量`p`的类型是 `int *const p`，因此 `&p` 的类型是 `int *const *`。我们尝试将其赋给 `q`。

但`q` 是 `int **`！在第一个 `*`上有不同的`const`性质！因此，我们得到一个警告，`int *const *` 中的`const`被忽视和丢弃。

我们可以通过确保`q`的类型至少和`p`一样`const`来修复这个问题。

``` {.c}
int x = 3490;
int *const p = &x;
int *const *q = &p;
```

现在一切正常。

我们甚至可以使`q`更加`const`。就像现在这样，我们说，“`q` 本身不是`const`，但它指向的东西是`const`。” 但我们也可以都变成`const`：

``` {.c}
int x = 3490;
int *const p = &x;
int *const *const q = &p;  // 更多const！
```

这也是可行的。现在我们无法修改`q`或`q`指向的指针。

我们早些地在各个地方略微暗示过这一点，但很明显，并不是每个值都可以存储在单个字节的内存中。物体占据多个字节的内存空间（假设它们不是`char`）。你可以通过使用`sizeof`来知道需要多少字节来存储。通过使用标准的`&`运算符，你可以确定对象在内存中的第一个字节的地址，该运算符始终返回第一个字节的地址。

再来一个有趣的事实！如果你遍历任何对象的字节，你将获得它的“对象表示”。内存中具有相同对象表示的两个事物是相等的。

如果你想要遍历对象表示，你应该使用指向`unsigned char`的指针。

让我们做一个我们自己版本的`memcpy()`函数，完全符合上述要求：

``` {.c}
void *my_memcpy(void *dest, const void *src, size_t n)
{
    // 为 src 和 dest 声明类型为 unsigned char 的本地变量

    const unsigned char *s = src;
    unsigned char *d = dest;

    while (n-- > 0)   // 针对指定的字节数
        *d++ = *s++;  // 将源字节复制到目标字节

    // 大多数复制函数返回指向目标的指针，以便方便调用者

    return dest;
}
```

（这里有一些值得你研究的后增量和后减量的例子。）

值得注意的是，上述版本可能比系统自带的版本效率低一些。

但你可以向其中传递任何指针，并且它将复制这些对象。可以是 `int*`、`struct animal*`，或者任何其他类型。

让我们做另一个示例，打印出一个`struct`的对象表示字节，这样我们就可以看到是否有填充，并且有哪些值^[你的C编译器不一定会添加填充字节，并且添加的任何填充字节的值是不确定的]。

``` {.c .numberLines}
#include <stdio.h>

struct foo {
    char a;
    int b;
};

int main(void)
{
    struct foo x = {0x12, 0x12345678};
    unsigned char *p = (unsigned char *)&x;

    for (size_t i = 0; i < sizeof x; i++) {
        printf("%02X\n", p[i]);
    }
}
```

这里有一个`struct foo`，被构建成应该鼓励编译器注入填充字节的方式（尽管不一定会这样）。然后我们得到了一个指向`struct foo`变量`x`的第一个字节的`unsigned char *`。

接着，我们只需要知道`sizeof x`，然后我们可以循环遍历相应数量的字节，打印出这些值（以十六进制的方式方便查看）。

运行这个代码会输出一堆数字。下面我已经做了注释说明每个值存储的位置：

``` {.default}
12  | x.a == 0x12

AB  |
BF  | 使用“随机”值填充字节
26  |

78  |
56  | x.b == 0x12345678
34  |
12  |
```

在所有系统中，`sizeof(char)`都是1，我们可以看到输出结果的顶部那个第一个字节，其中存储着我们存储的值`0x12`。

然后我们有一些填充字节——对我来说，每次运行时这些值都有所不同。

最后，在我的系统上，`sizeof(int)` 是4，我们可以在最后看到这4个字节。请注意它们与十六进制值`0x12345678`中的字节相同，但奇怪的是顺序相反^[这会根据架构而变化，但我的系统是小端存储，这意味着数字的最低有效字节是首先存储的。大端系统将首先是`12`，最后是`78`。但规范并未对此表示做出任何规定]。

因此，这是我们透过内存中更复杂实体的字节的一小瞥。

[指针-->到多字节值]

## NULL指针和零

[NULL指针-->零等价]

这些都可以互换使用：

* `NULL`
* `0`
* `'\0'`
* `(void *)0`

个人而言，我总是在需要`NULL`时使用`NULL`，但您可能偶尔会看到其他变种。尽管`'\0'`（所有位均设置为零的字节）也将比较相等，但将其与指针进行比较就有点奇怪；应该将`NULL`与指针进行比较。（当然，在字符串处理中，很多时候您在比较指针指向的内容与`'\0'`，这样做是正确的。）

`0`被称为_null指针常量_，且在与另一个指针进行比较或赋值时，它将转换为相同类型的null指针。

[NULL指针-->零等价]

## 指针作为整数

[指针-->作为整数]

您可以将指针转换为整数，反之亦然（因为指针只是内存中的索引），但如果您只有在进行某些低级硬件操作时才需要这样做。此类操作的结果是由实现定义的，因此不具有可移植性。并且可能会发生奇怪的事情。

C确实有一个保证：你可以将指针转换为`uintptr_t`类型，然后再将其转换回指针而不会丢失任何数据。

`uintptr_t`在`<stdint.h>`中被定义。 [[它是一个可选特性，可能不存在---但很可能存在。]]

另外，如果你想符号化，也可以使用`intptr_t`来达到同样的效果。

## 将指针转换为其他指针

只有一种安全的指针转换：

1. 转换为`intptr_t`或`uintptr_t`。
2. 转换为和从`void*`之间的转换。

两个！有两种安全的指针转换。

3. 转换为和从`char*`（或`signed char*`/`unsigned char*`）之间的转换。

三个！有三个安全的转换！

4. 转换为一个结构体指针和其第一个成员的指针之间的转换，反之亦然。

四个！有四个安全的转换！

如果你将指针转换为另一种类型的指针，然后访问它指向的对象，这种行为是未定义的，因为存在一种叫做“严格别名”的东西。

普通的“别名”是指可以以多种方式访问相同的对象。这些访问点是彼此的别名。

“严格别名”说你只能通过指向该对象的相容类型的指针来访问该对象。

例如，下面这种转换肯定是被允许的：

``` {.c}
int a = 1;
int *p = &a;
```

`p`是指向`int`的指针，并且它指向相容类型---即`int`---所以一切正常。

但以下代码是不好的，因为`int`和`float`不是相容类型：

``` {.c}
int a = 1;
float *p = (float *)&a;
```

这是一个演示程序，做了一些别名处理。它接受一个类型为 `int32_t` 的变量 `v`，并将其赋值为指向 `struct words` 的指针。该 `struct` 里面有两个 `int16_t`。这些类型是不兼容的，因此我们违反了严格别名规则。编译器会假定这两个指针永远不会指向同一个对象... 但我们却让它们指向同一个对象。这是我们的调皮行为。

让我们看看能否搞出什么问题来。

看看我如何将这两个不兼容的指针传递给 `fun()`？其中一个类型是 `int32_t*`，另一个是 `struct words*`。

但它们都指向同一个对象：初始化为 `0x12345678` 的32位值。

因此，如果我们查看 `struct words` 中的字段，应该看到该数字的两个16位部分。对吗？

在 `fun()` 循环中，我们递增指向 `int32_t` 的指针。就是这样。但由于 `struct` 指向同一内存，它也应该被更新为相同的值。

所以让我们运行它，并在左边查看32位值，右边查看两个16位部分。它应该匹配^[我逆向打印16位值，因为我使用的是小端机器，这样在这里更容易阅读。]:

``` 
12345679, 1234-5679
1234567a, 1234-567a
1234567b, 1234-567b
1234567c, 1234-567c
1234567d, 1234-567d
```

它确实匹配... _明天再继续！_

让我们尝试使用 `-O3` 和 `-fstrict-aliasing` 编译 GCC：

``` {.default}
12345679, 1234-5678
1234567a, 1234-5679
1234567b, 1234-567a
1234567c, 1234-567b
1234567d, 1234-567c
```

它们相差一个！但它们指向相同的内存！这是怎么回事？答案：像那样别名内存是未定义的行为。_一切皆有可能_，只是不是好的方式。

如果你的代码违反了严格别名规则，它能否运行取决于某人如何决定编译它。而这件事令人沮丧，因为超出了你的控制范围。除非你是某种全能的神。

不太可能，抱歉。

GCC 可以通过 `-fno-strict-aliasing` 强制不使用严格别名规则。使用 `-O3` 和这个标志编译上面的演示程序，会导致输出与预期一致。

最后，_类型转换_ 是指使用不同类型的指针查看相同的数据。在严格别名规则之前，这种事情是相当常见的：

``` {.c}
int a = 0x12345678;
short b = *((short *)&a);   // 违反了严格别名规则
```

如果你想（相对）安全地进行类型转换，请参阅[Union 和类型转换](#union-type-punning)部分。

## 指针差异 {#ptr_differences}

如您在指针算术部分所了解的，你可以从另一个减去一个指针^[假设它们都指向相同的数组对象]来得到它们之间的差异，以数组元素的计数为单位。

现在，这个差异的类型是由实现确定的，因此它可能会因系统而异。

为了更具可移植性，您可以将结果存储在`<stddef.h>`中定义的`ptrdiff_t`类型的变量中。

``` {.c}
int cats[100];

int *f = cats + 20;
int *g = cats + 60;
```

```c
ptrdiff_t d = g - f;  // 差值为40
```

[^^指针相减^]
[^^ptrdiff_t类型-->打印^]
并且可以通过在整数格式说明符前加上`t`来打印它：

```c
printf("%td\n", d);  // 打印十进制数：40
printf("%tX\n", d);  // 打印十六进制数：28
```

[^^ptrdiff_t类型-->打印^]
[^^ptrdiff_t类型^]
[^^指针-->相减^]

## 函数指针

[^^指针-->到函数^]

函数只是内存中的一系列机器指令，因此我们完全可以获取函数第一条指令的指针。

然后调用它。

将函数的指针作为参数传递给另一个函数可能很有用。然后第二个函数可以调用传入的函数。

然而，这种情况的棘手之处在于，C需要知道指向函数的变量的类型。

并且它真的很想知道所有细节。

比如“这是一个指向接受两个`int`参数并返回`void`的函数的指针”。

你如何将所有这些写下来以便声明一个变量？

嗯，事实证明，它看起来非常像函数原型，只不过多了一些括号：

```c
// 声明p为一个函数指针。
// 这个函数返回一个float，接受两个int作为参数。

float (*p)(int, int);
```

同时注意到你不必给参数命名。但如果你愿意，也可以；它们只是被忽略掉而已。

```c
// 声明p为一个函数指针。
// 这个函数返回一个float，接受两个int作为参数。

float (*p)(int a, int b);
```

现在我们知道如何声明一个变量，我们如何知道要分配给它什么？我们如何获取函数的地址？
```

原来获取数组指针一样有一个快捷方式：你可以只引用裸函数名而不使用括号。 （如果你愿意，你可以在前面加上 `&`，但这是不必要的且不符合惯例。）

一旦你有了一个函数指针，你可以通过添加括号和参数列表来调用它。

让我们做一个简单的例子，我通过设置一个指向函数的指针来有效地创建一个函数的别名。然后我们将调用它。

这段代码会输出 `3490`：

``` {.c .numberLines}
#include <stdio.h>

void print_int(int n)
{
    printf("%d\n", n);
}

int main(void)
{
    // 将 p 分配到 print_int 的地址：

    void (*p)(int) = print_int;

    p(3490);          // 通过指针调用 print_int
}
```

注意 `p` 的类型表示 `print_int` 的返回值和参数类型。它必须是这样，否则 C 会抱怨不兼容的指针类型。

这里再举个例子，展示我们如何将一个函数的指针作为参数传递给另一个函数。

我们将编写一个函数，它接受一对整数参数，以及一个操作这两个参数的函数的指针。然后它会打印结果。

``` {.c .numberLines}
#include <stdio.h>

int add(int a, int b)
{
    return a + b;
}

int mult(int a, int b)
{
    return a * b;
}

void print_math(int (*op)(int, int), int x, int y)
{
    int result = op(x, y);

    printf("%d\n", result);
}

int main(void)
{
    print_math(add, 5, 7);   // 12
    print_math(mult, 5, 7);  // 35
}
```

花点时间消化一下。这里的想法是，我们会将一个函数的指针传递给 `print_math()`，然后它会调用那个函数执行一些数学运算。

这样我们可以通过将另一个函数传递给`print_math()`来改变其行为。您可以看到，当我们分别传递函数`add`和`mult`的指针时，我们在第22-23行这样做。

现在，在第13行，我想我们都可以一致认为`print_math()`函数的函数签名是令人瞠目的。而且，如果您能相信，与您可以构建的某些东西相比，这个实际上相当简单直接^[《Go编程语言》从C语言相反的类型声明语法中汲取了灵感]。

但让我们仔细把它消化。原来只有三个参数，但有点难以看清：

``` {.c}
//                      op             x      y
//              |-----------------|  |---|  |---|
void print_math(int (*op)(int, int), int x, int y)
```

第一个`op`是一个指向以两个`int`作为参数并返回一个`int`的函数的指针。这与`add()`和`mult()`的签名匹配。

第二和第三个参数`x`和`y`只是标准的`int`参数。

缓慢而深思地让你的眼睛在函数签名上游走，同时识别出其中的工作部分。对我来说，总是引人注目的一点是序列`(*op)(`，括号和星号。这是指向函数的指针的关键标志。

最后，回到《指针 II》章节，看一个使用内置`qsort()`的函数指针的[示例](#qsort-example)。

[i[指针-->函数]>]