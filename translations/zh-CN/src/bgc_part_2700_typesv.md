# 复合文字和通用选择

这是类型的最后一章！我们将讨论两件事情：

* 如何拥有“匿名”无名称对象及其用途。
* 如何生成与类型有关的代码。

它们并不特别相关，但也没有各自值得单独成章。所以我像叛逆者一样把它们塞在这里！

## 复合文字

这是语言的一个很棒的特性，它允许您即时创建某个类型的对象，而无需将其分配给变量。您可以创建简单类型、数组、`struct`，你说了算。

其主要用途之一是在不想创建临时变量来保存值时，向函数传递复杂的参数。

创建复合文字的方式是将类型名称放在括号内，然后在其后放置初始化列表。例如，一个无名称的 `int` 数组，看起来可能是这样的：

``` {.c}
(int []){1,2,3,4}
```

现在，这行代码本身并不执行任何操作。它创建了一个包含 4 个 `int` 的无名称数组，并且在没有使用它们的情况下丢弃了它们。

我们可以使用指针存储到数组的引用…

``` {.c}
int *p = (int []){1 ,2 ,3 ,4};

printf("%d\n", p[1]);  // 2
```

但这似乎有点冗长来定义数组。我的意思是，我们本可以直接这样做^[这并不完全相同，因为它是一个数组，而不是指向 `int` 的指针。]：

``` {.c}
int p[] = {1, 2, 3, 4};

printf("%d\n", p[1]);  // 2
```

因此，让我们看一个更有用的例子。

### 将无名称对象传递给函数

假设我们有一个函数来对 `int` 数组进行求和：

``` {.c}
int sum(int p[], int count)
{
    int total = 0;

    for (int i = 0; i < count; i++)
        total += p[i];

    return total;
}
```

如果我们想调用它，通常需要这样做，声明一个数组并将值存储在其中以传递给函数：

``` {.c}
int a[] = {1, 2, 3, 4};

int s = sum(a, 4);
```

但是未命名对象使我们有一种跳过变量并直接传递的方法（上面列出了参数名称）。看看这个---我们将用一个未命名数组替换变量 `a` 作为第一个参数传入：

``` {.c}
//                   p[]         count
//           |-----------------|  |
int s = sum((int []){1, 2, 3, 4}, 4);
```

相当巧妙！

### 未命名`struct`s

我们也可以使用 `struct` 来做类似的事情。

首先，让我们不使用未命名对象。我们将定义一个 `struct` 来保存一些 `x`/ `y` 坐标。然后我们将定义一个，将值传递到它的初始化器中。最后，我们将将其传递给一个函数来打印这些值：

``` {.c .numberLines}
#include <stdio.h>

struct coord {
    int x, y;
};

void print_coord(struct coord c)
{
    printf("%d, %d\n", c.x, c.y);
}

int main(void)
{
    struct coord t = {.x=10, .y=20};

    print_coord(t);   // 打印 "10, 20"
}
```

足够简单明了吗？

让我们修改它以使用未命名对象而不是我们传递给 `print_coord()` 的变量 `t`。

我们将只需将 `t` 替换为一个未命名 `struct`：

``` {.c .numberLines startFrom="7"}
    //struct coord t = {.x=10, .y=20};

    print_coord((struct coord){.x=10, .y=20});   // 打印 "10, 20"
```

依然有效！

### 指向未命名对象的指针

你可能已经注意到在上一个示例中，即使我们使用了 `struct`，我们仍然将 `struct` 的副本传递给了 `print_coord()`，而不是传递指向 `struct` 的指针。

事实证明，我们可以像往常一样使用 `&` 来获取未命名对象的地址。

这是因为通常情况下，如果某个操作符适用于特定类型的变量，那么你也可以在该类型的未命名对象上使用该操作符。

让我们修改上面的代码，以便传递指向未命名对象的指针：

``` {.c .numberLines}
#include <stdio.h>

struct coord {
    int x, y;
};

void print_coord(struct coord *c)
{
    printf("%d, %d\n", c->x, c->y);
}

int main(void)
{
    //     注意 &
    //           |
    print_coord(&(struct coord){.x=10, .y=20});   // 输出 "10, 20"
}
```

此外，这也是传递指针指向简单对象的一种不错的方法：

``` {.c}
// 传递指向值为 3490 的 int 的指针
foo(&(int){3490});
```

就是这么简单。

### 未命名对象和作用域

未命名对象的生存期在其作用域结束时结束。这可能会给你带来最大的困扰，如果你创建一个新的未命名对象，获取指向它的指针，然后离开对象的作用域。在这种情况下，指针将指向一个无效的对象。

因此，以下是未定义行为：

``` {.c}
int *p;

{
    p = &(int){10};
}

printf("%d\n", *p);  // 无效：(int){10} 超出了作用域
```

同样地，你不能从函数中返回指向未命名对象的指针。当对象超出作用域时，对象会被释放：

``` {.c .numberLines}
#include <stdio.h>

```c
int *get3490(void)
{
    // 不要这样做
    return &(int){3490};
}

int main(void)
{
    printf("%d\n", *get3490());  // 无效: (int){3490} 超出了作用域
}
```

只需将其范围视为普通本地变量。 您也不能返回指向本地变量的指针。

### 蠢得无名对象示例

您可以在其中放入任何类型并创建一个无名对象。

例如，以下三者实际上是等效的：

``` {.c}
int x = 3490;

printf("%d\n", x);               // 3490（变量）
printf("%d\n", 3490);            // 3490（常量）
printf("%d\n", (int){3490});     // 3490（无名对象）
```

最后一个是无名的，但有点蠢。不如在前一行中做简单的事情。

但希望这会对语法提供更清晰的解释。

## 通用选择 {#type-generics}

这是一个表达式，允许您根据表达式的第一个参数的 _类型_ 选择不同的代码片段。

我们马上就会看一个例子，但重要的是要知道，这在编译时处理，_而不是在运行时_。 这里没有运行时分析。

[i[`_Generic` 关键字]>]

表达式以 `_Generic` 开头，类似于 `switch`，并且至少需要两个参数。

第一个参数是一个具有 _类型_ 的表达式（或变量^[在这里使用的变量确实是一个表达式。]）。 所有表达式都有一个类型。
`_Generic` 的其余参数是要替换为表达式结果的内容的情况，如果第一个参数是该类型的话。

怎么回事？

我们试着来看看。
```

从第9行开始查看`_Generic`表达式。

编译器看到此表达式时，会查看第一个参数的类型。（在此示例中，是变量`i`的类型。）然后它会在各个情况中寻找匹配该类型的内容。然后将参数替换整个`_Generic`表达式。

在这个例子中，`i`是一个`int`，所以匹配到了该情况。然后将字符串替换到表达式中。所以当编译器看到这行代码时，会变成这样：

``` {.c}
    char *s = "that variable is an int";
```

如果编译器在`_Generic`中找不到类型匹配，它会查找可选的`default`情况并使用该情况。

如果在`_Generic`中找不到类型匹配且没有`default`，将会得到一个编译错误。第一个表达式**一定**要匹配到一个类型或`default`。

因为在不断重复编写`_Generic`很麻烦，通常它用于创建一个宏的主体，可以轻松重复使用。

让我们创建一个宏`TYPESTR(x)`，它接受一个参数并返回一个字符串，其中包含该参数的类型。

所以例如，`TYPESTR(1)` 将返回字符串`"int"`。

我们开始吧：

``` {.c}
#include <stdio.h>

#define TYPESTR(x) _Generic((x), \
                        int: "int", \
                        long: "long", \
                        float: "float", \
                        double: "double", \
                        default: "something else")

int main(void)
{
    int i;
    long l;
    float f;
    double d;
    char c;
```

``` {.default}
i = 10
f = 3.14159
s = Hello, world!
```

我们本可以把这一切都压缩成一个大宏，但我把它分成两部分以防止眼睛流血。