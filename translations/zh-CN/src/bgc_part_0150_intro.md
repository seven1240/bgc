<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 你好，世界！

## 从C语言中可以期待什么

> _"这个楼梯通向哪里？"_ \
> _"通向上面。"_
>
> ---雷·斯坦兹和彼得·威廉·本曼，《捉鬼敢死队》

C语言是一种低级语言。

它本来不是。在过去人们用花岗岩雕刻穿孔卡片的时代，C语言是一个摆脱像[flw[assembly|汇编语言]]那样低级语言单调乏味的不可思议方式。

但是在当今现代，当前一代的语言提供了1972年C语言问世时不存在的种种功能。这意味着C语言是一种相当基础的语言，功能不多。它可以做 _任何事情_，但你可能需要费点力气。

那么今天为什么还要使用它呢？

* 作为一个学习工具：C不仅是计算机史上值得尊敬的一部分，而且与当今的语言相比，它与[flw[bare metal|裸机]]有一种连接。学习C语言时，您会了解到软件如何在低级别与计算机内存进行接口。没有安全带。我向您保证，您将编写导致软件崩溃的软件。这也是乐趣的一部分！

* 作为一个实用工具：C仍然用于某些应用程序，如构建[flw[操作系统|操作系统]]或[flw[嵌入式系统|嵌入式系统]]。（尽管[flw[Rust|Rust（编程语言）]]编程语言也把眼光投向了这两个领域！）

如果您熟悉其他语言，C语言的许多东西都很容易。C启发了许多其他语言，在Go、Rust、Swift、Python、JavaScript、Java等各种其他语言中，您将看到它的一些部分。这些部分会很熟悉。

有关 C 语言让人困惑的是_指针_。几乎其他所有内容都是熟悉的，但指针是奇怪的。指针背后的概念可能是你已经了解的，但 C 强迫你对它做出明确的规定，使用你可能以前从未见过的运算符。

这特别阴险，因为一旦你明白了指针，它们突然变得容易起来。但直到那一刻之前，它们是滑溜溜的鳗鱼。

C 中的所有其他内容仅仅是记忆另一种方式（有时是相同的方式！）来做你已经做过的事情。指针是古怪的部分。并且，可以说，即使指针也是一种你可能熟悉的主题的变化。

所以做好准备，迎接一个充满乐趣的冒险，它离计算机的核心如此之近，即使没有使用汇编语言，在所有时间里最具影响力的计算机语言中^[我知道有人会和我争辩，但至少得是前三名，对吧？]。加油！

## 你好，世界！

这是一个 C 程序的经典示例。每个人都在使用它。 (请注意，左侧的数字仅供读者参考，不是源代码的一部分。)

``` {.c .numberLines}
/* Hello world program */

#include <stdio.h>

int main(void)
{
    printf("Hello, World!\n");  // 实际上在这里执行工作
}
```

我们将穿上长袖重型橡胶手套，拿起手术刀，撕开这个东西，看看它的运行原理。所以，准备好，因为我们要开始了。很轻柔地切开…

让我们先解决简单的问题：在 `/*` 和 `*/` 之间的任何内容都是注释，并且编译器会完全忽略它。在 `//` 后的任何内容也一样。这样你就可以留下消息给自己和他人，这样当你未来某一天回来阅读你的代码时，你会知道当初想要做什么。相信我，你会忘记的；这种事总会发生。

现在，`#include` 是什么？恶心！它告诉C预处理器从另一个文件中提取内容并将其插入到代码中。

等等——什么是C预处理器？好问题。编译有两个阶段，预处理器和编译器。以井号开头的任何东西，或者"井号"（`#`），是预处理器在编译器启动之前处理的内容。通常称为 _预处理指令_ 的有 `#include` 和 `#define`。以后再讨论。

在继续之前，我为什么要特别指出井号称为八音符号？答案很简单：我觉得八音符号这个词非常有趣，所以每当我有机会的时候都会毫无理由地传播它的名称。八音符号。八音符号，八音符号，八音符号。

所以_无论如何_。在C预处理器完成预处理后，结果准备好供编译器接手并生成[flw[汇编代码|汇编语言]]、[flw[机器码|机器码]]或者其他操作。机器码是CPU能够理解的“语言”，而且它能够被CPU _非常迅速_地理解。这也是C程序往往执行迅速的原因之一。

暂时不用担心编译的技术细节；只需要知道你的源代码会经过预处理器处理，然后输出经过编译器处理的结果，最终产生一个可执行文件供你运行。

那剩下的这一行呢？[i[`stdio.h`头文件]<]`<stdio.h>`是什么？这就是被称为_头文件_的文件。从末尾的.h就可以看出来。事实上，这是你会逐渐熟悉和喜爱的“标准输入输出” (`stdio`) 头文件。它给了我们访问一堆输入输出功能的权限^[从技术层面上说，它包含了常见输入输出需求的预处理指令和函数原型（稍后会讲到）。]。对于我们的演示程序，我们要输出字符串"Hello, World!"，所以我们特别需要访问 [i[`printf()` 函数]<] `printf()` 函数来实现这个目的。`<stdio.h>` 文件提供了这个访问权限。基本上，如果我们尝试使用`printf()`却没有`#include <stdio.h>`，编译器会向我们抱怨。

我是怎么知道我需要为`printf()` `#include <stdio.h>`？[i[`printf()`函数]>] 答案：在文档中有写明。如果你使用的是Unix系统，查看`man 3 printf`，页面顶部就会告诉你需要哪些头文件。或者参考本书的参考资料部分。`:-)` [i[`stdio.h`头文件]>]

天哪。这些都是为了解释第一行！但是，让我们面对现实，它已经被完全解剖了。没有任何谜题会留下！

所以休息一下...回过头来看看示例代码。只剩下几行简单的代码了。

欢迎回来！我知道你实际上并没有休息；我只是逗你玩。

下一行是 `main()`。这是 `main()` 函数的定义；花括号 (`{` 和 `}`) 中的所有内容都是函数定义的一部分。

（无论如何你如何**调用**不同的函数呢？答案就在`printf()`那一行，不过我们待会再说。）

现在，`main` 函数在很多方面都是特殊的，但有一个方面超越其他：它是程序启动时会自动调用的函数。在 `main()` 之前不会调用程序中的任何部分。在我们的例子中，这很好用，因为我们只想打印一行然后退出。

哦，忘了告诉你：一旦程序执行到`main()`的末尾，也就是那里的闭合花括号，程序就会退出，你会回到命令提示符下。

所以现在我们知道，程序已经引入了一个头文件 `stdio.h`，并声明了一个当程序启动时将会执行的 `main()` 函数。`main()` 函数里有哪些好东西呢？

我很高兴你问了。真的！我们只有一个好东西：调用函数 `printf()`。你可以根据一些方式判断这是一个函数调用而不是函数定义，但其中一个指标是它后面没有花括号。然后用分号结束函数调用，这样编译器就知道这是表达式的结尾。你会发现几乎所有的东西后面都要加上分号。

将一个参数传递给函数`printf()`，在调用该函数时会打印一个字符串。哦，是的---我们在调用一个函数！我们很厉害！等等，等等---不要变得自大。这个字符串末尾的疯狂`\n`是什么意思？大部分字符串中的字符会被打印出来，就像它们存储的那样。但是有些字符无法很好地在屏幕上打印出来，它们被嵌入为两个字符的反斜杠代码。其中最流行的之一是`\n`（读作"反斜杠-N"或简单地说是"换行符"），对应的是_换行符_字符。这个字符会导致进一步的打印在下一行的开头继续，而不是在当前行的结尾。就像在一行的结尾按下回车键一样。

所以将那段代码复制到一个名为`hello.c`的文件中，然后对其进行构建。在类Unix平台上（例如Linux、BSD、Mac或WSL），你可以通过以下命令进行构建：

```
gcc -o hello hello.c
```

（这意味着"编译`hello.c`，并输出一个名为`hello`的可执行文件"。）

完成后，你应该有一个名为`hello`的文件，可以使用以下命令运行：

```
./hello
```

（开头的`./`告诉shell"从当前目录运行"。）

然后看看会发生什么：

```
Hello, World!
```

已完成并经过测试！可以发布了！

## 编译细节

让我们更加深入地讨论如何构建C程序，以及在幕后发生的情况。

和其他语言一样，C也有_源代码_。但是，根据你来自的语言不同，你可能从未不必将源代码_编译_成一个_可执行文件_。

编译是将你的 C 源代码转换为操作系统可以执行的程序的过程。

JavaScript 和 Python 开发人员根本不习惯分开编译步骤——尽管在幕后确实发生着！Python 将你的源代码编译成一种叫做 _字节码_ 的东西，Python 虚拟机可以执行。Java 开发人员习惯于编译，但这会生成 Java 虚拟机的字节码。

在编译 C 时，会生成 _机器码_。这是 CPU 直接且快速执行的 1 和 0。

> 通常不经过编译的语言称为 _解释型_ 语言。但就像我们在 Java 和 Python 中提到的一样，它们也有编译步骤。并没有规定 C 不能被解释。 （已经有 C 解释器存在！）总的来说，这些都是一片灰色地带。编译一般来说就是将源代码转换为另一种更易执行的形式。

C 编译器是进行编译的程序。

正如我们已经提到的，`gcc` 是安装在很多 [flw[Unix-like operating systems|Unix]] 上的编译器。它通常在终端命令行中运行，但不总是。你也可以在 IDE 中运行它。

那么该如何进行命令行构建呢？

## 使用 `gcc` 进行构建

[i[`gcc` 编译器]<]如果在当前目录中有一个名为 `hello.c` 的源文件，你可以使用在终端中输入以下命令将其构建为一个名为 `hello` 的程序：

``` {.zsh}
gcc -o hello hello.c
```

`-o` 的意思是“输出到这个文件”。如果你没有给它一个输出文件名，它会默认导出到一个叫做 `a.out` 的文件中---这个文件名的历史根源深深植根于 Unix 历史中。在末尾是 `hello.c`，这是我们想要编译的文件的名称。

如果你的源文件被分成多个文件，你可以一起编译它们（几乎就像它们是一个文件一样，但规则实际上比那更复杂），只要将所有的 `.c` 文件放在命令行上：

``` {.zsh}
gcc -o awesomegame ui.c characters.c npc.c items.c
```

它们将一起构建成一个大型可执行文件。

这已经足够开始了---稍后我们会详细讨论多个源文件、目标文件以及各种有趣的东西。

## 使用 `clang` 进行构建

在 Mac 上，原始编译器并不是 `gcc`---而是 `clang`。但也安装了一个包装器，这样你就可以运行 `gcc` 并让它仍然工作。

你也可以通过 Homebrew 或其他方式安装正确的 `gcc` 编译器。

## 通过 IDE 进行构建

如果你正在使用 _集成开发环境_（IDE），你很可能不必从命令行构建。

在 Visual Studio 中，`CTRL-F7` 会构建，`CTRL-F5` 会运行。

在 VS Code 中，你可以通过调试器按 `F5` 运行。 （你将需要安装 C/C++ 扩展。）

在 XCode 中，你可以用 `COMMAND-B` 构建，用 `COMMAND-R` 运行。 若要获取命令行工具，搜索“XCode 命令行工具”，你会找到安装它们的说明。

对于入门，我鼓励你也尝试从命令行构建---这是历史的延续！

C语言多年来发展很长，有很多命名的版本号来描述你使用的语言的方言。

这些通常指的是规范的年份。

最著名的是C89、C99、C11和C2x。本书将重点介绍后者。

以下是一个更完整的表格：

|版本|描述|
|-----|--------------|
|K&R C|1978年的原始版本。以Brian Kernighan和Dennis Ritchie的名字命名。Ritchie设计和编写了这门语言，而Kernighan共同编写了关于它的书籍。如今很少看到原始的K&R代码。如果你看到了，它看起来会很奇怪，就像中古英语对现代英语读者来说很奇怪一样。|
|**C89**，ANSI C，C90|在1989年，美国国家标准协会（ANSI）制定了一项C语言规范，为当今的C语言奠定了基调。一年后，国际标准化组织（ISO）接手并制定了完全相同的C90。|
|C95|C89的一个很少提及的补充，包括宽字符支持。|
|**C99**|第一个大规模改革，增加了许多语言功能。大多数人记住的是添加了`//`风格的注释。截至撰写本文时，这是目前使用最广泛的C版本。|
|**C11**|这个重大版本更新包括Unicode支持和多线程。请注意，如果开始使用这些语言特性，可能会牺牲与仍处于C99水平的地方的可移植性。但老实说，1999年已经有一段时间了。|
|C17，C18|C11的错误修复更新。C17似乎是官方名称，但该版本一直延迟到2018年才发布。据我所知，这两个版本是可以互换的，但C17更受偏爱。|
|C2x|接下来会是什么！预计最终会成为C23。|

你可以使用`-std=`命令行参数来强制GCC使用其中一种标准。如果你想要它对标准要求更严格，添加`-pedantic`。

例如：

``` {.zsh}
gcc -std=c11 -pedantic foo.c
```

对于这本书，我使用所有警告设置来为C2x编译程序：

``` {.zsh}
gcc -Wall -Wextra -std=c2x -pedantic foo.c
```