```c
// Beej's C指南

# vim: ts=4:sw=4:nosi:et:tw=72

```

# 多文件项目

到目前为止，我们一直在研究那些大多可以放在一个文件中的玩具程序。但是复杂的C程序由许多文件组成，所有这些文件都会被编译和链接到一个单独的可执行文件中。

在本章中，我们将了解一些组合更大项目的常见模式和实践。

## 包含和函数原型 {#includes-func-protos}

一个非常普遍的情况是，有些函数在一个文件中定义，而你想在另一个文件中调用它们。

这实际上默认是可以工作的，但会带来一个警告... 让我们先尝试一下，然后看看正确修复警告的方法。

在这些示例中，我们将文件名称作为源代码中的第一个注释。

要编译它们，你需要在命令行中指定所有的源文件：

``` {.zsh}
# 输出文件   源文件
#     v            v
#   |----| |---------|
gcc -o foo foo.c bar.c
```

在这个示例中，`foo.c` 和 `bar.c` 会被编译成名为 `foo` 的可执行文件。

现在让我们看一下源文件 `bar.c`：

``` {.c .numberLines}
// 文件 bar.c

int add(int x, int y)
{
    return x + y;
}
```

以及包含 `main` 函数的 `foo.c` 文件：

``` {.c .numberLines}
// 文件 foo.c

#include <stdio.h>

int main(void)
{
    printf("%d\n", add(2, 3));  // 5!
}
```

注意看，从 `main()` 中我们调用了 `add()`--- 但 `add()` 实际上在一个完全不同的源文件中！在 `bar.c` 中定义，而调用却在 `foo.c` 中！

如果我们用下面的命令编译：

``` {.zsh}
gcc -o foo foo.c bar.c
```

会得到如下错误：

``` {.default}
error: implicit declaration of function 'add' is invalid in C99
```

(或者你可能会收到警告。你不应该忽视。在C中决不要忽视警告；要处理它们。)

如果你还记得[原型部分](#prototypes)里的内容，隐式声明在现代C中是被禁止的，而且没有合法的理由将其引入新的代码中。我们应该修复它。

所谓的`隐式声明`意味着我们在这种情况下使用了一个函数，即`add()`，而不事先让C知道任何关于它的信息。C想知道它返回什么，它接受什么类型的参数等等。

我们之前看到了如何用函数原型来修复这个问题。确实，如果我们在调用前在`foo.c`中添加一个函数原型，一切都会很好运行：

``` {.c .numberLines}
// 文件 foo.c

#include <stdio.h>

int add(int, int);  // 添加原型

int main(void)
{
    printf("%d\n", add(2, 3));  // 5!
}
```

再也没有错误了！

但这真是一件麻烦事情——每次想要使用一个函数都需要输入原型。我的意思是，我们刚才用了`printf()`，并不需要输入原型；这是怎么回事？

如果你还记得书的开头的`hello.c`，_我们实际上是包含了`printf()`的原型的_！它在`stdio.h`文件里！而我们通过`#include`包含了它！

我们能不能对我们的`add()`函数做同样的事呢？为它创建一个原型，并将其放在头文件里？

当然可以！

在C中，头文件默认使用`.h`扩展名。它们通常，但并不总是，和它们对应的`.c`文件有相同的名称。所以让我们为我们的`bar.c`文件创建一个`bar.h`文件，并将原型放进去：

``` {.c .numberLines}
// 文件 bar.h

int add(int, int);
```

现在让我们修改`foo.c`文件以包含那个文件。假设它和`foo.c`在同一个目录下，我们使用双引号将其引入（与尖括号相对）：

``` {.c .numberLines}
// 文件 foo.c

#include <stdio.h>

#include "bar.h"  // 从当前目录包含

int main(void)
{
    printf("%d\n", add(2, 3));  // 5!
}
```

注意我们不再在 `foo.c` 文件中有原型声明了---我们从 `bar.h` 中包含了它。现在 _任意_ 想要使用 `add()` 功能的文件只需要通过 `#include "bar.h"` 来获取，而你不用担心要手动输入函数原型。

正如你可能猜到的那样，`#include` 命令就是将指定的文件 _直接_ 包含在你的源代码中，就好像你亲自输入了一样。

构建并运行：

``` {.zsh}
./foo
5
```

确实，我们得到了$2+3$的结果！耶！

但还不要着急开启你的随意小酌时间。我们快成功了！只需再添加一个标准样板文件。

[i[多文件项目-->函数原型]>]

## 处理重复包含

头文件本身可能会`#include`其他为了相应的C文件功能所需的头文件。我是说，为什么不呢？

可能你会发现同一个头文件在不同地方被多次`#include`进来。或许这没问题，但这样或许会导致编译错误。而我们也控制不了会被多少地方`#include`这个头文件！

更糟糕的是，我们可能陷入一个疯狂的情况，头文件 `a.h` 包含了头文件 `b.h`，而 `b.h` 又包含了 `a.h`！这就是一个 `#include` 无限循环！

试图构建这样的情况会报错：

``` {.default}
error: #include nested depth 200 exceeds maximum of 200
```

我们需要做的是，确保如果一个文件被包含过一次，那么对于该文件的后续 `#include` 都会被忽略。

**我们即将要做的事情非常常见，你应该每次创建头文件时都自动做这个操作！**

``` {.c .numberLines}
#ifndef BAR_H   // 如果BAR_H未定义...
#define BAR_H   // 定义它（没有特定的值）

// 文件bar.h

int add(int, int);

#endif          // 结束 #ifndef BAR_H
```

```c
// 目标文件

这不是规范的一部分，但在C世界中99.999%是常见的。

您可以将C文件编译成一个称为_目标文件_的中间表示形式。这些是已编译但尚未制作成可执行文件的机器代码。

在Windows中，目标文件的扩展名是`.OBJ`; 在类Unix系统中，它们是`.o`。

在gcc中，我们可以像这样构建一些内容，使用`-c`（仅编译！）标志：

``` {.zsh}
gcc -c foo.c     # 生成 foo.o
gcc -c bar.c     # 生成 bar.o
```

然后我们可以将这些文件链接在一起形成一个单独的可执行文件：

``` {.zsh}
gcc -o foo foo.o bar.o
```

_大功告成_，我们从这两个目标文件生成了一个可执行的`foo`。

但你可能会想，为什么要麻烦呢？我们不可以简单地：

``` {.zsh}
gcc -o foo foo.c bar.c
```

一箭双雕吗？

对于小型程序来说，这样做没有问题。我经常这样做。

但对于较大的程序，我们可以利用这样一个事实：从源代码编译到目标文件相对较慢，而链接多个目标文件相对较快。

这一点在`make`工具中尤为突出，该工具仅重新构建那些较新的源文件。

假设你有一千个C文件。你可以先将它们全部编译成目标文件（较慢），然后将所有这些目标文件组合成一个可执行文件（较快）。

现在假设你只修改了其中一个C源文件---这里就是它的神奇之处：_您只需要为该源文件重新构建那一个目标文件_！然后重新构建可执行文件（较快）。其他所有C文件都不必再次触及。
```

```c
// 在其他词汇中，只有重建我们需要的目标文件，我们可以显著缩短编译时间。（当然，除非您正在进行"clean"构建，这种情况下所有目标文件都必须被创建。）

[i[目标文件]>]
[i[多文件项目]>]
```