# 多文件项目

到目前为止，我们一直在看一些基本上可以放在一个文件中的玩具程序。但是复杂的C程序由许多文件组成，所有这些文件都会被编译和链接在一起形成一个可执行文件。

在本章中，我们将探讨一些组合更大项目的常见模式和实践。

## 包含和函数原型 {#includes-func-protos}

一个非常常见的情况是，一些函数在一个文件中定义，而你想从另一个文件中调用它们。

实际上，这默认情况下是可以工作的，但会有警告... 让我们首先尝试一下，然后再看看如何正确修复警告。

对于这些示例，我们将文件名放在源文件的第一个注释中。

要编译它们，你需要在命令行上指定所有的源文件：

``` {.zsh}
# 输出文件   源文件
#     v            v
#   |----| |---------|
gcc -o foo foo.c bar.c
```

在这个示例中，`foo.c` 和 `bar.c` 将被构建成一个名为 `foo` 的可执行文件。

现在让我们看看源文件 `bar.c`：

``` {.c .numberLines}
// 文件 bar.c

int add(int x, int y)
{
    return x + y;
}
```

以及包含 `main` 的文件 `foo.c`：

``` {.c .numberLines}
// 文件 foo.c

#include <stdio.h>

int main(void)
{
    printf("%d\n", add(2, 3));  // 5!
}
```

注意从 `main()` 中我们如何调用 `add()` --- 但 `add()` 实际上在完全不同的源文件中！它在 `bar.c` 中定义，而对它的调用在 `foo.c` 中！

如果我们用以下方式构建它：

``` {.zsh}
gcc -o foo foo.c bar.c
```

我们将会得到以下错误：

``` {.default}
error: implicit declaration of function 'add' is invalid in C99
```

（或许你会收到一个警告。不要忽视它。在C语言中永远不要忽视警告；要解决它们。）

如果你回忆一下[原型部分](#prototypes)中的内容，隐式声明在现代C语言中是被禁止的，而且没有合理的理由在新代码中引入它们。我们应该修复它。

所谓的“隐式声明”意味着我们在这种情况下使用了一个函数，即`add()`，但在事先没有让C语言知道有关函数的任何信息。C语言想要知道它的返回值，它接受哪些类型的参数等等。

我们之前已经看到了如何通过一个“函数原型”来修复这个问题。的确，如果我们在调用前在`foo.c`中添加了一个原型，一切都能正常工作：

``` {.c .numberLines}
// 文件 foo.c

#include <stdio.h>

int add(int, int);  // 添加原型

int main(void)
{
    printf("%d\n", add(2, 3));  // 5!
}
```

不再有错误提示！

但这很烦人——每次想要使用一个函数都需要输入原型。我的意思是，刚刚我们用了`printf()`而不需要输入原型；怎么回事？

如果你还记得在本书开头的`hello.c`中，_实际上我们的确包含了`printf()`的原型_！它在`stdio.h`文件中！而且我们使用`#include`将其包含进来了！

我们能否对我们的`add()`函数做同样的事情？为它创建一个原型并将其放在一个头文件中？

当然可以！

在C语言中，头文件默认使用`.h`扩展名。它们通常但并非总是和对应的`.c`文件同名。所以让我们为`bar.c`文件创建一个`bar.h`文件，并将原型放进去：

``` {.c .numberLines}
// 文件 bar.h

int add(int, int);
```

现在让我们修改`foo.c`以包含这个文件。假设它在同一个目录中，我们使用双引号来包含它（与尖括号不同）：

``` {.c .numberLines}
// 文件 foo.c

#include <stdio.h>

#include "bar.h"  // 从当前目录包含

int main(void)
{
    printf("%d\n", add(2, 3));  // 5!
}
```

请注意，我们不再在 `foo.c` 中有函数原型---我们从 `bar.h` 包含了它。现在 _任何_ 需要 `add()` 功能的文件都可以简单地通过 `#include "bar.h"` 来获取它，你不需要担心键入函数原型。

正如你可能猜到的那样，`#include` 在你的源代码中_直接包含_了命名的文件，就好像你自己键入一样。

然后编译并运行：

``` {.zsh}
./foo
5
```

确实，我们得到了 $2+3$ 的结果！太棒了！

但不要匆忙打开你的饮料，我们快要完成了！我们只需再添加一个样板文件的部分。

[i[多文件项目-->函数原型]>]

## 处理重复包含

一个头文件会引入其他为了对应C文件功能所需要的头文件，这并不罕见。我是说，为什么不呢？

有可能你的一个头文件被从不同位置多次 `#include`。也许这没问题，但也可能导致编译器错误。我们无法控制 `#include` 的位置！

更糟糕的是，我们可能会陷入这样一个疯狂的情况，即头文件 `a.h` 包含头文件 `b.h`，而 `b.h` 又包含 `a.h`！这就是一个`#include` 无限循环！

尝试构建这样一个东西会导致错误：

``` {.default}
error: #include 嵌套深度200超出最大值200
```

我们需要做的是，如果一个文件被包含一次，那么对于该文件的后续 `#include` 应该被忽略。

**接下来我们要做的事情是如此常见，以至于你应该每次制作头文件时都自动执行它！**

这通常是通过预处理器变量实现的，我们在第一次`#include`文件时设置该变量。然后在后续的`#include`时，我们首先检查该变量是否已被定义。

通常，变量名会采用头文件的名称，比如`bar.h`，将其转换为大写，并用下划线替换句号：`BAR_H`。

因此，在文件的非常顶部设置一个检查点，以查看是否已经包含过该文件，如果已包含，则将其注释掉。

（不要加一个下划线作为开头（因为一个下划线加一个大写字母是保留的），也不要重复加前导的两个下划线（因为这也是保留的）。）

``` {.c .numberLines}
#ifndef BAR_H   // 如果BAR_H未定义...
#define BAR_H   // 定义它（没有特定的值）

// 文件 bar.h

int add(int, int);

#endif          // 结束 #ifndef BAR_H
```

这将使得头文件只被包含一次，无论有多少地方尝试`#include`它。

[i[Multifile projects-->includes]>]

## `static`和`extern`

[i[`static`存储类]<]
[i[`extern`存储类]<]
[i[多文件项目-->`static`存储类]<]
[i[多文件项目-->`extern`存储类]<]

在多文件项目中，您可以使用`static`关键字确保文件作用域的变量和函数 _不_ 从其他源文件中可见。

您可以使用`extern`引用其他文件中的对象。

有关更多信息，请查阅书中关于[`static`](#static)和[`extern`](#extern)存储类说明符的部分。

[i[`static`存储类]>]
[i[`extern`存储类]>]
[i[多文件项目-->`static`存储类]>]
[i[多文件项目-->`extern`存储类]>]

## 使用目标文件进行编译

目标文件

这不是规格的一部分，但在C世界中99.999%都是这样的。

你可以将C文件编译成称为目标文件的中间表示。这些是编译成机器码的文件，但还没有被放进可执行文件中。

在Windows中，目标文件的扩展名是`.OBJ`；在类Unix系统中，是`.o`。

在gcc中，我们可以像这样构建一些，使用`-c`（仅编译！）标志：

``` {.zsh}
gcc -c foo.c     # 生成 foo.o
gcc -c bar.c     # 生成 bar.o
```

然后我们可以将这些一起 _链接_ 成一个单一的可执行文件：

``` {.zsh}
gcc -o foo foo.o bar.o
```

大功告成，我们从这两个目标文件生成了一个可执行文件 `foo`。

但你可能会想，为什么那么麻烦呢？我们不可以直接：

``` {.zsh}
gcc -o foo foo.c bar.c
```

一举两得吗？

对于小程序来说，这样做没问题。我一直都是这么做的。

但对于大程序来说，我们可以利用从源代码编译到目标文件的速度相对较慢，以及链接一堆目标文件的速度相对较快这一事实。

这在只重新构建新于输出的源文件的`make`实用程序中得到体现。

假设你有一千个C文件。你可以将它们全部编译成目标文件（慢），然后将所有这些目标文件组合成一个可执行文件（快）。

现在假设你只修改了其中一个C源文件---这就是魔法：_你只需要为那个源文件重新构建那个一个目标文件！_ 然后重新构建可执行文件（快）。所有其他C文件就不用改动了。

换句话说，只重新构建我们需要的目标文件，我们可以显著缩短编译时间。（当然，除非你在进行“干净”构建，这种情况下所有目标文件都必须被创建。）