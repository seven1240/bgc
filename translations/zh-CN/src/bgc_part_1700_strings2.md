```c
// Beej's C 指南

# vim: ts=4:sw=4:nosi:et:tw=72

```

# 字符和字符串 II

我们已经讨论过 `char` 类型实际上只是小整数类型... 但对于单引号中的字符来说也是一样的。

但是双引号中的字符串是 `const char *` 类型。

事实证明，还有一些更多类型的字符串和字符，这将引入语言中最臭名昭著的一个问题：多字节/宽字符/Unicode/本地化。

我们将尝试去理解这个问题，但暂时不深入探讨。...现在！

## 转义序列

[i[转义序列]<]

通常我们会使用正常的字母、标点符号和数字构成字符串和字符：

``` {.c}
char *s = "Hello!";
char t = 'c';
```

但如果我们想在其中加入一些无法通过键盘输入的特殊字符（例如 "€"），或者甚至想要一个单引号字符怎么办？我们不能这样写：

``` {.c}
char t = ''';
```

[i[`\` 反斜杠转义]<]

为了实现这些需求，我们使用一种叫做 _转义序列_ 的方法。这些序列由反斜杠字符（`\`）后跟另一个字符组成。这两个（或更多）字符在一起具有特殊意义。

对于单引号字符的例子，我们可以在中间单引号前面加上一个转义符号（即 `\`）来解决这个问题：

[i[`\'` 单引号]<]

``` {.c}
char t = '\'';
```

现在 C 语言知道 `\'` 表示的只是我们想要打印的一个普通引号，而不是字符序列的结尾。

[i[`\'` 单引号]>]

在这种情况下您可以说“backslash”或“escape”（“转义这个引号”），C 开发人员就会明白您在谈论什么。另外，这里的“转义”概念与您的 `Esc` 键或 ASCII `ESC` 码不同。

### 经常使用的转义字符
```

在我看来，这些转义字符占了99.2%的比例^[我随口说的这个数字，但应该差不太远]。

|代码|描述|
|--|------------|
|[i[`\n` 换行]]`\n`|换行字符---在打印时，继续在下一行输出后续内容|
|[i[`\'` 单引号]]`\'`|单引号---用于单引号字符常量|
|[i[`\"` 双引号]]`\"`|双引号---用于字符串文字中的双引号|
|[i[`\\` 反斜杠]]`\\`|反斜杠---用于字符串或字符中的文字`\`|

以下是一些转义字符的示例以及它们在打印时的输出。

``` {.c}
printf("Use \\n for newline\n");  // Use \n for newline
printf("Say \"hello\"!\n");       // Say "hello"!
printf("%c\n", '\'');             // '
```

### 很少使用的转义字符

但还有更多转义字符！只是你不常见到这些。

|代码|描述|
|--|------------|
|[i[`\a` 提示音]]`\a`|提示音。这会使终端发出声音或闪烁，或两者皆有！|
|[i[`\b` 退格]]`\b`|退格。将光标移回一个字符。不删除该字符。|
|[i[`\f` 分页符]]`\f`|分页符。这会移动到下一页，但这已经在现代意义上不太常见。在我的系统中，它的行为类似于`\v`。|
|[i[`\r` 回车]]`\r`|回车。移到同一行的开头。|
|[i[`\t` 水平制表符]]`\t`|水平制表符。移到下一个水平制表符位置。在我的机器上，这会对齐在列数是8的倍数上，但可能因人而异。|
|[i[`\v` 垂直制表符]]`\v`|垂直制表符。移到下一个垂直制表符位置。在我的机器上，这会移到下一行相同列。|
|[i[`\?` 问号]]`\?`|字面上的问号。有时候你需要它来避免三连字符，就像下面所示。|

#### 单行状态更新

[i[`\b` 退格]<]
[i[`\r` 回车]<]

一个使用`\b`或`\r`的用例是显示屏幕同一行上的状态更新，而不引起显示滚动。这里有一个例子，从10开始倒计时。(如果您的编译器不支持线程，可以使用非标准 POSIX 函数 `sleep()`，来自 `<unistd.h>`---如果您不在类 Unix 系统上，请搜索您的平台并找到相应的 `sleep` 函数。)

``` {.c .numberLines}
#include <stdio.h>
#include <threads.h>

int main(void)
{
    for (int i = 10; i >= 0; i--) {
        printf("\rT 减少 %d 秒%s... \b", i, i != 1? "": "");

        fflush(stdout);  // 强制刷新输出

        // 休眠1秒
        thrd_sleep(&(struct timespec){.tv_sec=1}, NULL);
    }

    printf("\r发射！            \n");
}
```

第7行发生了很多事情。首先，我们以`\r`开头，使光标回到当前行的开头，然后用当前倒计时覆盖当前位置。(有个条件运算符确保我们打印出`1 秒`而不是`1 秒钟`。)

此外，在`...`后面有一个空格。这样我们可以正确地覆盖最后一个`.`，当`i`从`10`降到`9`时，获得一个更窄的列。尝试去掉空格看看效果。

最后，我们用`\b`回退覆盖空格，使光标优雅地停在行尾位置。

注意，第14行结尾也有很多空格，以覆盖来自倒计时的已有字符。

最后，我们在这里有一个奇怪的 `fflush(stdout)`，不管那是什么意思。简单来说，大多数终端默认是_行缓冲_的，这意味着直到遇到换行符才实际显示任何内容。由于我们没有换行符（只有 `\r`），如果没有这行代码，程序会一直停在 `Liftoff!`，然后一次性打印所有内容。`fflush()` 可以覆盖这种行为，强制即时输出发生。

[i[`\r` 回车]>]

#### 疑问符转义

[i[`\?` 疑问符]<]

为什么要用这个？毕竟，这样也能正常工作：

``` {.c}
printf("Doesn't it?\n");
```

转义符也能正常工作：

``` {.c}
printf("Doesn't it\?\n");   // 注意 \?
```

那意义何在？！

[i[三问号]<]

让我们更强调一下，加一个问号和一个感叹号：

``` {.c}
printf("Doesn't it??!\n");
```

当我编译时，会收到这个警告：

``` {.zsh}
foo.c: In function ‘main’:
foo.c:5:23: warning: trigraph ??! converted to | [-Wtrigraphs]
    5 |     printf("Doesn't it??!\n");
      |    
```

运行程序会得到这个预料之外的结果：

``` {.default}
Doesn't it|
```

那么 _三问号_？这究竟是什么鬼？！

我确信以后我们会重新探讨语言的这个古老角落，简短来说，编译器寻找以 `??` 开头的特定三字符组合，然后用其他字符替换它们。所以，如果你使用一台没有管道符号 (`|`) 的古老终端键盘，你可以输入 `??!`。

你可以通过转义第二个问号来解决这个问题，就像这样：

``` {.c}
printf("Doesn't it?\?!\n");
```

然后它可以被正确编译并按预期运行。

这些天，当然，没有人再使用三字符序列了。但是如果你决定在字符串中强调使用它，那整个`??!`有时会出现。

### 数字转义

此外，还有一些方法可以在字符串或字符常量中指定数字常量或其他字符值。

如果你知道一个字节的八进制或十六进制表示，你可以将其包含在一个字符串或字符常量中。

下表列出了一些示例数字，但可以使用任何十六进制或八进制数字。必要时请使用前导零以保证正确的数字位数。

|代码|描述|
|--|------------|
|`\123`|嵌入具有八进制值`123`的字节，确切为3位数。|
|`\x4D`|嵌入具有十六进制值`4D`的字节，为2位数。|
|`\u2620`|嵌入具有十六进制值`2620`的代码点处的Unicode字符，为4位数。|
|`\U0001243F`|嵌入具有十六进制值`1243F`的代码点处的Unicode字符，为8位数。|

这里有一个不常用的八进制表示法示例，来表示在`A`和`C`之间的字母`B`。通常情况下，这将用于某种特殊的不可打印字符，但我们有其他方法来做到这一点，在下面，这只是一个八进制演示：

``` {.c}
printf("A\102C\n");  // 102是ASCII/UTF-8中的`B`
```

请注意，当以这种方式包含时，八进制数字没有前导零。但是它确实需要是三个字符，所以如果需要请使用前导零补齐。

然而，如今更加常见的是使用十六进制常量。这里有一个演示示例，你不应该使用，但它演示了如何在字符串中嵌入UTF-8字节0xE2、0x80和0xA2，对应于Unicode中的"bullet"字符(•)。

``` {.c}
printf("\xE2\x80\xA2 Bullet 1\n");
printf("\xE2\x80\xA2 Bullet 2\n");
printf("\xE2\x80\xA2 Bullet 3\n");
```

如果你在一个UTF-8控制台上，会产生以下输出（如果不是，则可能是垃圾）：

``` {.default}
• Bullet 1
• Bullet 2
• Bullet 3
```

[i[`\x12` 十六进制值]>]

[i[`\u` Unicode转义]<]
[i[`\U` Unicode转义]<]

但这并不是处理Unicode的好方法。你可以使用`\u`（16位）或`\U`（32位）转义来直接引用Unicode的代码点数字。在Unicode中，bullet是`2022`（十六进制），因此你可以这样做，从而获得更可移植的结果：

``` {.c}
printf("\u2022 Bullet 1\n");
printf("\u2022 Bullet 2\n");
printf("\u2022 Bullet 3\n");
```

请确保在`\u`前面添加足够多的前导零，以确保达到四个字符，或者在`\U`前面添加足够多的前导零，以确保达到八个字符。

[i[`\u` Unicode转义]>]

例如，bullet可以使用`\U`和四个前导零来表示：

``` {.c}
printf("\U00002022 Bullet 1\n");
```

[i[`\U` Unicode转义]>]

但是，谁有时间写这么啰嗦呢？

[i[`\` 反斜杠转义]>]
[i[转义序列]>]