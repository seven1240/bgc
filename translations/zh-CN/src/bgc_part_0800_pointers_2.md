<!-- Beej's C指南

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 指针 II：算术 {#pointers2}

[i[指针-->算术]<]
是时候深入探讨一些新的指针主题了！如果你对指针还不是很熟悉，[请查看指南中关于这个主题的第一部分](#pointers)。

## 指针算术

原来在指针上也可以进行数学运算，尤其是加法和减法。

但是当你这样做时代表着什么呢？

简而言之，如果你有一个指向某种类型的指针，将指针加一就会直接移动到该类型后面的下一个内存单元。

在我们移动指针并查看内存中不同位置时，**重要**的是要确保我们在对指针进行解引用之前一直指向的是内存中的有效位置。如果我们走入了“荒野”并尝试查看那里的内容，这种行为是未定义的，崩溃是一个常见结果。

这与下文的[数组/指针等价](#arraypointerequiv)有点类似，但我们还是要尝试一下。

### 对指针加法

首先，让我们取一个数字数组。

``` {.c}
int a[5] = {11, 22, 33, 44, 55};
```

然后让我们得到这个数组中第一个元素的指针：

``` {.c}
int a[5] = {11, 22, 33, 44, 55};

int *p = &a[0];  // 或者 "int *p = a;" 也同样有效
```

然后通过对指针进行解引用打印出那里的值：

``` {.c}
printf("%d\n", *p);  // 打印 11
```

现在让我们使用指针算术打印出数组中的下一个元素，即索引为1的那个：

``` {.c}
printf("%d\n", *(p + 1));  // 打印 22!!
```

发生了什么事？C知道`p`是一个指向`int`的指针。所以它知道`int`的`sizeof`^[回想一下，`sizeof`运算符会告诉你一个对象在内存中的字节大小。]，它知道要跳过这么多字节，才能找到第一个`int`之后的下一个`int`！

实际上，前面的例子可以用两种等效的方式来写：

``` {.c}
printf("%d\n", *p);        // 输出 11
printf("%d\n", *(p + 0));  // 输出 11
```

因为将`0`加到一个指针上会得到相同的指针。

我们来想想这里的重要性。我们可以用这种方式迭代数组的元素，而不是使用数组：

``` {.c}
int a[5] = {11, 22, 33, 44, 55};

int *p = &a[0];  // 或者 "int *p = a;"同样有效

for (int i = 0; i < 5; i++) {
    printf("%d\n", *(p + i));  // 和p[i]一样！
}
```

这样做的效果和使用数组表示法一样！哦哦！越来越接近数组/指针等价的概念了！本章后面会详细讨论这个问题。

但实际上，这里到底发生了什么？它是如何工作的？

还记得早些时候提到过，内存就像一个大数组，每个数组索引存储一个字节吗？

而且内存中的数组索引有一些名字：

* 内存索引
* 位置
* 地址
* _指针！_

所以指针就是内存中的一个索引。

举个随机的例子，假设一个数字3490被存储在地址（"索引"）23,237,489,202上。如果我们有一个指向那个3490的`int`指针，那个指针的值就是23,237,489,202... 因为指针就是内存地址。同一概念，不同称谓。

现在假设我们有另一个数字4096，存储在紧挨着3490后面的地址23,237,489,210上（比3490高8，因为在这个例子中每个`int`长8字节）。

```c
// 如果我们给指针加上 `1`，实际上它会跳过 `sizeof(int)` 字节到下一个 `int`。它知道要跳这么远，因为它是一个 `int` 指针。如果它是一个 `float` 指针，它会跳过 `sizeof(float)` 字节到下一个 float！

// 所以你可以通过给指针加 `1` 来查看下一个 `int`，加 `2` 来查看后面的一个，以此类推。

### 改变指针

我们在前面的部分看到了如何给指针加一个整数。这次，让我们_修改指针本身_。

你可以直接给任何指针加（或减）整数值！

让我们再做那个例子，不过有几处改动。首先，我会在我们的数字末尾加一个 `999` 作为标记值。这样我们就知道数据的末尾在哪里了。

``` {.c}
int a[] = {11, 22, 33, 44, 55, 999};  // 在这里加上 999 作为标记

int *p = &a[0];  // p 指向 11
```

而且我们也让 `p` 指向数组 `a` 的索引 `0` 处的元素，即 `11`，就像之前一样。

现在---让我们开始_递增_ `p`，使其指向数组的后续元素。一直做到 `p` 指向 `999` 为止；也就是说，我们会一直做直到 `*p == 999`：

``` {.c}
while (*p != 999) {       // 只要 p 指向的东西不是 999
    printf("%d\n", *p);   // 打印它
    p++;                  // 把 p 移动到下一个 int 的位置！
}
```

挺疯狂的，对吧？

当我们运行时，首先 `p` 指向 `11`。然后我们增加 `p`，它指向 `22`，再增加，它指向 `33`。依此类推，直到指向 `999`，我们停止。

### 减去指针

[i[Pointers-->subtracting]<]
你也可以从指针中减去一个值，以到达之前的地址，就像我们之前加上的那样。
```

但是我们也可以通过减法来计算两个指针之间的差距，例如，我们可以计算在两个`int*`之间有多少个`int`。关键在于，这仅适用于单个数组内^[或字符串，实际上是`char`数组。有点奇怪的是，你也可以有一个指针指向数组末尾之后的位置而且仍然可以对其进行数学运算。但禁止在此位置解引用它。]---如果指针指向其他东西，你将得到未定义的行为。

还记得在C语言中字符串是`char*`类型吗？让我们看看能否利用这一点来编写另一种`strlen()`函数的变体来计算字符串的长度。

这个想法是，如果我们有一个指向字符串开头的指针，我们可以通过向前扫描直到找到`NUL`字符来找到指向字符串结尾的指针。

如果我们有一个指向字符串开头的指针，又计算出了指向字符串末尾的指针，我们只需将这两个指针相减就可以得到长度！

``` {.c .numberLines}
#include <stdio.h>

int my_strlen(char *s)
{
    // 从字符串开头开始扫描
    char *p = s;

    // 直到找到NUL字符为止
    while (*p != '\0')
        p++;

    // 返回两指针的差值
    return p - s;
}

int main(void)
{
    printf("%d\n", my_strlen("Hello, world!"));  // 打印出 "13"
}
```

请记住，只能在指向同一数组的两个指针之间进行指针减法运算！
[i[指针-->减法]>]

## 数组/指针等价性 {#arraypointerequiv}

[i[Pointers->array equivalence]<]
终于可以讨论这个啦！我们已经看了很多例子，混合使用了数组表示法，但让我们了解 _数组/指针等价的基本公式_：

``` {.c}
a[b] == *(a + b)
```

研究一下！这两者是等价的，可以互换使用！

我有点过于简化了，因为在我上面的示例中 `a` 和 `b` 都可以是表达式，如果表达式复杂，我们可能需要更多括号来强制运算顺序。

规范总是具体明确的，在 C11 §6.5.2.1¶2 中声明：

> `E1[E2]` 等同于 `(*((E1)+(E2)))`

但有点难以理解。确保如果表达式复杂时加上括号，以确保所有的数学运算按正确顺序进行。

这意味着我们可以 _决定_ 是使用数组表示法还是指针表示法来访问数组或指针（假设指针指向数组的元素）。

让我们使用既有数组表示法又有指针表示法的数组和指针：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int a[] = {11, 22, 33, 44, 55};

    int *p = a;  // p 指向数组 a 的第一个元素，11

    // 以多种方式打印数组 a 的所有元素：

    for (int i = 0; i < 5; i++)
        printf("%d\n", a[i]);      // 使用数组表示法访问 a

    for (int i = 0; i < 5; i++)
        printf("%d\n", p[i]);      // 使用数组表示法访问 p

    for (int i = 0; i < 5; i++)
        printf("%d\n", *(a + i));  // 使用指针表示法访问 a

    for (int i = 0; i < 5; i++)
        printf("%d\n", *(p + i));  // 使用指针表示法访问 p

    for (int i = 0; i < 5; i++)
        printf("%d\n", *(p++));    // 移动指针 p
        //printf("%d\n", *(a++));    // 移动数组变量 a--ERROR!
}
```

所以你可以看到，一般来说，如果你有一个数组变量，你可以用指针或者数组的方式来访问元素。指针变量也一样。

最大的不同在于，你可以**修改**一个指针让它指向一个不同的地址，但是数组变量是做不到这点的。<!--6.3.2.1p2-->

### 函数调用中的数组/指针等价性

这是你肯定会最常遇到这个概念的地方。

如果你有一个接受指针参数的函数，比如：

``` {.c}
int my_strlen(char *s)
```

这意味着你可以传递一个数组或者指针给这个函数，它都会正常工作！

``` {.c}
char s[] = "Antelopes";
char *t = "Wombats";

printf("%d\n", my_strlen(s));  // 没问题！
printf("%d\n", my_strlen(t));  // 这个也可以！
```

这也是为什么这两个函数签名是等价的：

``` {.c}
int my_strlen(char *s)    // 没问题！
int my_strlen(char s[])   // 这个也可以！
```
[i[指针-->数组等价性]>]

## `void`指针

[i[`void*` void pointer]<]
你之前已经见过`void`关键字用在函数中，但是这是完全不同的一个东西。

有时候你可能需要一个指向一个**你不知道类型**的东西的指针。

我知道，再忍耐一下。

基本上有两种用法。

[i[`memcpy()`函数]<]
1. 一个函数需要按字节操作某个东西。比如，`memcpy()`会从一个指针复制内存的字节到另一个指针，但是这两个指针可以指向任何类型。`memcpy()`利用了这样一个事实，就是如果你逐个遍历`char*`，你实际上是在遍历对象的字节，无论对象的类型是什么。关于这点，后面的[多字节值](#multibyte-values)小节会详细介绍。

``` {.c}
// 另一个函数是调用你传递给它的函数（回调），并向你传递数据。 你知道数据的类型，但调用你的函数并不知道。 所以它向你传递`void*`---因为它不知道类型---然后你将其转换为你需要的类型。 内置的[qsort()](https://beej.us/guide/bgclr/html/split/stdlib.html#man-qsort)和[bsearch()](https://beej.us/guide/bgclr/html/split/stdlib.html#man-bsearch)使用了这种技术。

让我们看一个例子，内置的`memcpy()`函数：

``` {.c}
void *memcpy(void *s1, void *s2, size_t n);
```

此函数将从地址`s2`开始的`n`字节内存复制到从地址`s1`开始的内存中。

但看！ `s1`和`s2`都是`void*`！ 为什么？ 这意味着什么？ 让我们运行更多示例来看看。

例如，我们可以使用`memcpy()`复制一个字符串（尽管对于字符串来说更适合使用`strcpy()`）：

``` {.c .numberLines}
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s[] = "Goats!";
    char t[100];

    memcpy(t, s, 7);  // 复制7个字节--包括空终止符！

    printf("%s\n", t);  // "Goats!"
}
```

或者我们可以复制一些`int`：

``` {.c .numberLines}
#include <stdio.h>
#include <string.h>

int main(void)
{
    int a[] = {11, 22, 33};
    int b[3];

    memcpy(b, a, 3 * sizeof(int));  // 复制3个int的数据

    printf("%d\n", b[1]);  // 22
}
```

那个有点疯狂---你看到我们如何使用`memcpy()`了吗？ 我们将数据从`a`复制到`b`，但是我们必须指定要复制多少_字节_，而`int`超过一个字节。

好了，那么---一个`int`占多少个字节呢？ 答案：取决于系统。 但我们可以使用`sizeof`运算符来查看任何类型占多少字节。
```

``` {.c}
// 所以答案是：一个 `int` 占用 `sizeof(int)` 个字节的内存空间。

// 如果我们的数组里有3个 `int`，就像我们在那个例子中展示的那样，那么这3个 `int` 所占用的整个空间大小必须是 `3 * sizeof(int)`。

// （在之前的字符串例子中，更准确的做法应该是复制 `7 * sizeof(char)` 个字节。但是 `char` 按定义总是一个字节大小，所以简化后就是 `7 * 1`。）

// 我们甚至可以使用 `memcpy()` 复制一个 `float` 或一个 `struct`！（尽管这样有些滥用---实际上我们应该用 `=` 来做）：

struct antelope my_antelope;
struct antelope my_clone_antelope;

// ...

memcpy(&my_clone_antelope, &my_antelope, sizeof my_antelope);
```

// 看看 `memcpy()` 有多强大！如果你有一个指向源数据和目的数据的指针，并知道要复制的字节数，你可以复制_任何类型的数据_。

// 想象一下如果没有 `void*`。我们将不得不为每种类型编写专门的 `memcpy()` 函数：
[i[`memcpy()` 函数]>]

``` {.c}
memcpy_int(int *a, int *b, int count);
memcpy_float(float *a, float *b, int count);
memcpy_double(double *a, double *b, int count);
memcpy_char(char *a, char *b, int count);
memcpy_unsigned_char(unsigned char *a, unsigned char *b, int count);

// 等等...太糟糕了！
```

// 只需要使用 `void*` 并且拥有一个可以胜任所有类型的功能，这就好得多了。

// 这就是 `void*` 的威力。你可以编写不关心数据类型却仍能操作数据的函数。

// 但是伴随着伟大的能力就有伟大的责任。也许在这种情况下责任没那么重大，但还是有一些限制。

[`void*` void pointer-->caveats]
1. 你不能在 `void*` 上进行指针算术运算。
2. 你不能对 `void*` 进行解引用。
3. 你不能使用箭头运算符对 `void*` 进行操作，因为箭头运算符也是一种解引用。
4. 你不能对 `void*` 使用数组表示法，因为数组表示法也是一种解引用，同理。[因为要记住，数组表示法只是一种解引用和一些指针运算，而你不能解引用一个 `void*`！]。

而且如果仔细想想，这些规则是有道理的。所有这些操作都依赖于知道指向数据的数据类型的 `sizeof`，而使用 `void*`，我们并不知道指向的数据的大小---它可以是任何类型的数据！

[`void*` void pointer-->caveats]
但等等---如果不能解引用 `void*`，它有什么用呢？

比如说`memcpy()`，它帮助你编写可以处理多种数据类型的通用函数。但其中的奥秘在于，内心深处，_在使用之前你会将 `void*` 转换为另一种类型_！

转换很容易：你可以直接赋值给想要的类型的变量。[你也可以将 `void*` _强制转换_ 为另一种类型，但是我们还没讨论到类型转换。]。

``` {.c}
char a = 'X';  // 单个字符

void *p = &a;  // p 指向 'X'
char *q = p;   // q 也指向 'X'

printf("%c\n", *p);  // 错误--不能解引用 void*！
printf("%c\n", *q);  // 输出 "X"
```

[`memcpy()` 函数]
我们来写一个自己的 `memcpy()` 来尝试一下。我们可以复制字节（`char`），并且我们知道字节数是多少，因为它是作为参数传入的。

``` {.c}
void *my_memcpy(void *dest, void *src, int byte_count)
{
    // 将 void* 转换为 char*
    char *s = src, *d = dest;

    // 现在我们有了 char*，我们可以解引用并复制它们
    while (byte_count--) {
        *d++ = *s++;
    }
```

```c
    // 大多数这些函数返回目的地，以防对调用者有用的话。
    return dest;
}
```

就在开始的地方，我们将 `void*` 复制到 `char*`，这样我们就可以将它们用作 `char*`。就是这么简单。

然后在一个 `while` 循环中有点乐趣，在其中我们递减 `byte_count` 直到它变为假 (`0`)。记住，使用后递减时，表达式的值会被计算（供 `while` 使用），然后才会将变量递减。

在复制操作中有些乐趣，我们将 `*d = *s` 赋给复制的字节，但我们使用后递增这样 `d` 和 `s` 在赋值操作完成后都会移到下一个字节。

最后，大多数的内存和字符串函数返回目的字符串的指针的复制，以防调用者想要使用它。

现在我们做到了这一点，我只想快速指出，我们可以使用这种技术来遍历 `C` 语言中_任何_对象的字节，`float`、`struct` 或任何东西！

[i[`memcpy()` 函数]>]

[i[`qsort()` 函数]<]
[让我们]{#qsort-example}再运行一个内置的 `qsort()` 例程的现实世界示例，这个例程可以通过 `void*` 的魔术来对_任何东西_进行排序。

（在以下示例中，您可以忽略我们尚未涵盖的 `const` 这个词。）

``` {.c .numberLines}
#include <stdio.h>
#include <stdlib.h>

// 我们将要排序的结构类型
struct animal {
    char *name;
    int leg_count;
};
```

```c
// 这是一个由qsort()调用的比较函数，以帮助确定排序的依据。我们将使用它来按照腿的数量对struct animals数组进行排序。
int compar(const void *elem1, const void *elem2)
{
    // 我们知道要排序struct animals，所以让我们将整个参数都转换为struct animals的指针
    const struct animal *animal1 = elem1;
    const struct animal *animal2 = elem2;

    // 根据需要排序的内容返回 <0 =0或>0。

    // 让我们按照腿的数量升序排序，因此我们将返回腿数量的差异
    if (animal1->leg_count > animal2->leg_count)
        return 1;
    
    if (animal1->leg_count < animal2->leg_count)
        return -1;

    return 0;
}

int main(void)
{
    // 让我们构建一个由4个具有不同特征的struct animals组成的数组。这个数组按照腿的数量是无序的，但我们稍后会对其进行排序。
    struct animal a[4] = {
        {.name="Dog", .leg_count=4},
        {.name="Monkey", .leg_count=2},
        {.name="Antelope", .leg_count=4},
        {.name="Snake", .leg_count=0}
    };

    // 调用qsort()来对数组进行排序。qsort()需要准确告诉它要按照什么标准对数据进行排序，我们将在compar()函数中进行定义。
    //
    // 这个调用的意思是：qsort数组a，有4个元素，每个元素的大小是sizeof(struct animal)字节，这是比较任意两个元素的函数。
    qsort(a, 4, sizeof(struct animal), compar);

    // 打印它们全部出来
    for (int i = 0; i < 4; i++) {
        printf("%d: %s\n", a[i].leg_count, a[i].name);
    }
}
```

只要你给`qsort()`传递一个能比较数组中两个要排序项的函数，它就可以对任何东西进行排序。而且它可以在不需要在任何地方硬编码这些项的类型的情况下完成这个任务。`qsort()`只是根据你传入的`compar()`函数的结果重新排列字节块。