## 指针 II：算术 {#pointers2}

[i[指针-->算术]<]
是时候更深入地学习一些新的指针主题了！如果你对指针还不是很熟悉，[可以查看指南中相关部分的第一节](#pointers)。

## 指针算术

事实证明，指针可以进行数学运算，尤其是加法和减法。

但当你这样做的时候是什么意思呢？

简而言之，如果你有一个指向某种类型的指针，将指针加一就会直接移动到该类型后面的下一个项目所在的内存位置。

**重要**的是，当我们移动指针并查看内存中的不同位置时，我们需要确保在对指针进行解引用之前，始终指向的是内存中的一个有效位置。如果我们偏离了正途并试图查看那里的内容，那么行为是未定义的，崩溃是一个常见的结果。

这与[下面的数组/指针等价性](#arraypointerequiv)有点像鸡生蛋还是蛋生鸡的问题，但无论如何我们都要尝试一下。

### 对指针进行加法

首先，让我们取一个数字数组。

``` {.c}
int a[5] = {11, 22, 33, 44, 55};
```

然后我们获取一个指针指向该数组的第一个元素：

``` {.c}
int a[5] = {11, 22, 33, 44, 55};

int *p = &a[0];  // 或者 "int *p = a;" 也可以
```

然后我们通过解引用指针来打印那里的值：

``` {.c}
printf("%d\n", *p);  // 打印 11
```

现在让我们使用指针算术来打印数组中的下一个元素，即索引为 1 的元素：

``` {.c}
printf("%d\n", *(p + 1));  // 打印 22!!
```

发生了什么？C知道`p`是一个指向`int`的指针。因此，它知道`int`的`sizeof`[记住`sizeof`操作符告诉您内存中对象的字节大小]，并且知道要跳过这么多字节才能到达第一个后续的`int`！

实际上，之前的示例可以这样写成两种等价的方式：

``` {.c}
printf("%d\n", *p);        // 输出 11
printf("%d\n", *(p + 0));  // 输出 11
```

因为将`0`加到一个指针上会得到相同的指针。

让我们来想一想这里的要点。我们可以通过这种方式迭代数组的元素，而不是使用数组：

``` {.c}
int a[5] = {11, 22, 33, 44, 55};

int *p = &a[0];  // 也可以使用"int *p = a;"，效果一样好

for (int i = 0; i < 5; i++) {
    printf("%d\n", *(p + i));  // 和 p[i] 一样！
}
```

这和使用数组表示法的效果一样！哦！逼近数组/指针等价的东西了！稍后在本章中将详细讨论这一点。

但实际上，这里发生了什么？它是如何工作的？

早先我们记得，内存就像一个大数组，每个数组索引处存储一个字节吧？

而在内存中的数组索引有一些名称：

* 内存索引
* 位置
* 地址
* _指针！_

因此，指针是内存的一个索引，某处。

举个随机例子，假设数字3490存储在地址（“索引”）23,237,489,202处。如果我们有一个指向那个3490的`int`指针，该指针的值是23,237,489,202...因为指针就是内存地址。同一件事不同的说法。

现在让我们假设我们有另一个数字4096，存储在比3490更高8位的地址23,237,489,210处（比3490高8，因为在这个例子中每个`int`长8字节）。

如果我们给那个指针加 `1`，它实际上会向前跳 `sizeof(int)` 字节到下一个 `int`。它知道要跳那么远，因为它是一个 `int` 指针。如果它是一个 `float` 指针，它会向前跳 `sizeof(float)` 字节到下一个 float！

因此，通过将 `1` 添加到指针，可以查看下一个 `int`，将 `2` 添加到指针查看其后面一个，依此类推。

### 更改指针

在上一节，我们看到了如何将整数添加到指针。这一次，让我们 _修改指针本身_。

您可以直接向任何指针添加（或减去）整数值！

让我们再次进行上面的示例，但有一些更改。首先，我将在我们的数字末尾添加 `999` 作为哨兵值。 这将让我们知道数据的末尾在哪里。

``` {.c}
int a[] = {11, 22, 33, 44, 55, 999};  // 在这里添加 999 作为哨兵

int *p = &a[0];  // p 指向 11
```

现在，`p` 也指向 `a` 的索引 `0` 处的元素，即 `11`，就像之前一样。

现在--- 让我们开始递增 `p`，让它指向数组的后续元素。我们将一直这样做，直到 `p` 指向 `999` 为止；也就是说，我们会持续这样做，直到 `*p == 999`：

``` {.c}
while (*p != 999) {       // 只要 p 指向的东西不是 999
    printf("%d\n", *p);   // 打印它
    p++;                  // 移动 p 指向下一个 int！
}
```

相当疯狂，对吧？

当我们运行它时，首先 `p` 指向 `11`。然后我们递增 `p`，它指向 `22`，再次递增，它指向 `33`。依此类推，直到它指向 `999` 并退出。

### 减去指针

[i[Pointers-->subtracting]<]
您可以从指针减去一个值，以达到较早地址，就像我们之前添加到它们一样。

但是我们也可以通过减法来计算两个指针之间的差异，例如，我们可以计算两个`int*`指针之间有多少个`int`。关键在于，这仅适用于单个数组[^在C中字符串也是`char`类型的数组。有些奇怪的是，你也可以有一个指针，指向数组末尾的下一个位置，而不会出问题，并且仍然可以对其进行数学运算。但是当指针不再数组范围内时，你就无法对其进行解引用操作。]---如果指针指向其他内容，你将获得未定义的行为。

还记得在C中字符串是`char*`吗？让我们看看是否可以利用这一点来编写另一种计算字符串长度的`strlen()`变体。

这种想法是，如果我们有指向字符串开头的指针，我们可以通过向前扫描`NUL`字符来找到指向字符串末尾的指针。

如果我们有指向字符串开头的指针，并计算了指向字符串末尾的指针，我们只需对这两个指针进行减法运算就可以得出长度！

``` {.c .numberLines}
#include <stdio.h>

int my_strlen(char *s)
{
    // 从字符串开头开始扫描
    char *p = s;

    // 扫描直到找到NUL字符
    while (*p != '\0')
        p++;

    // 返回指针之间的差距
    return p - s;
}

int main(void)
{
    printf("%d\n", my_strlen("Hello, world!"));  // 输出 "13"
}
```

请记住，只能在指向同一个数组的两个指针之间进行指针减法运算！

[i[指针-->数组等价性]<]
我们终于准备好讨论这个了！我们已经看到了很多例子，我们混合了数组表示法，但让我们给出数组/指针等价性的基本公式：

``` {.c}
a[b] == *(a + b)
```

研究一下！这两者是等价的，可以互换使用！

我有点过于简化了，因为在上面的例子中，`a` 和 `b` 都可以是表达式，如果表达式很复杂，我们可能需要更多括号来强制执行操作顺序。

规范总是具体的，在 C11 第6.5.2.1¶2 中声明：

> `E1[E2]` 等同于 `(*((E1)+(E2)))`

但这有点难以理解。只需确保如果表达式复杂，则包含括号，以便所有数学操作按正确顺序进行。

这意味着我们可以_决定_对任何数组或指针（假设指向数组元素）使用数组或指针表示法。

让我们使用一个数组和一个指针，分别使用数组和指针表示法：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int a[] = {11, 22, 33, 44, 55};

    int *p = a;  // p 指向数组 a 的第一个元素，11

    // 以各种方式打印数组 a 的所有元素：

    for (int i = 0; i < 5; i++)
        printf("%d\n", a[i]);      // 用 a 的数组表示法

    for (int i = 0; i < 5; i++)
        printf("%d\n", p[i]);      // 用 p 的数组表示法

    for (int i = 0; i < 5; i++)
        printf("%d\n", *(a + i));  // 用 a 的指针表示法

    for (int i = 0; i < 5; i++)
        printf("%d\n", *(p + i));  // 用 p 的指针表示法

    for (int i = 0; i < 5; i++)
        printf("%d\n", *(p++));    // 移动指针 p
        //printf("%d\n", *(a++));    // 移动数组变量 a--错误！
}
```

所以你可以看到，通常情况下，如果你有一个数组变量，你可以使用指针或数组表示法来访问元素。指针变量也一样。

其中一个重要区别是，你可以 _修改_ 一个指针指向不同的地址，但你不能对数组变量做到这点。 

### 函数调用中的数组/指针等价性

这是你肯定会遇到这个概念最多的地方。

如果你有一个接受指针参数的函数，例如：

``` {.c}
int my_strlen(char *s)
```

这意味着你可以将一个数组或一个指针传递给这个函数，并让它工作！

``` {.c}
char s[] = "Antelopes";
char *t = "Wombats";

printf("%d\n", my_strlen(s));  // 可行！
printf("%d\n", my_strlen(t));  // 也可行！
```

这也是为什么这两个函数签名是等价的：

``` {.c}
int my_strlen(char *s)    // 可行！
int my_strlen(char s[])   // 也可行！
```

## `void` 指针

你已经看到了 `void` 关键字与函数一起使用，但这是一个完全独立、不相关的概念。

有时候有一个指针指向一个 _你不知道类型的_ 东西是很有用的。

我知道。请稍等片刻。

基本上有两个用例。

1. 一个函数将逐字节操作某些东西。例如, `memcpy()` 从一个指针复制内存中的字节到另一个指针，但这些指针可以指向任何类型。 `memcpy()` 利用了这样一个事实，即如果你通过 `char*` 迭代，那么你无论对象的类型如何，都是在迭代该对象的字节。有关更多信息，请参阅 [多字节值](#multibyte-values) 子节。

另一个函数是调用您传递给它的函数（一个回调函数），并向您传递数据。您知道数据的类型，但调用您的函数不知道。因此，它向您传递 `void*`---因为它不知道类型---然后您将它们转换为您需要的类型。内置的 [fl[`qsort()`|https://beej.us/guide/bgclr/html/split/stdlib.html#man-qsort]] 和 [fl[`bsearch()`|https://beej.us/guide/bgclr/html/split/stdlib.html#man-bsearch]] 使用这种技术。

让我们看一个例子，内置的 `memcpy()` 函数：

``` {.c}
void *memcpy(void *s1, void *s2, size_t n);
```

此函数从地址 `s2` 开始复制 `n` 字节的内存到从地址 `s1` 开始的内存。

但是看！`s1` 和 `s2` 都是 `void*`！为什么？这是什么意思？让我们运行更多示例以了解更多。

例如，我们可以使用 `memcpy()` 复制一个字符串（虽然对于字符串来说，使用 `strcpy()` 更合适）：

``` {.c .numberLines}
#include <stdio.h>
#include <string.h>

int main(void)
{
    char s[] = "Goats!";
    char t[100];

    memcpy(t, s, 7);  // 复制 7 个字节--包括 NUL 结束符！

    printf("%s\n", t);  // "Goats!"
}
```

或者我们可以复制一些整数：

``` {.c .numberLines}
#include <stdio.h>
#include <string.h>

int main(void)
{
    int a[] = {11, 22, 33};
    int b[3];

    memcpy(b, a, 3 * sizeof(int));  // 复制 3 个整数的数据

    printf("%d\n", b[1]);  // 22
}
```

这个有点疯狂---你看到我们在这里如何使用 `memcpy()` 了吗？我们从 `a` 复制数据到 `b`，但是我们必须指定要复制多少个 _字节_，而一个 `int` 不止一个字节。

好的，接着---一个 `int` 占多少个字节？答案：取决于系统。但是我们可以用 `sizeof` 运算符来确定任何类型占用多少个字节。

所以答案就在这里：一个 `int` 占用 `sizeof(int)` 字节的内存来存储。

如果我们在数组中有3个，就像我们在那个示例中所做的一样，那么用于这3个 `int` 所用的整个空间必须是 `3 * sizeof(int)`。

（在前面的字符串示例中，更精确的做法是复制 `7 * sizeof(char)` 字节。但是按照定义，`char` 总是一个字节大，所以这只会变成 `7 * 1`。）

我们甚至可以用 `memcpy()` 复制一个 `float` 或一个 `结构体`！（虽然这是一种滥用——我们应该只使用 `=` 进行赋值）：

``` {.c}
struct antelope my_antelope;
struct antelope my_clone_antelope;

// ...

memcpy(&my_clone_antelope, &my_antelope, sizeof my_antelope);
```

看看 `memcpy()` 有多么灵活！如果你有一个指向源和一个指向目标的指针，并且知道你想要复制的字节数，你可以复制 _任何类型的数据_。

想象一下如果没有 `void*` 。我们将不得不为每种类型编写专门的`memcpy()` 函数：

``` {.c}
memcpy_int(int *a, int *b, int count);
memcpy_float(float *a, float *b, int count);
memcpy_double(double *a, double *b, int count);
memcpy_char(char *a, char *b, int count);
memcpy_unsigned_char(unsigned char *a, unsigned char *b, int count);

// 等等... 有够烦人！
```

最好的办法就是只使用 `void*` 并只有一个可以执行所有操作的函数。

这就是 `void*` 的威力。你可以编写不关心类型的函数，但仍然可以对其进行操作。

但是伴随着巨大的力量来着极大的责任。也许在这种情况下不是那么_巨大_，但是也有些限制。

1. 你无法对 `void*` 执行指针算术。
2. 你无法对 `void*` 解引用。
3. 你无法对 `void*` 使用箭头运算符，因为箭头运算符也是解引用操作。
4. 你无法对 `void*` 使用数组表示法，因为数组表示法也是解引用操作^[请记住，数组表示法实际上就是解引用和一些指针数学运算，而你无法对 `void*` 进行解引用操作！]。

如果你仔细思考一下，这些规则是有道理的。所有这些操作都依赖于知道指向数据的类型的 `sizeof`，而对于 `void*`，我们不知道指向的数据的大小---它可能是任何类型的数据！

但是等等---如果你不能对 `void*` 进行解引用，它到底能有什么用处呢？

就像使用 `memcpy()` 一样，它帮助你编写能够处理多种数据类型的通用函数。但秘诀是，在深层，_你在使用它之前将 `void*` 转换为另一种类型_！

并且转换很简单：你可以直接赋给一个期望的类型的变量^[你也可以 _将_ `void*` 转换为另一种类型，但我们还没有讲解类型转换。]。

``` {.c}
char a = 'X';  // 一个单个字符

void *p = &a;  // p 指向 'X'
char *q = p;   // q 也指向 'X'

printf("%c\n", *p);  // 错误--无法解引用 void*！
printf("%c\n", *q);  // 输出 "X"
```

[i[`memcpy()` 函数]<]
让我们自己编写 `memcpy()` 函数来尝试一下。我们可以复制字节（`char`），并且由于传入了字节数，我们知道要复制的字节数。

``` {.c}
void *my_memcpy(void *dest, void *src, int byte_count)
{
    // 将 void* 转换为 char*
    char *s = src, *d = dest;

    // 现在我们有了 char*，可以解引用并复制它们
    while (byte_count--) {
        *d++ = *s++;
    }

```c
    // 大多数这些函数返回目的地，以防对调用者有用。
    return dest;
}
```

// 就在一开始，我们将 'void*' 复制到 'char*' 中，这样我们就可以将它们作为 'char*' 使用。就是这么简单。

然后在一个 while 循环中玩一些乐趣，我们将 'byte_count' 减少，直到它变为 false（`0`）。请记住，使用后减量时，表达式的值会被计算（供 `while` 使用），然后才会减量变量。

在复制中也有一些乐趣，我们赋值 `*d = *s` 来复制字节，但我们使用后递增来执行此操作，这样在分配完成后，`d` 和 `s` 都会移动到下一个字节。

最后，大多数内存和字符串函数返回目的字符串的指针副本，以防调用者想要使用它。

既然我们做到了，我只想快速指出，我们可以使用这种技术来在 C 中迭代_任何_对象的字节，`float`、`struct` 或其他任何东西！

现在，让我们用内置的 `qsort()` 例程再运行一个真实世界的例子，它可以对_任何东西_进行排序，多亏了 `void*` 的魔法。

（在以下示例中，您可以忽略我们尚未讨论的 `const` 一词。）

```c
#include <stdio.h>
#include <stdlib.h>

// 我们要排序的结构体类型
struct animal {
    char *name;
    int leg_count;
};
```

// 这是一个比较函数，由qsort()调用，帮助确定如何排序。我们将使用它来按 leg_count 对结构数组 animals 进行排序。
// 让我们按照升序 leg_count 进行排序，所以我们将返回 leg_counts 的差异
// 让我们创建一个具有不同特征的 4 个结构体 animals 的数组。这个数组按 leg_count 混乱，但我们马上会对它进行排序。在 compar() 函数中指定排序依据。

只要您提供给`qsort()`一个可以比较您数组中待排序的两个项目的函数，它就可以对任何项目进行排序。而且它做到这一点无需在任何地方硬编码项目的类型。`qsort()`只是根据您传入的`compar()`函数的结果重新排列字节块。