```markdown
<!--
Beej的C指南

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 文件输入/输出

[i[文件I/O]<]
我们已经看过一些使用`printf()`在控制台进行I/O操作的示例。

但是在本章中，我们将进一步探讨这些概念。

## `FILE*` 数据类型

[i[`FILE*` 类型]<]
在C中进行任何类型的I/O操作时，我们通过一个数据片段来实现，这个数据片段以`FILE*`类型的形式呈现。 这个`FILE*`包含了与I/O子系统通信所需的所有信息，比如你打开了哪个文件，文件中的位置等。

规范中将这些称为_流_，也就是来自文件或任何源的数据流。 我将在文中交替使用"文件"和"流"这两个术语，但实际上你应该把一个"文件"看作是一个"流"的特殊情况。 除了从文件中读取外，还有其他将数据流入程序的方法。

我们很快就会看到如何将一个文件名转换为打开的`FILE*`，但在此之前，我想提一下已经为你打开并可以使用的三个流。

[i[`stdin`标准输入]<]
[i[`stdout`标准输出]<]
[i[`stderr`标准错误]<]

|`FILE*`名称|描述|
|-|-|
|`stdin`|标准输入，通常默认为键盘|
|`stdout`|标准输出，通常默认为屏幕|
|`stderr`|标准错误，通常默认为屏幕|

事实上，我们已经在隐式地使用它们了。 例如，以下两个调用是相同的：

``` {.c}
printf("Hello, world!\n");
fprintf(stdout, "Hello, world!\n");  // printf到一个文件
```

但稍后再详细讨论。
```

同样，你会注意到`stdout`和`stderr`都会输出到屏幕上。
乍看起来可能会觉得这是一个疏忽或冗余，但实际上并不是这样。
典型的操作系统允许你将其中任意一个的输出_重定向_到不同的文件中，这样能够方便地将错误消息与常规非错误输出分开。

例如，在类POSIX shell（如sh、ksh、bash、zsh等）上运行在类Unix系统上，我们可以运行一个程序，并将仅非错误（`stdout`）输出发送到一个文件，将所有错误（`stderr`）输出发送到另一个文件。

``` {.zsh}
./foo > output.txt 2> errors.txt   # 此命令仅适用于Unix系统
```

因此，你应该将严重错误消息发送到`stderr`而不是`stdout`。
[i[`stdin` 标准输入]>]
[i[`stdout` 标准输出]>]
[i[`stderr` 标准错误]>]

如何实现这一点将在稍后详述。
[i[`FILE*` 类型]<]

## 读取文本文件

[i[文件I/O-->文本文件，读取]<]
流在很大程度上被分类为两种不同的方式：_文本_和_二进制_。

文本流允许对数据进行重要的翻译，最显著的是换行符的转换为它们的不同表示方式^[我们过去普遍存在三种不同的换行符：回车（CR，旧Mac系统中使用）、换行（LF，Unix系统中使用）和回车/换行（CRLF，Windows系统中使用）。值得庆幸的是，随着OS X的推出，作为基于Unix的系统，这个数量减少到了两种。]。
文本文件在逻辑上是由换行符分隔的_行_序列。为了具有可移植性，你的输入数据应该始终以换行符结束。

但基本原则是，如果你能够在普通的文本编辑器中编辑文件，那么它就是一个文本文件。否则，它就是二进制文件。更多关于二进制文件的内容稍后再说。

让我们开始工作——如何打开一个文件进行读取，并从中提取数据？

让我们创建一个名为 `hello.txt` 的文件，并在其中只包含以下内容：

``` {.default}
Hello, world!
```

然后我们编写一个程序来打开该文件，读取一个字符，最后在完成后关闭文件。这就是我们的计划！

[i[`fopen()` 函数]<]
[i[`fgetc()` 函数]<]
[i[`fclose()` 函数]<]
``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    FILE *fp;                      // 代表打开文件的变量

    fp = fopen("hello.txt", "r");  // 打开文件进行读取

    int c = fgetc(fp);             // 读取单个字符
    printf("%c\n", c);             // 将字符打印到标准输出

    fclose(fp);                    // 完成后关闭文件
}
```

看到了吗，当我们用 `fopen()` 打开文件时，它会返回一个 `FILE*`，以便我们稍后可以使用它。

（出于简洁起见，我没有提到，但是如果出现问题，比如文件不存在，`fopen()` 会返回 `NULL`，因此你真的应该对其进行错误检查！）

还要注意我们传入的 `"r"` ——这意味着"打开一个文本流以供读取"。（我们可以向 `fopen()` 传递各种字符串，具有额外意义，比如写入、追加等。）
[i[`fopen()` 函数]>]

接着，我们使用了 `fgetc()` 函数从流中获取一个字符。也许你会好奇为什么我将 `c` 定义为 `int` 而不是 `char`——先抱着这个想法！
[i[`fgetc()` 函数]>]

最后，当我们完成时关闭流。所有流在程序退出时都会自动关闭，但是明确关闭任何文件是良好的礼仪和管理文件的好方式。
[i[`fclose()` 函数]>]

[`FILE*`类型]`FILE*`会跟踪我们在文件中的位置。因此，随后调用`fgetc()`将获取文件中的下一个字符，依此类推直至文件结尾。

但这听起来有点麻烦。让我们看看能否让它变得更简单。[文件I/O-->文本文件，读取]

## 文件结尾：`EOF`

[`EOF`文件结尾]有一个特殊的宏定义字符：`EOF`。当文件结束并且您尝试读取另一个字符时，`fgetc()`会返回此值。

来分享一个小趣闻™，`EOF`其实是`fgetc()`等函数返回`int`而不是`char`的原因。`EOF`不是一个正确的字符，并且其值很可能超出`char`的范围。由于`fgetc()`需要能返回任何字节**以及**`EOF`，它需要更宽的类型来存储更多不同的值。所以就是`int`了。但是除非您将返回的值与`EOF`进行比较，否则您始终可以明白，它其实是个`char`。

好了！回到现实！我们可以利用这点来在循环中读取整个文件。

[`fopen()`函数]
[`fgetc()`函数]
[`fclose()`函数]
``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    FILE *fp;
    int c;

    fp = fopen("hello.txt", "r");

    while ((c = fgetc(fp)) != EOF)
        printf("%c", c);

    fclose(fp);
}
```
[`fopen()`函数]
[`fclose()`函数]

(如果第10行看起来太奇怪，可以从最内层括号开始分解。我们首先将`fgetc()`的结果赋值给`c`，然后将其与`EOF`进行比较。我们刚刚将它压缩到一行中。这可能看起来难以阅读，但请仔细研究下---这是典型的C风格。)
[`fgetc()`函数]

运行后，我们将看到：

``` {.default}
Hello, world!
```

但即使如此，我们仍然是逐个字符地操作，许多文本文件在逐行级别上更有意义。让我们切换到那种模式。

```c
#include <stdio.h>

int main(void)
{
    FILE *fp;
    char name[1024];  // 足够大以容纳此程序遇到的任何行
    float length;
    int mass;

    fp = fopen("whales.txt", "r");

    while (fscanf(fp, "%s %f %d", name, &length, &mass) != EOF)
        printf("%s 鲸鱼，%d 吨，%.1f 米\n", name, mass, length);

    fclose(fp);
}
```

``` {.default}
蓝鲸，173吨，29.9米
右鲸，135吨，20.7米
灰鲸，41吨，14.9米
座头鲸，30吨，16.0米
```

这些工作方式与文本文件非常相似，只是I/O子系统不会像处理文本文件那样在数据上执行任何转换。使用二进制文件，你会得到一串原始字节流，就是这样简单。

在打开文件时的一个重要差异是，你需要在模式中添加一个`"b"`。也就是说，要读取二进制文件，以`"rb"`模式打开它。要写入文件，以`"wb"`模式打开它。

由于这是字节流，字节流中可以包含NUL字符，而NUL字符是C中的字符串结束标记，很少有人会使用`fprintf()`等函数操作二进制文件。

而是最常见的函数是`fread()`和`fwrite()`。这些函数可以读取和写入指定数量的字节到流中。

为了演示，我们将编写一些程序。其中一个程序会一次将一系列字节值写入磁盘。第二个程序会一次读取一个字节并将其打印出来。通常第二个程序会一次性读取所有字节，然后在循环中打印它们。那样会更有效率。但我们这里是为了演示价值。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    FILE *fp;
    unsigned char bytes[6] = {5, 37, 0, 88, 255, 12};

    fp = fopen("output.bin", "wb");  // 以"写入二进制"的模式打开文件！

    // 在调用fwrite函数时，参数依次为：
    //
    // * 指向要写入数据的指针
    // * 每个数据的大小
    // * 每个数据的数量
    // * FILE*

    fwrite(bytes, sizeof(char), 6, fp);

    fclose(fp);
}
```

```c
// 这两个中间参数传给 `fwrite()` 的有点奇怪。基本上我们要告诉这个函数的是，“我们有这么大的项，我们要写这么多个。” 当你有一个固定长度的记录且有一堆记录时，这种方式就很方便。你只需告诉它一个记录的大小以及要写入多少个。

// 在上面的示例中，我们告诉它每个记录都是一个 `char` 大小，并且我们有 6 个这样的记录。

// 运行程序会得到一个文件 `output.bin`，但是在文本编辑器中打开却看不到友好的内容！因为这是二进制数据---不是文本。而且还是我随意编造的随机二进制数据！

// 如果我通过一个 [flw[hex dump|Hex_dump]] 程序运行它，我们可以看到输出的字节：

``` {.default}
05 25 00 58 ff 0c
```

// 这些十六进制值确实与我们写出的十进制值匹配。

// 现在让我们尝试用另一个程序读取这些数据。这个程序将以二进制读取方式打开文件（`"rb"`模式），并在循环中逐个字节读取。

[i[`fread()` 函数]<]
// `fread()` 有一个很棒的功能，即在读取字节数后返回实际读取的字节数，或者在文件末尾返回 `0`。因此我们可以循环直到遇到这种情况，同时打印出数字。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    FILE *fp;
    unsigned char c;

    fp = fopen("output.bin", "rb"); // rb 代表“读取二进制”！

    while (fread(&c, sizeof(char), 1, fp) > 0)
        printf("%d\n", c);

    fclose(fp);
}
```
[i[`fread()` 函数]>]

// 运行程序后，我们看到了原始数字！

``` {.default}
5
37
0
88
255
12
```

// 太棒啦！
[i[文件 I/O-->二进制文件]>]

### `struct` 和数字注意事项
```

```c
//如我们在`struct`部分看到的那样，编译器可以随意在`struct`中添加填充物。而不同的编译器可能会以不同的方式添加填充物。同一编译器在不同架构上可能也会以不同方式添加填充物。同一编译器在相同架构上可能也会以不同方式添加填充物。

我想说的是：当你不知道填充物会出现在哪里时，仅`fwrite()`整个`struct`到文件中是不可移植的。

我们如何解决这个问题？暂缓思考---在看另一个相关问题之后，我们将探讨一些解决方法。

//数字！

原来所有架构在内存中表示数字的方式并不相同。

让我们来看一个简单的写入一个2字节数字的`fwrite()`。我们将以十六进制编写，以便清晰地看到每个字节。最高有效字节的值为`0x12`，最低有效字节的值为`0x34`。

``` {.c}
unsigned short v = 0x1234;  // 两个字节，0x12 和 0x34

fwrite(&v, sizeof v, 1, fp);
```

流中的结果将是什么？

嗯，看起来应该是`0x12`后面跟着`0x34`，对吧？

但是，如果我在我的机器上运行这个代码，将结果进行十六进制转储，我得到的是：

``` {.default}
34 12
```

它们颠倒了！怎么回事？

这与架构的[i[字节序]][flw[_endianess_|字节序]]有关。有些先写入最高有效字节，有些则先写入最低有效字节。

这意味着，如果直接从内存中写入一个多字节数字，你无法以一种可移植的方式进行^[这就是为什么我在上面的`fwrite()`和`fread()`示例中，机敏地使用了单个字节。]。
```

```c
#include <stdio.h>
#include <stdlib.h>

// Translate the text into Simplified Chinese
// 小数点也存在类似的问题。大多数系统使用相同的格式来表示浮点数，但有些却不是。没什么保证！

[i[文件I/O-->使用 `结构体`]<]
那么...我们怎样才能解决这些关于数字和 `结构体` 的问题，以便以可移植的方式写入我们的数据呢？

总结就是要进行数据序列化，这是一个通用术语，意思是将所有数据按照你控制的格式写出来，这个格式是众所周知的，并且可以在所有平台上以编程方式运行。

正如你所想象的那样，这个问题已经有解决方案了。有许多序列化库可以利用，比如谷歌的 [flw[_protocol buffers_|Protocol_buffers]]，这些库已经准备就绪可以使用。它们会为你处理所有复杂的细节，甚至能够让你的 C 程序的数据与支持相同序列化方法的其他语言进行交互操作。

对自己和他人好一点！当你将二进制数据写入流时对其进行序列化！这样即使你将数据文件从一个架构传输到另一个架构，一切仍将保持良好和可移植的状态。
[i[文件I/O-->使用 `结构体`]>]
[i[文件I/O-->使用数字值]>]
[i[文件I/O]>]
```