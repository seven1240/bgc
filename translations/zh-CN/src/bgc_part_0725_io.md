# 文件输入/输出

我们已经看过使用 `printf()` 在控制台进行 I/O 的一些例子。

但是在本章中，我们将进一步探讨这些概念。

## `FILE*` 数据类型

在 C 中进行任何类型的 I/O 时，我们都是通过一个你以 `FILE*` 类型形式
获取的数据来进行的。这个 `FILE*` 包含了与 I/O 子系统通信所需的所有
信息，比如你打开了哪个文件，文件中的位置等等。

规范将这些称为_流_，即从文件或任何来源获取的数据流。我会将 "文件" 
和 "流" 互换使用，但实际上你应该将 "文件" 视为 "流" 的一种特殊情况。
除了从文件中读取数据外，还有其他将数据流入程序的方法。

我们待会将看到如何从文件名获取到打开的 `FILE*`，但首先我要提到三个
已经为你打开并准备好供使用的流。

- `stdin`：标准输入，通常默认为键盘
- `stdout`：标准输出，通常默认为屏幕
- `stderr`：标准错误，通常默认为屏幕

实际上，我们已经在隐式地使用它们了。例如，下面这两个调用是一样的：

``` {.c}
printf("Hello, world!\n");
fprintf(stdout, "Hello, world!\n");  // printf 到文件中
```

但关于这个后面会讲更多。

同时，您会注意到`stdout`和`stderr`都输出到屏幕上。 虽然乍看起来这似乎是一个疏忽或冗余，但其实并非如此。典型的操作系统允许您将这两者的输出重定向到不同的文件中，这样能够将错误消息与常规非错误输出分开是很方便的。

例如，在类似Unix的系统上的 POSIX shell（如 sh、ksh、bash、zsh 等），我们可以运行一个程序，并将仅非错误（`stdout`）输出发送到一个文件，将所有错误（`stderr`）输出发送到另一个文件。

``` {.zsh}
./foo > output.txt 2> errors.txt   # 这个命令是特定于Unix的
```

因此，出于这个原因，您应该将严重的错误消息发送到`stderr`而不是`stdout`。
[i[`stdin` 标准输入]>]
[i[`stdout` 标准输出]>]
[i[`stderr` 标准错误]>]

稍后会介绍更多关于如何做到这一点的内容。
[i[`FILE*` 类型]<]

## 读取文本文件

[i[文件I/O-->文本文件，读取]<]
流通常分为两种类型：_文本_ 和 _二进制_。

文本流可以对数据进行重要的转换，其中最显著的是换行符的转换为不同的表示方式^[过去在广泛使用三种不同的换行符：回车（CR，用于旧的 Mac）、换行（LF，用于Unix系统）和回车/换行（CRLF，用于Windows系统）。幸运的是，随着基于Unix的 OS X 的推出，这个数字减少到了两个。]。文本文件在逻辑上是由换行符分隔的一系列 _行_。为了便于移植，您的输入数据应该总是以换行符结束。

但一般规则是，如果您能够在普通文本编辑器中编辑文件，那么它是一个文本文件。否则，它就是二进制文件。稍后会详细介绍二进制文件。

让我们开始工作吧---我们如何打开一个文件进行读取，并从中获取数据呢？

让我们创建一个名为`hello.txt`的文件，里面只有这一行内容：

``` {.default}
Hello, world!
```

然后让我们编写一个程序，打开这个文件，读取一个字符，然后在完成后关闭文件。这就是我们的计划！

看看当我们用`fopen()`打开文件时，它会把`FILE*`返回给我们，以便我们后续可以使用它。

（出于简洁起见，我将此略过，但是`fopen()`在出现问题时会返回`NULL`，比如找不到文件，所以你真的应该检查错误！）

另外请注意我们传入的`"r"`---这意味着“打开一个文本流以供读取”。（我们可以传入不同的字符串到`fopen()`，表示不同的含义，比如写入、附加等。）

之后，我们使用`fgetc()`函数从流中获取一个字符。也许你会想为什么我将`c`定义为`int`而不是`char`---先留个心眼！

最后，当我们完成后，我们关闭这个流。所有的流在程序退出时会自动关闭，但是明确关闭任何文件是良好的习惯和好的管理方式。

[i[`FILE*` 类型]]`FILE*`记录了我们在文件中的位置。所以对`fgetc()`的后续调用会得到文件中的下一个字符，然后是下一个，直到结束。

但是这听起来很麻烦。让我们看看是否可以让它更容易一些。
[i[文件I/O-->文本文件，读取]>]

## 文件结尾：`EOF`

[i[`EOF` 文件结尾]<]
有一个特殊字符被定义为一个宏：`EOF`。当到达文件结尾并且尝试读取另一个字符时，`fgetc()`会返回这个值。

我来分享一个 Fun Fact™，现在。原来`EOF`就是为什么`fgetc()`和类似的函数返回`int`而不是`char`。`EOF`并不是一个正常的字符，它的值很可能超出了`char`的范围。因为`fgetc()`需要能够返回任何字节**和**`EOF`，所以它需要是一个更宽的类型来存储更多的值。所以就选择了`int`。但是除非你将返回的值与`EOF`进行比较，你知道，其实在内心深处，它就是一个`char`。

好吧！回到现实中！我们可以使用这个来在循环中读取整个文件。

[i[`fopen()` 函数]<]
[i[`fgetc()` 函数]<]
[i[`fclose()` 函数]<]
``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    FILE *fp;
    int c;

    fp = fopen("hello.txt", "r");

    while ((c = fgetc(fp)) != EOF)
        printf("%c", c);

    fclose(fp);
}
```
[i[`fopen()` 函数]>]
[i[`fclose()` 函数]>]

（如果第10行太难理解，可以从最内层嵌套的括号开始拆解。我们首先将`fgetc()`的结果赋给`c`，然后我们将其与`EOF`进行比较。我们只是把这些都堆在了一行上。这看起来可能难以阅读，但研究一下吧---这是典型的C写法。）
[i[`fgetc()` 函数]>]

运行这段代码，我们会看到：

``` {.default}
Hello, world!
```

但是，我们仍然是一次处理一个字符，并且很多文本文件更适合在行级别上理解。让我们转而处理行级别。

文件I/O-->格式化输入

你知道如何使用`printf()`（以及，因此，我们将在下面看到的`fprintf()`）获得格式化输出吗？

`fscanf()`函数

你可以使用`fscanf()`做同样的事情。

在我们开始之前，你应该知道使用类似`scanf()`风格的函数在不受信任的输入中可能存在危险。如果你没有在`%s`中指定字段宽度，可能会溢出缓冲区。更糟糕的是，无效的数字转换会导致未定义的行为。在处理不受信任的输入时，安全的做法是使用带有字段宽度的`%s`，然后使用`strtol()`或`strtod()`等函数进行转换。

让我们有一个包含一系列数据记录的文件。在这种情况下，是关于鲸鱼的，包括名字、长度（米）和重量（吨）。`whales.txt`:

``` {.default}
blue 29.9 173
right 20.7 135
gray 14.9 41
humpback 16.0 30
```

是的，我们可以使用`fgets()`读取这些数据，然后使用`sscanf()`解析字符串（在文件损坏时更具弹性），但在这种情况下，让我们直接使用`fscanf()`获取数据。

`fscanf()`函数在读取时会跳过前导空格，并在文件结束或错误时返回`EOF`。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    FILE *fp;
    char name[1024];  // 足够大以容纳该程序遇到的任何行
    float length;
    int mass;

    fp = fopen("whales.txt", "r");

    while (fscanf(fp, "%s %f %d", name, &length, &mass) != EOF)
        printf("%s 鲸鱼，%d 吨，%.1f 米\n", name, mass, length);

    fclose(fp);
}
```

`fscanf()`函数产生的结果是：

``` {.default}
蓝鲸，173吨，29.9米
露脊鲸，135吨，20.7米
灰鲸，41吨，14.9米
座头鲸，30吨，16.0米
```
[[文件I/O-->格式化输入]>]

## 写入文本文件

[[文件I/O-->文本文件，写入]>]
[[`fputc()`函数]>]
[[`fputs()`函数]>]
[[`fprintf()`函数]>]
类似于我们使用`fgetc()`，`fgets()`和`fscanf()`来读取文本流一样，我们可以使用`fputc()`，`fputs()`和`fprintf()`来写入文本流。

为此，我们必须通过将`"w"`作为第二个参数传递来以写模式打开文件。以`"w"`模式打开现有文件将立即将该文件截断为0字节，进行完全覆写。

我们将编写一个简单的程序，使用各种输出函数输出一个名为`output.txt`的文件。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    FILE *fp;
    int x = 32;

    fp = fopen("output.txt", "w");

    fputc('B', fp);
    fputc('\n', fp);   // 换行
    fprintf(fp, "x = %d\n", x);
    fputs("Hello, world!\n", fp);

    fclose(fp);
}
```
[[`fputc()`函数]>]
[[`fputs()`函数]>]
[[`fprintf()`函数]>]

这将生成一个名为`output.txt`的文件，其内容如下：

``` {.default}
B
x = 32
Hello, world!
```

有趣的事实：由于`stdout`是一个文件，您可以将第8行替换为：

``` {.c}
fp = stdout;
```

程序将会输出到控制台而不是文件。试一试！
[[文件I/O-->文本文件，写入]>]

## 二进制文件I/O

[[文件I/O-->二进制文件]>]
到目前为止，我们只讨论了文本文件。但在前面提到过的另一个东西叫做 _二进制_ 文件，或者称为二进制流。

这些工作方式与文本文件非常相似，唯一不同的是I/O子系统不会像处理文本文件那样对数据进行任何转换。对于二进制文件，您会得到一串原始的字节流，仅此而已。

在打开文件时的最大区别是需要在模式中添加一个 `"b"`。也就是说，要读取一个二进制文件，使用 `"rb"` 模式打开它。要写入文件，使用 `"wb"` 模式打开它。

因为它是字节流，并且字节流可以包含NUL字符，而NUL字符是C中的字符串结束标记，人们很少使用`fprintf()`及其函数操作二进制文件。

而是最常用的函数是`fread()`和`fwrite()`。这些函数读取并写入指定数量的字节到流中。

为了演示，我们将编写一些程序。一个程序将一次性将一系列字节值写入磁盘。第二个程序将一次读取一个字节并将其打印出来^[通常第二个程序会一次性读取所有字节，然后在循环中将它们打印出来。那样会更有效率。但我们这里只是展示演示价值。]。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    FILE *fp;
    unsigned char bytes[6] = {5, 37, 0, 88, 255, 12};

    fp = fopen("output.bin", "wb");  // wb模式代表"写入二进制"！

    // 在调用fwrite时，参数是：
    //
    // * 要写入的数据的指针
    // * 每个数据“片段”的大小
    // * 每个数据“片段”的计数
    // * FILE*

    fwrite(bytes, sizeof(char), 6, fp);

    fclose(fp);
}
```

`fwrite()` 函数中的那两个中间参数相当奇怪。但基本上我们想告诉函数的是，"我们有固定大小的项，想要写入那么多个。" 这在你有一个固定长度的记录，并且在数组中有许多这样的记录时很方便。你只需告诉它一个记录的大小和要写入的数量。

在上面的示例中，我们告诉它每个记录的大小是一个 `char`，并且有 6 个记录。

运行程序将会生成一个名为 `output.bin` 的文件，但是在文本编辑器中打开它并不能看到友好的内容！那是二进制数据---不是文本。而且还是我随意制造的随机二进制数据！

如果我通过一个 [flw[hex dump|Hex_dump]] 程序运行它，我们可以看到输出的字节：

``` {.default}
05 25 00 58 ff 0c
```

这些十六进制值确实与我们写出的十进制值相匹配。

但现在让我们尝试用另一个程序将它们读取回来。这个程序将以二进制读取方式打开文件（`"rb"` 模式），并在循环中逐个字节地读取。

`fread()` 函数有一个很棒的功能，它返回实际读取的字节数，或者在文件结尾返回 `0`。因此我们可以循环直到看到这个值，同时打印出读取的数字。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    FILE *fp;
    unsigned char c;

    fp = fopen("output.bin", "rb"); // rb 意为 "read binary"！

    while (fread(&c, sizeof(char), 1, fp) > 0)
        printf("%d\n", c);

    fclose(fp);
}
```

运行后，我们看到我们最初的数字！

``` {.default}
5
37
0
88
255
12
```

哇耶！

在`结构体`部分中，我们看到编译器可以自由地根据需要向`结构体`添加填充。不同的编译器可能以不同的方式执行此操作。而在不同体系结构上相同的编译器可能会以不同的方式执行此操作。同一体系结构上同一编译器也可能以不同的方式执行此操作。

我的意思是：当你不知道填充将会被放置在哪里时，仅仅使用`fwrite()`将整个`结构体`写入文件是不可移植的。

我们如何解决这个问题？先把这个问题放一边，我们先来看看另一个相关的问题。

数字！

结果显示并非所有体系结构在内存中以相同的方式表示数字。

让我们来看一个简单的写入2字节数字的`fwrite()`操作。我们用十六进制表示以便清晰地看到每个字节。最高有效字节的值为`0x12`，最低有效字节的值为`0x34`。

在流中会包含什么呢？

看起来应该是`0x12`后跟着`0x34`，对吧？

但是如果我在我的机器上运行这个代码并查看十六进制转储的结果，我会得到：

34 12

它们被颠倒了！怎么回事？

这与体系结构的端序有关。一些体系结构会先写入最高有效字节，而另一些则会先写入最低有效字节。

这意味着，如果你直接从内存中写出一个多字节数字，你无法以可移植的方式完成这个操作。

浮点数也存在类似的问题。大多数系统使用相同的浮点数格式，但有些不一样。不能保证通用！

因此...我们如何解决所有这些有关数字和`struct`s的问题，以便以可移植的方式编写数据？

总结就是进行数据序列化_serialize_，这是一个通用术语，意味着将所有数据以你可以控制、熟知、可编程的格式写出，并且在所有平台上都能以相同方式工作。

你可能会想到，这是一个已经解决的问题。有许多序列化库可供利用，比如谷歌的[flw[_protobuf协议_|Protocol_buffers]]，都已准备就绪。它们将为你处理所有棘手的细节，甚至能够让你的C程序的数据与支持相同序列化方法的其他语言互操作。

为自己和他人着想！在将二进制数据写入流时进行序列化！这将保持数据的可移植性，即使你将数据文件从一个架构转移到另一个架构。
[使用`struct`进行文件I/O]
[使用数值进行文件I/O]
[文件I/O]