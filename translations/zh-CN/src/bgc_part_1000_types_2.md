<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 类型 II：更多的类型！

我们已经习惯了`char`、`int`和`float`类型，但现在是时候把这些东西提升到下一个级别，看看在类型部门还有什么！

## 有符号和无符号整数

[i[Types-->signed and unsigned]<]
到目前为止，我们使用`int`作为一个_有符号_类型，也就是一个可以是负数或正数的值。但是C语言还有特定的_无符号_整数类型，只能保存正数。

这些类型以关键字[i[`unsigned` type]<]`unsigned`为前缀。

``` {.c}
int a;           // 有符号
signed int a;    // 有符号
signed a;        // 有符号，"shorthand" 表示 "int" 或 "signed int"，较少使用
unsigned int b;  // 无符号
unsigned c;      // 无符号，表示 "unsigned int" 的简写
```

为什么？为什么决定只保存正数？

答案：使用无符号变量可以表示比有符号变量更大的数。

但为什么会这样呢？

您可以将整数表示为一定数量的_位_^["Bit" 是 _binary digit_ 的缩写。二进制是表示数字的另一种方式。与我们习惯的 0-9 不同，它的数字只有 0-1。]. 在我的计算机上，一个 `int` 由64位表示。

每一个由 `1` 或 `0` 构成的比特排列都代表一个数字。我们可以决定如何分配这些数字。

对于有符号数，我们使用（大致）一半的排列来表示负数，另一半来表示正数。

对于无符号数，我们使用_所有_排列来表示正数。

在我的计算机上，使用64位`int`以[flw[补码（two's complement）|Two%27s_complement]]表示无符号数，整数范围的限制如下：

|Type|最小值|最大值|
|:-|-:|-:|
|`int`|`-9,223,372,036,854,775,808`|`9,223,372,036,854,775,807`|
|`unsigned int`|`0`|`18,446,744,073,709,551,615`|

请注意，最大的正数`unsigned int`大约是最大的正数`int`的两倍。因此在这方面你可以获得一些灵活性。

## 字符类型

记得`char`吗？我们可以用它来保存单个字符的类型吗？

``` {.c}
char c = 'B';

printf("%c\n", c);  // "B"
```

我有一个震惊的消息告诉你：它实际上是一个整数。

``` {.c}
char c = 'B';

// 将这里的 %c 改为 %d：
printf("%d\n", c);  // 66 (!!)
```

其实，`char`就是一个小的`int`，也就是一个只使用一个字节空间的整数，限制了它的范围为......

在这里C规范有点古怪。它告诉我们`char`是一个字节，即`sizeof(char) == 1`。但在C11 §3.6¶3中，它特意指出：

> 一个字节由一系列连续的位组成，_位数是由实现定义的_。

等等---什么？有些人可能习惯于认为一个字节是8位，对吧？我的意思是，它就是这样，对吧？答案是，“几乎可以肯定地是这样的。”^[一个确切、无可争议为8位的序列的行业术语是_八位字节（octet）_] 但C是一门古老的语言，早年的机器有着更“宽容”的看法，可以说这些机器对一个字节有多少位有着更“宽松”的看法。而多年来，C一直保留着这种灵活性。

但假设在C中，像你将几乎在世界上所有你见过的机器上一样，每个字节都是8位，那么`char`的范围是...

unsigned char 类型
signed char 类型
---所以在我告诉你之前，char 可能是有符号的也可能是无符号的，这取决于你的编译器。除非你明确指定。

在许多情况下，只使用 char 就可以，因为你不在乎数据的符号。但是，如果你需要有符号或无符号的 char，你必须明确地指定：

``` {.c}
char a;           // 可能是有符号的或无符号的
signed char b;    // 明确是有符号的
unsigned char c;  // 明确是无符号的
```

好了，现在，假设 char 是 8 位并且你的系统对于有符号和无符号是使用几乎普遍的二进制补码表示法的话，我们就可以确定数字范围了 [^1]。

因此，假设这些约束条件，我们最终可以确定我们的范围：

|`char` 类型|最小值|最大值|
|:-|-:|-:|
|`signed char`|`-128`|`127`|
|`unsigned char`|`0`|`255`|

而 `char` 类型的范围是实现定义的。

unsigned char 类型
signed char 类型

让我澄清一下。char 其实是一个数，所以我们可以对它进行数学运算吗？

可以！只需记得将事物保持在 char 的范围内！

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    char a = 10, b = 20;

    printf("%d\n", a + b);  // 30!
}
```

单引号
那么单引号中的常量字符呢，例如 'B'？它是如何有数值的呢？

规范在这里也有些模糊，因为 C 并不是设计运行在一种单一类型的基础系统上。

但是，暂时假设你的字符集至少是基于ASCII的前128个字符。在这种情况下，字符常量将被转换为一个`char`，其值与字符的ASCII值相同。

说了一大堆话。让我们举个例子：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    char a = 10;
    char b = 'B';  // ASCII 值为 66

    printf("%d\n", a + b);  // 76!
}
```

这取决于你的执行环境和所使用的字符集。今天最流行的字符集之一是Unicode（它是ASCII的超集），所以对于基本的0-9、A-Z、a-z和标点符号，你几乎肯定会得到它们的ASCII值。
[i[`'` 单引号]>]
[i[`char` 类型]>]
[i[类型-->字符]>]

## 更多整数类型：`short`、`long`、`long long`

到目前为止，我们通常只使用了两种整数类型：

* `char`
* `int`

而且我们最近了解了整数类型的无符号变体。我们也知道`char`实际上是一个伪装的小`int`。所以我们知道`int`可以有多种位大小。

但是还有几种整数类型我们应该了解一下，以及它们能够容纳的_最小_最大值。

是的，我说了两次"最小"。规范规定这些类型将容纳_至少_这些大小的数字，所以你的实现可能会有所不同。头文件`<limits.h>`定义了包含最小和最大整数值的宏；依赖于它以确保，并_永远不要硬编码或假设这些值_。

`short`类型、`long`类型和`long long`类型被称为额外的类型，它们分别是`short int`、`long int`和`long long int`。一般来说，在使用这些类型时，C开发者会省略其中的`int`部分（比如`long long`），编译器也不会报错。

``` {.c}
// 下面两行是等价的：
long long int x;
long long x;

// 同理，这两行也是等价的：
short int x;
short x;
```

我们来看一下按照有符号性分组，以升序排列的整数数据类型和大小。

|类型|最小字节数|最小值|最大值|
|:-|-:|-:|-:|
|`char`|1|-127或0|127或255^[取决于`char`是默认为`signed char`还是`unsigned char`]|
|`signed char`|1|-127|127|
|`short`|2|-32767|32767|
|`int`|2|-32767|32767|
|`long`|4|-2147483647|2147483647|
|`long long`|8|-9223372036854775807|9223372036854775807|
|`unsigned char`|1|0|255|
|`unsigned short`|2|0|65535|
|`unsigned int`|2|0|65535|
|`unsigned long`|4|0|4294967295|
|`unsigned long long`|8|0|18446744073709551615|

没有`long long long` 这种类型。不能简单地一直添加`long`来定义类型。不要太荒谬。

> 二进制补码的爱好者可能会注意到这些数字有点奇怪。为什么，比如说，`signed char`的范围在-127而不是-128呢？记住：这些只是规范要求的最小值。有些数字表示（例如[flw[sign and magnitude|Signed_number_representations#Signed_magnitude_representation]]）在±127处截断。

让我们在我的64位、二进制补码系统上运行相同的表格，看看结果如何：

|类型|我的字节|最小值|最大值|
|:-|-:|-:|-:|
|`char`|1|-128|127^[我的`char`是有符号的。]|
|`signed char`|1|-128|127|
|`short`|2|-32768|32767|
|`int`|4|-2147483648|2147483647|
|`long`|8|-9223372036854775808|9223372036854775807|
|`long long`|8|-9223372036854775808|9223372036854775807|
|`unsigned char`|1|0|255|
|`unsigned short`|2|0|65535|
|`unsigned int`|4|0|4294967295|
|`unsigned long`|8|0|18446744073709551615|
|`unsigned long long`|8|0|18446744073709551615|

这个更合理一些，但我们可以看到我的系统的限制比规范中的最小值要大。

[那么`<limits.h>`中的宏是什么？]{#limits-macros}

|类型|最小值宏|最大值宏|
|:-|:-|:-|
|`char`|`CHAR_MIN`|`CHAR_MAX`|
|`signed char`|`SCHAR_MIN`|`SCHAR_MAX`|
|`short`|`SHRT_MIN`|`SHRT_MAX`|
|`int`|`INT_MIN`|`INT_MAX`|
|`long`|`LONG_MIN`|`LONG_MAX`|
|`long long`|`LLONG_MIN`|`LLONG_MAX`|
|`unsigned char`|`0`|`UCHAR_MAX`|
|`unsigned short`|`0`|`USHRT_MAX`|
|`unsigned int`|`0`|`UINT_MAX`|
|`unsigned long`|`0`|`ULONG_MAX`|
|`unsigned long long`|`0`|`ULLONG_MAX`|

请注意，这里有一个隐藏的方法可以确定系统是使用有符号还是无符号的`char`。如果`CHAR_MAX == UCHAR_MAX`，那么`char`必须是无符号的。

另请注意，`unsigned` 变体没有最小宏，它们就是`0`。
[i[`short`类型]>]
[i[`long`类型]>]
[i[`long long`类型]>]

## 更多关于浮点型：`double` 和 `long double`

让我们看看规范中对浮点数的定义在 §5.2.4.2.2¶1-2：

下面的参数用于为每种浮点类型定义模型：

|参数|定义|
|:-|:-|
|$s$|符号（$\pm1$）|
|$b$|指数表示的基数或基数（大于1的整数）|
|$e$|指数（介于最小值$e_{min}$和最大值$e_{max}$之间的整数）|
|$p$|精度（尾数中基数-$b$的数字数）|
|$f_k$|小于 $b$ 的非负整数（尾数数字）|

浮点数（$x$）由以下模型定义：

$x=sb^e\sum\limits_{k=1}^p f_kb^{-k},$\ \ \ \ $e_{min}\le e\le e_{max}$

希望这为您澄清了一切。

好的，好吧。让我们退后一步，看看实际情况。

注意：在本节中我们引用了一堆宏。这些宏可以在头文件 `<float.h>` 中找到。

浮点数用特定位序列编码（[flw[IEEE-754格式|IEEE_754]] 非常流行）。

再深入一点，这个数字基本上表示为 _尾数_（即数字部分---数字本身，有时也称为 _尾数_）和 _指数_，即将数字提升到的幂。请记住，负指数会使数字变小。

想象一下，我们使用 $10$ 作为指数。我们可以通过用尾数 $12345$ 和指数 $-3$、$4$ 和 $0$ 来表示以下数字来编码以下浮点值：

$12345\times10^{-3}=12.345$

$12345\times10^4=123450000$

$12345\times10^0=12345$

对所有这些数字来说，尾数保持不变。唯一的区别是指数。

在您的计算机上，指数的基数很可能是 $2$，而不是 $10$，因为计算机喜欢二进制。您可以通过打印 `FLT_RADIX` 宏来检查它。

所以我们有一个由一定数量字节表示的数字，以某种方式编码。由于位模式的数量有限，因此只能表示有限数量的浮点数。

但更具体地说，只有一定数量的有效十进制数字可以准确表示。

如何获取更多的数字精度呢？你可以使用更大的数据类型！

我们有一些数据类型。我们已经了解了 `float`，但为了获得更高的精度，我们有 `double`。而为了获得更高的精度，我们有 `long double`（与 `long int` 除了名称外无关）。

规范没有说明每种类型应该占用多少字节的存储空间，但在我的系统上，我们可以看到相对大小的增加：

|类型|`sizeof`|
|:-|-:|
|`float`|4|
|`double`|8|
|`long double`|16|

因此，每种类型（在我的系统上）都使用那些额外的位数来提高精度。

但这里我们谈论的是多少精度？这些值可以表示多少十进制数？

嗯，C 为我们提供了一堆宏在 `<float.h>` 中以帮助我们弄清楚这一点。

如果你使用基于二进制的系统来存储数字的话（几乎地球上的所有人，可能包括你），那么它会变得有些复杂，但请跟着我一起弄清楚。

### 多少十进制数字？

百万美元问题是：“我可以在给定的浮点类型中存储多少有效十进制数字，以便在打印时获得相同的十进制数字？”

在这些宏中，你可以存储在浮点类型中的十进制数字的数量，当你打印它时可以确保得到相同的数字：

[`FLT_DIG` 宏]<]

[`DBL_DIG` 宏]<]

[`LDBL_DIG` 宏]<]

|类型|可存储的十进制数字|最小值|我的系统|
|:-|-:|-:|
|`float`|`FLT_DIG`|6|6|
|`double`|`DBL_DIG`|10|15|
|`long double`|`LDBL_DIG`|10|18|

在我的系统上，`FLT_DIG` 为6，因此我可以确保如果我打印一个6位数的`float`，我会得到相同的结果。 （可能会有更多位数---一些数字会以更多位数正确返回。 但是6位数肯定会返回。）

例如，按照递增位数打印`float`，我们显然可以一直打印到8位数字，然后在那之后我们又回到了7位正确的数字。

``` {.default}
0.12345
0.123456
0.1234567
0.12345678
0.123456791  <-- 开始出错
0.1234567910
```

让我们再做一个演示。 在这个代码中，我们有两个`float`，它们都包含有`FLT_DIG` 个有效的十进制数字^[这个程序在一个使用IEEE-754基于二进制浮点数的系统上，其`FLT_DIG`为 `6`。否则，你可能会得到不同的输出。]。 然后我们将它们相加，所得结果应该有 12 个有效的十进制数字。 但这超过了我们可以在`float`中存储和正确恢复为字符串的数量---因此当我们打印它时，事情在第 7 个有效数字之后开始出错。

``` {.c .numberLines}
#include <stdio.h>
#include <float.h>

int main(void)
{
    // 这两个数字都有 6 个有效数字，所以它们可以精确地存储在一个 float 中：

    float f = 3.14159f;
    float g = 0.00000265358f;

    printf("%.5f\n", f);   // 3.14159       -- 正确!
    printf("%.11f\n", g);  // 0.00000265358 -- 正确!

    // 现在将它们相加
    f += g;                // 3.14159265358 是 f 应该是的结果

    printf("%.11f\n", f);  // 3.14159274101 -- 错误!
}
```

(上面的代码在数字常量后面带有一个 `f`---这表示该常量的类型是 `float`，而不是默认的 `double` 类型。稍后我们会详细讨论这个问题。)

记住 `FLT_DIG` 是你可以在 `float` 中存储并正确检索的安全数字位数。

有时你可能会获得多一两位数字。但有时你只能获得 `FLT_DIG` 位数字。可以确定的是：如果你在 `float` 中存储任意位数，包括 `FLT_DIG` 位数字，你一定可以正确读取它们。

这就是故事的全部。`FLT_DIG`。完结。

...或者说呢？

### 转换为十进制再返回

但在浮点数中存储一个十进制数并将其取回只是一部分故事。

事实证明，浮点数可以编码需要更多小数位才能完全输出的数字。只是你的大十进制数字可能无法映射到这些数字之一。

也就是说，当你从一个浮点数到另一个浮点数时，它们之间存在一个间隔。如果你尝试在那个间隔中编码一个十进制数，它会使用最接近的浮点数。这就是为什么你只能在 `float` 中编码 `FLT_DIG`。

但是那些**不在**间隔中的浮点数呢？要准确地输出这些数字，你需要多少位小数？

另一种表达这个问题的方式是对于任何给定的浮点数，如果我想将其十进制数转换回完全相同的浮点数，我需要保留多少十进制数字？也就是说，如果我想在十进制中打印出原始数字中**所有**二进制位中的数字，我需要打印多少位十进制数字？

有时可能只需要一些。但要确保，你应该转换为带有一定安全十进制位数的十进制。这个数字被编码在以下宏中：

``` {.default}
// 定义FLT_DECIMAL_DIG宏，代表float类型中编码的十进制数字个数。
// 定义DBL_DECIMAL_DIG宏，代表double类型中编码的十进制数字个数。
// 定义LDBL_DECIMAL_DIG宏，代表long double类型中编码的十进制数字个数。
// 定义DECIMAL_DIG宏，与最宽类型的编码相同，即LDBL_DECIMAL_DIG。
```

在一个例子中我们看到 `DBL_DIG` 是15（这是我们可以在一个常数中拥有的），但 `DBL_DECIMAL_DIG` 是17（因此我们需要转换成17位小数才能保留所有原始 `double` 的位）。

让我们把15个有效数字 `0.123456789012345` 赋给 `x`，并将1个有效数字 `0.0000000000000006` 赋给 `y`。

``` {.default}
x 是精确的: 0.12345678901234500    打印为 17 位小数
y 是精确的: 0.00000000000000060
```

但让我们把它们相加。预期会得到 `0.1234567890123456`，但这超过了 `DBL_DIG`，所以可能会发生一些奇怪的事情... 让我们看看：

``` {.default}
x + y 结果不太对: 0.12345678901234559    预期末尾是 4560！
```

这就是因为超过了 `DBL_DIG` 而发生的事情，对吧？但看看这个... 上面的数字，正好可以被精确表示！

如果我们将 `0.12345678901234559`（17 位数）赋给 `z` 并打印出来，我们会得到：

``` {.default}
z 是精确的: 0.12345678901234559   17 位正确！超过 DBL_DIG！
```

如果将 `z` 截断为 15 位数，它将不再是相同的数字。这就是为什么为了保存所有 `double` 的位，我们需要 `DBL_DECIMAL_DIG` 而不只是较小的 `DBL_DIG`。
```

话虽如此，明显的是，当我们处理一般的十进制数字时，打印超过 [i[`FLT_DIG`宏]]`FLT_DIG`、[i[`DBL_DIG`宏]]`DBL_DIG` 或 [i[`LDBL_DIG`宏]]`LDBL_DIG` 位数字是不安全的，要考虑与原始的十进制数和任何后续数学运算相关联。

但是，当从 `float` 转换为十进制表示形式，然后再转换回 `float` 时，一定要使用 `FLT_DECIMAL_DIG`，这样所有的位将被精确保留。[i[`FLT_DECMIAL_DIG`宏]>]

[i[有效位数]>]

## 常数类型

当你写下一个常数，比如 `1234`，它有一个类型。但是它是什么类型呢？让我们看看 C 是如何决定常数的类型，并且如何强制它选择一个特定的类型。

### 十六进制和八进制

除了传统的十进制，C 也支持不同进制的常数。

[i[`0x` 十六进制]<]

如果你用 `0x` 来开头一个数字，它会被解析为十六进制数字：

``` {.c}
int a = 0x1A2B;   // 十六进制
int b = 0x1a2b;   // 对十六进制数大小写不敏感

printf("%x", a);  // 打印一个十六进制数字，"1a2b"
```

[i[`0x` 十六进制]>]

[i[`0` 八进制]<]
如果你用一个 `0` 来开头一个数字，它会被解析为八进制数字：

``` {.c}
int a = 012;

printf("%o\n", a);  // 打印一个八进制数字，"12"
```

这对初学者程序员来说尤其棘手，他们试图在十进制数字左边用 `0` 来补位，使得排列整齐，却无意中改变了数字的进制：

``` {.c}
int x = 11111;  // 十进制 11111
int y = 00111;  // 十进制 73（八进制 111）
int z = 01111;  // 十进制 585（八进制 1111）
```

[i[`0` 八进制]>]

#### 二进制注意事项

[i[`0b` 二进制]<]

许多C编译器中的非官方扩展允许您用 `0b` 前缀表示二进制数：

``` {.c}
int x = 0b101010;    // 二进制 101010

printf("%d\n", x);   // 打印十进制的 42
```

没有用于打印二进制数的 `printf()` 格式说明符。您必须使用位运算符逐个字符地打印。

整数常量

可以通过在整数常量后附加指示类型的后缀来强制将常量整数作为特定类型。

我们将进行一些赋值以演示，但大多数开发人员通常会省略后缀，除非需要精确。编译器非常擅长确保类型是兼容的。

`U` 无符号常量
`L` 长常量
`LL` 长长整型常量
`UL` 无符号长整型常量
`ULL` 无符号长长整型常量

后缀可以是大写或小写。`U` 和 `L` 或 `LL` 可以任何一个先出现。

我在表中提到“无后缀”表示 `int` … 但实际上要比那更复杂。

当你有一个没有后缀的数字时会发生什么呢，比如：

``` {.c}
int x = 1234;
```

它是什么类型的呢？

一般情况下，C 会选择从 `int` 开始的能够容纳该值的最小类型。

但具体来说，这取决于数字的进制（十进制、十六进制或八进制）。

规范中有一个很棒的表格，指示了用于未带后缀值的类型。事实上，我打算直接把它完整复制过来。

C11 §6.4.4.1¶5 写道，“整数常量的类型是对应列表中第一个能够表示其值的类型。”

接着展示这个表格：

+----------------+------------------------+-------------------------+
|后缀             |十进制常量              |八进制或十六进制常量       |
|                |                        |                          |
+----------------+------------------------+-------------------------+
|无              |`int`                   |`int`                    |
|                |`long int`              |`unsigned int`            |
|                |                        |`long int`                |
|                |                        |`unsigned long int`       |
|                |                        |`long long int`           |
|                |                        |`unsigned long long int`  |
|                |                        |                          |
+----------------+------------------------+-------------------------+
|`u` 或 `U`      |`unsigned int`          |`unsigned int`            |
|                |`unsigned long int`     |`unsigned long int`       |
|                |`unsigned long long int`|`unsigned long long int`  |
|                |                        |                          |
+----------------+------------------------+-------------------------+
|`l` 或 `L`      |`long int`              |`long int`                |
|                |`long long int`         |`unsigned long int`       |
|                |                        |`long long int`           |
|                |                        |`unsigned long long int`  |
|                |                        |                          |
+----------------+------------------------+-------------------------+
|`u` 或 `U`以及  |`unsigned long int`     |`unsigned long int`       |
|`l` 或 `L`     |`unsigned long long int`|`unsigned long long int`  |
|                |                        |                          |
+----------------+------------------------+-------------------------+
|`ll` 或 `LL`   |`long long int`         |`long long int`           |
|                |                        |`unsigned long long int`  |
|                |                        |                          |
+----------------+------------------------+-------------------------+
|`u` 或 `U`以及  |`unsigned long long int`|`unsigned long long int`  |
|`ll` 或 `LL`   |                        |                          |
+----------------+------------------------+-------------------------+

[ `L` 长整型常数 ]
[ `LL` 长长整型常数 ]
[ `UL` 无符号长整型常数 ]
[ `ULL` 无符号长长整型常数 ]

这意味着，比如说，如果你指定一个像 `123456789U` 这样的数字，首先C语言会尝试将其解释为 `unsigned int`。如果不符合，它会尝试解释为 `unsigned long int`。然后是 `unsigned long long int`。它会使用可以容纳该数字的最小的类型。

[ `U` 无符号常数 ]

[整数常数]

### 浮点常数

你可能认为浮点常数像 `1.23` 应该默认是 `float` 类型，对吧？

惊喜！事实证明，没有后缀的浮点数是 `double` 类型！迟来的生日快乐！

[ `F` 浮点常数 ]
[ `L` 长双精度浮点常数 ]

你可以通过添加 `f`（大小写不敏感）来强制其为 `float` 类型。你可以通过添加 `l`（大小写不敏感）来强制其为 `long double` 类型。

|类型|后缀|
|:-|:-|
|`float`|`F`|
|`double`|无|
|`long double`|`L`|

例如：

``` {.c}
float x       = 3.14f;
double x      = 3.14;
long double x = 3.14L;
```

[ `F` 浮点常数 ]
[ `L` 长双精度浮点常数 ]

不过，我们一直在做这样的操作，对吧？

``` {.c}
float x = 3.14;
```

左边是 `float`，右边是 `double`，是吧？是的！但是C语言在自动数值转换方面做得相当好，所以使用没有后缀的浮点常数比有后缀的更常见。稍后会详细介绍。

[浮点常数]

#### 科学计数法

我们稍早谈到浮点数可以用一位数、基数和指数来表示时，还记得吗？

好吧，有一种常见的写法来表示这样一个数字，如下所示，紧接着是更容易识别的等价形式，当你实际运算时得到的结果：

$1.2345\times10^3 = 1234.5$

以 $s\times b^e$ 的形式写数字被称为[flw[_科学计数法_|Scientific_notation]]。在C语言中，使用“E记法”来表示这些，因此这些是等价的：

|科学计数法|E记法|
|:-|:-|
|$1.2345\times10^{-3}=0.0012345$|`1.2345e-3`|
|$1.2345\times10^8=123450000$|`1.2345e+8`|

你可以使用 `%e` 来以这种记法打印一个数字：

``` {.c}
printf("%e\n", 123456.0);  // 输出 1.234560e+05
```

关于科学记数法的一些有趣事实：

* 小数点前不一定要写一个数字作为主导。前面可以有任意数量的数字。

  ``` {.c}
  double x = 123.456e+3;  // 123456
  ```

  但是，当你打印它时，指数会改变，所以小数点前只会有一个数字。
  
* 指数前的加号可以省略，因为这是默认的，但据我所见，在实践中很少见。

  ``` {.c}
  1.2345e10 == 1.2345e+10
  ```
* 你可以在E记法常数上应用`F`或`L`后缀：

  ``` {.c}
  1.2345e10F
  1.2345e10L
  ```

[i[科学计数法]>]

#### 十六进制浮点常数

[i[十六进制浮点常数]<]

但是等等，还有更多浮点数的用法！

原来还有十六进制浮点常数！

它们类似于十进制的浮点数，但是它们以一个 `0x` 开头，就像整数一样。

唯一的问题是你 _必须_ 指定一个指数，并且这个指数产生一个2的幂。也就是说：$2^x$。

然后在写数字时，使用 `p` 而不是 `e`：

因此 `0xa.1p3`表示 $10.0625\times2^3 == 80.5$。

当使用浮点十六进制常量时，
我们可以使用 `%a` 打印十六进制科学计数法：

``` {.c}
double x = 0xa.1p3;

printf("%a\n", x);  // 0x1.42p+6
printf("%f\n", x);  // 80.500000
```