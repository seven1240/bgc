<!--Beej's指南C

# vim: ts=4:sw=4:nosi:et:tw=72-->

# 类型II：更多类型！

我们熟悉`char`、`int`和`float`类型，但现在是时候把这些内容提升到下一个层次，看看类型部门里还有什么其他内容！

## 有符号和无符号整数

到目前为止，我们使用`int`作为_有符号_类型，即可以是负数或正数的值。但C语言还有特定的_无符号_整数类型，只能容纳正数。

这些类型以关键字[i[`unsigned` type]<]`unsigned`为前缀。

``` {.c}
int a;           // 有符号
signed int a;    // 有符号
signed a;        // 有符号，"int"或"signed int"的“简写”，不常见
unsigned int b;  // 无符号
unsigned c;      // 无符号，简写为"unsigned int"
```

为什么？为什么会决定只想要容纳正数？

答案：你可以在无符号变量中得到比有符号变量更大的数值。

但是为什么呢？

可以将整数理解为由一定数量的_比特_组成[^["Bit"是 _二进制数字_ 的简称。二进制只是表示数字的另一种方式。与我们习惯的数字0-9不同，它的数字是0-1。]]. 在我的计算机上，一个`int`由64位表示。

每一组由`1`或`0`组成的比特排列表示一个数字。我们可以决定如何分配这些数字。

对于有符号数，我们使用（粗略地）一半的排列来表示负数，另一半用来表示正数。

对于无符号数，我们使用_全部_排列来表示正数。

在我的计算机上，使用64位`int`，采用[flw[二进制补码|二进制补码]]表示无符号数，整数范围的限制如下：

|类型|最小值|最大值|
|:-|-:|-:|
|`int`|`-9,223,372,036,854,775,808`|`9,223,372,036,854,775,807`|
|`unsigned int`|`0`|`18,446,744,073,709,551,615`|

请注意，最大的正整数 `unsigned int` 大约是最大的正整数的两倍。这样你就可以获得一些灵活性。

## 字符类型

还记得 `char` 吗？那个我们用来保存单个字符的类型？

``` {.c}
char c = 'B';

printf("%c\n", c);  // "B"
```

让我告诉你一个惊人的事实：实际上它是一个整数。

``` {.c}
char c = 'B';

// 将这里的 %c 改成 %d：
printf("%d\n", c);  // 66 (!!)
```

从根本上讲，`char` 只是一个小的 `int`，也就是只使用一个字节空间的整数，限制了它的范围为...

在这里，C 规范有点特别。它向我们保证一个 `char` 是一个字节，即 `sizeof(char) == 1`。但是在 C11 §3.6¶3 中，它特意指出：

> 字节由一系列连续的位组成，位数由实现定义。

等等---什么？你们中的一些人可能习惯于字节是8位的概念，对吧？我的意思是，字节就是8位，对吧？答案是，“几乎可以肯定是”。 [拥有确切、不容置疑的8位序列的行业术语是“字节”。] 但是 C 是一种古老的语言，当时的计算机对一个字节中有多少位持有更宽松的看法。多年来，C 保留了这种灵活性。

但是假设在 C 中，字节是8位，就像你将在世界上几乎所有的计算机上看到的那样，`char` 的范围是...

```c
unsigned char类型
```

```c
signed char类型
```

--- 所以在我告诉你之前,原来`char`类型可能是有符号或无符号的，这取决于您的编译器。除非您明确指定。

在许多情况下，只使用`char`是可以的，因为您不关心数据的符号。但是如果您需要有符号或无符号的`char`，您**必须**明确指定：

```c
char a;           // 可能有符号或无符号
signed char b;    // 明确有符号
unsigned char c;  // 明确无符号
```

好了，现在，最终，我们可以推测数字的范围，假设一个`char`是8位，并且您的系统使用了普遍采用的二进制补码表示法来表示有符号和无符号数^[一般来说，如果您有$n$位的二进制补码数，有符号数的范围是$-2^{n-1}$到$2^{n-1}-1$。无符号范围是$0$到$2^n-1$。].

所以，假设这些约束，我们最终可以确定我们的范围：

|`char`类型|最小值|最大值|
|:-|-:|-:|
|`signed char`|`-128`|`127`|
|`unsigned char`|`0`|`255`|

`char`类型范围是实现定义的。

```c
unsigned char类型
```

```c
signed char类型
```

让我搞清楚。`char`实际上是一个数字，所以我们可以对其进行数学运算吗？

是的！只是记得保持在`char`的范围内！

```c
#include <stdio.h>

int main(void)
{
    char a = 10, b = 20;

    printf("%d\n", a + b);  // 30!
}
```

```c
'` 单引号
```

那么单引号中的常量字符，如 `'B'`，具有什么数值？

这里规范也有模糊之处，因为C并非设计在单一类型的底层系统上运行。

但是暂时假设您的字符集至少在前128个字符上是基于ASCII的。在这种情况下，字符常量将被转换为一个`char`，其值与字符的ASCII值相同。

说了这么多。 让我们举个例子：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    char a = 10;
    char b = 'B';  // ASCII值为66

    printf("%d\n", a + b);  // 76!
}
```

这取决于您的执行环境和所使用的字符集。今天最流行的字符集之一是Unicode（它是ASCII的超集），因此对于基本的0-9，A-Z，a-z和标点符号，您几乎肯定会得到它们的ASCII值。

## 更多整数类型：`short`、`long`、`long long`

到目前为止，我们一直在使用两种整数类型：

- `char`
- `int`

我们最近学到了整数类型的无符号变体。我们也知道`char`实际上是伪装成小整数。所以我们知道`int`可以有多个位大小。

但是还有一些整数类型是我们应该看看的，并且它们能够保存的最小和最大值。

是的，我说了“最小”两次。规范规定这些类型将至少保存这些大小的数字，因此您的实现可能会有所不同。头文件`<limits.h>`定义了宏，用于保存整数的最小和最大值；依赖于这一点以确保，_永远不要硬编码或假设这些值_。

```c
[i[`short`类型]<]
[i[`long`类型]<]
[i[`long long`类型]<]
这些额外的类型是`short int`、`long int`和`long long int`。
通常情况下，C开发者在使用这些类型时会省略`int`部分
（例如`long long`），而编译器会完全理解。

``` {.c}
// 这两行是等价的：
long long int x;
long long x;

// 这两行也是等价的：
short int x;
short x;
```

让我们来看一下按升序排列分组的有符号整数数据类型和大小。

|类型|最小字节数|最小值|最大值|
|:-|-:|-:|-:|
|`char`|1|-127 或 0|127 或 255^[取决于`char`是默认为`signed char`还是`unsigned char`]|
|`signed char`|1|-127|127|
|`short`|2|-32767|32767|
|`int`|2|-32767|32767|
|`long`|4|-2147483647|2147483647|
|`long long`|8|-9223372036854775807|9223372036854775807|
|`unsigned char`|1|0|255|
|`unsigned short`|2|0|65535|
|`unsigned int`|2|0|65535|
|`unsigned long`|4|0|4294967295|
|`unsigned long long`|8|0|18446744073709551615|

没有`long long long`类型。你不能无休止地添加`long`。别搞笑。

> 二进制补码粉丝可能已经注意到这些数字有些奇怪。为什么，比如`signed char`的最小值是-127而不是-128呢？记住：这些只是规范要求的最小值。一些数字表示（例如[flw[sign and
> magnitude|Signed_number_representations#Signed_magnitude_representation]]）在±127处达到上限。

让我们在我的64位二进制补码系统上运行同样的表格，看看会得到什么结果：
```

|类型|字节数|最小值|最大值|
|:-|-:|-:|-:|
|`char`|1|-128|127^[我的`char`类型是有符号的。]|
|`signed char`|1|-128|127|
|`short`|2|-32768|32767|
|`int`|4|-2147483648|2147483647|
|`long`|8|-9223372036854775808|9223372036854775807|
|`long long`|8|-9223372036854775808|9223372036854775807|
|`unsigned char`|1|0|255|
|`unsigned short`|2|0|65535|
|`unsigned int`|4|0|4294967295|
|`unsigned long`|8|0|18446744073709551615|
|`unsigned long long`|8|0|18446744073709551615|

这看起来更合理了，但可以看出我的系统的限制比规范中的最小值要大。

[那么`<limits.h>`头文件中有哪些宏？]{#limits-macros}

|类型|最小宏|最大宏|
|:-|:-|:-|
|`char`|`CHAR_MIN`|`CHAR_MAX`|
|`signed char`|`SCHAR_MIN`|`SCHAR_MAX`|
|`short`|`SHRT_MIN`|`SHRT_MAX`|
|`int`|`INT_MIN`|`INT_MAX`|
|`long`|`LONG_MIN`|`LONG_MAX`|
|`long long`|`LLONG_MIN`|`LLONG_MAX`|
|`unsigned char`|`0`|`UCHAR_MAX`|
|`unsigned short`|`0`|`USHRT_MAX`|
|`unsigned int`|`0`|`UINT_MAX`|
|`unsigned long`|`0`|`ULONG_MAX`|
|`unsigned long long`|`0`|`ULLONG_MAX`|

请注意，在这里有一种隐含的方法可以确定系统是使用有符号还是无符号`char`。如果`CHAR_MAX == UCHAR_MAX`，那么它必须是无符号的。

还要注意，对于`unsigned`变体，没有最小宏---它们都是`0`。
[i[`short`类型]>]
[i[`long`类型]>]
[i[`long long`类型]>]

## 更多关于浮点数：`double`和`long double`

让我们看一下规范对浮点数的要求在§5.2.4.2.2¶1-2：

```c
// 以下参数用于定义每种浮点类型的模型：
// |参数|定义|
// |:-|:-|
// |$s$|符号 ($\pm1$)|
// |$b$|底数或指数表示的基数 (大于 1 的整数)|
// |$e$|指数 (介于最小值 $e_{min}$ 和最大值 $e_{max}$ 之间的整数)|
// |$p$|精度 (尾数中基数为 $b$ 的数字个数)|
// |$f_k$|小于 $b$ 的非负整数 (尾数数字)|
// 
// 一个 _浮点数_ ($x$) 的定义如下：
// 
// > $x=sb^e\sum\limits_{k=1}^p f_kb^{-k},$\ \ \ \ $e_{min}\le e\le e_{max}$

我希望这样讲清楚了。

好吧，让我们退一步看看现实中怎么用吧。

注意：在这一部分我们引用了一堆宏。可以在头文件 `<float.h>` 中找到它们。

浮点数以特定的位序列编码（[flw[IEEE-754 格式|IEEE_754]] 非常流行），存在字节中。

再深入一些，这个数字基本上由 _尾数_（也就是数字部分——尾数数字本身，有时也称为 _尾数_）和 _指数_ 组成，指数是乘幂的次数。记得负指数会使数字变小。

假设我们使用 $10$ 作为指数的基数。我们可以用尾数 $12345$ 和指数 $-3$、$4$ 和 $0$ 来表示以下数字，来编码以下浮点数值：

$12345\times10^{-3}=12.345$

$12345\times10^4=123450000$

$12345\times10^0=12345$

对于所有这些数字，尾数保持不变。唯一不同的是指数。

在您的计算机上，指数的基数可能是 $2$，而不是 $10$，因为计算机喜欢二进制。您可以通过打印 `FLT_RADIX` 宏来检查它。
```

所以我们有一个用若干字节表示的数字，以某种方式编码。由于存在有限数量的比特模式，因此只能表示有限数量的浮点数。

但更具体地说，只能准确表示一定数量的有效十进制位数。

你如何能获得更多呢？你可以使用更大的数据类型！

我们有几种数据类型。我们已经了解了`float`，但为了更高的精度，我们有`double`。而为了更高的精度，我们有`long double`（与`long int`只是名字类似，并无关联）。

规范没有具体规定每种类型应该占用多少字节的存储空间，但在我的系统上，我们可以看到相对大小的增加：

[double类型]<]
[long double类型]<]

|类型|`sizeof`|
|:-|-:|
|`float`|4|
|`double`|8|
|`long double`|16|

因此在我的系统上，每种类型都使用额外的比特以获得更高的精度。

但这里谈到的精度有多高呢？这些值可以表示多少个十进制数字？

嗯，C语言在`<float.h>`中为我们提供了一堆宏来帮助我们弄清楚这一点。

如果你正在使用基于2进制（二进制）系统存储数字（几乎所有人都在使用，可能包括你在内），那么这可能会有点复杂，但请跟我一起弄清楚。
[double类型]>]
[long double类型]>]

### 有多少个十进制位数？

[有效数字]<]
关键问题是，“在给定的浮点类型中，我可以存储多少个有效的十进制位数，以确保在打印时得到相同的十进制数？”

你可以在这些宏中找到用于获取可以存储在浮点类型中的十进制位数的数量，且在打印时确保能得到相同数字：

[`FLT_DIG`宏]<]
[`DBL_DIG`宏]<]
[`LDBL_DIG`宏]<]

|类型|可存储的小数位数|最小值|我的系统|
|:-|-:|-:|
|`float`|`FLT_DIG`|6|6|
|`double`|`DBL_DIG`|10|15|
|`long double`|`LDBL_DIG`|10|18|

当系统中`DBL_DIG`是10时
当系统中`LDBL_DIG`是10时

在我的系统中，`FLT_DIG`是6，所以我可以确保如果我打印出一个6位的`float`，我会得到同样的结果。(可能会有更多的数字 --- 一些数字会正确返回更多的数字。但绝对会返回6位。)

例如，按照递增数字的模式打印出`float`，我们似乎在出现问题之前接近8位数字，在那之后我们又回到了7位正确的数字。

``` {.default}
0.12345
0.123456
0.1234567
0.12345678
0.123456791  <-- 从这里开始出现问题
0.1234567910
```

让我们做另一个演示。在这段代码中，我们将有两个`float`分别存储着有`FLT_DIG`位有效数字^[此程序在一个`FLT_DIG`是`6`且使用IEEE-754基于二进制浮点数的系统上如注释所示执行。否则，可能会得到不同的输出。]。然后我们将它们相加，应该得到12位有效数字。但这比我们可以存储并正确恢复为字符串的位数多 --- 因此当我们将其打印出来时，在第7个有效数字之后事情开始出错。

``` {.c .numberLines}
#include <stdio.h>
#include <float.h>

int main(void)
{
    // 这两个数字都有6位有效数字，所以可以准确存储在一个float中：

    float f = 3.14159f;
    float g = 0.00000265358f;

    printf("%.5f\n", f);   // 3.14159       -- 正确！
    printf("%.11f\n", g);  // 0.00000265358 -- 正确！

    // 现在将它们相加
    f += g;                // f 应该是 3.14159265358

    printf("%.11f\n", f);  // 3.14159274101 -- 错误！
}
```

```c
// 该代码中数字常量后面有一个`f`---这表示该常量是`float`类型，而不是默认的`double`类型。稍后会详细介绍。

// 请记住 `FLT_DIG` 是您可以存储在`float`中并正确检索的安全数字位数。

// 有时您可能多得到一两个数字位数。但有时您只会得到`FLT_DIG`个数字位数。可以肯定的是: 如果您在`float`中存储任意数量的数字位数，包括`FLT_DIG`，您肯定会正确检索到它们。

// 这就是故事的全部。`FLT_DIG`。结束。

// ...或许不尽然？

### 转换为十进制再返回

但是将一个十进制数存储在浮点数中，然后将其取回只是故事的一部分。

事实证明，浮点数可以编码需要更多所需小数位数才能完全打印出来的数字。只是您的大十进制数字可能无法映射到这些数字中的一个。

也就是说，当您从一个浮点数看到下一个浮点数时，会存在差距。如果您尝试在该差距中编码一个十进制数，则会使用最接近的浮点数。这就是为什么您只能为`float`编码`FLT_DIG`。

但是那些**不在**这个差距中的浮点数怎么办？如果要准确打印出这些数字，需要多少位小数？

另一种表述这个问题的方式是，对于任何给定的浮点数，如果要将十进制数转换回相同的浮点数，需要保留多少十进制数字位数？也就是说，如果要在十进制中打印出**原始数字**中基数为2的所有数字，则需要打印多少位数字？

有时可能只需要几位。但为了确保，您需要将其转换为具有一定安全小数位数的十进制数。这个数字编码在以下宏中：
```

```c
#ifndef FLT_DECIMAL_DIG
#define FLT_DECIMAL_DIG 6
#endif

#ifndef DBL_DECIMAL_DIG
#define DBL_DECIMAL_DIG 10
#endif

#ifndef LDBL_DECIMAL_DIG
#define LDBL_DECIMAL_DIG 10
#endif

#define DECIMAL_DIG LDBL_DECIMAL_DIG

|Macro|Description|
|-|-|
|`FLT_DECIMAL_DIG`|`float` 类型中编码的十进制数字个数。|
|`DBL_DECIMAL_DIG`|`double` 类型中编码的十进制数字个数。|
|`LDBL_DECIMAL_DIG`|`long double` 类型中编码的十进制数字个数。|
|`DECIMAL_DIG`|和最宽编码一样，即`LDBL_DECIMAL_DIG`。|
```

```c
// 所有这些都说了，很明显，一般情况下，我们在处理十进制数时，打印出超过`FLT_DIG`、`DBL_DIG`或`LDBL_DIG`这么多位数字，与原始的十进制数和随后的数学操作相关时，并不安全。 

// 但是，当从`float`转换为十进制表示，然后再转换回`float`时，一定要使用`FLT_DECIMAL_DIG`，以确保所有位完全保留。[i[`FLT_DECIMAL_DIG`宏]>

[i[有效数字]>]

## 常量数值类型

当你书写一个常量数值，比如`1234`时，它是有类型的。但是这个类型是什么呢？让我们看看C是如何确定常量的类型，以及如何强制它选择特定的类型。

### 十六进制和八进制

除了咱们老祖宗用来烤面包的老套的十进制外，C还支持不同进制的常量。

[i[`0x` 十六进制]<]

如果你用`0x`开头一个数字，它会被读为一个十六进制数：

``` {.c}
int a = 0x1A2B;   // 十六进制
int b = 0x1a2b;   // 对于十六进制数，大小写不区分

printf("%x", a);  // 打印一个十六进制数，"1a2b"
```

[i[`0x` 十六进制]>]

[i[`0` 八进制]<]
如果你用`0`开头一个数字，它会被读为一个八进制数：

``` {.c}
int a = 012;

printf("%o\n", a);  // 打印一个八进制数，"12"
```

这对于初学者来说特别棘手，他们试图在十进制数的左边填充`0`以使之对齐漂亮，结果不经意间改变了这个数的进制：

``` {.c}
int x = 11111;  // 十进制 11111
int y = 00111;  // 十进制 73（八进制111）
int z = 01111;  // 十进制 585（八进制1111）
```

[i[`0` 八进制]>]

#### 二进制的注意事项

[i[`0b` 二进制]<]
```

一些C编译器中的非官方扩展在表示二进制数字时允许使用`0b`前缀：

``` {.c}
int x = 0b101010;    // 二进制数 101010

printf("%d\n", x);   // 打印 42 十进制
```

没有用于打印二进制数字的`printf()`格式说明符。您需要使用按位运算符逐个字符地进行打印。

### 整型常量

您可以通过在常量整数后附加指示类型的后缀来强制常量整数成为特定类型。

我们将进行一些赋值操作进行演示，但大多数开发人员通常忽略后缀，除非需要精确。编译器非常善于确保类型兼容。

[i[`U` 无符号常量]<]
[i[`L` 长整型常量]<]
[i[`LL` 长长整型常量]<]
[i[`UL` 无符号长整型常量]<]
[i[`ULL` 无符号长长整型常量]<]

``` {.c}
int           x = 1234;
long int      x = 1234L;
long long int x = 1234LL

unsigned int           x = 1234U;
unsigned long int      x = 1234UL;
unsigned long long int x = 1234ULL;
```

后缀可以是大写或小写。`U` 和 `L` 或 `LL` 可以先出现其中一个。

|类型|后缀|
|:-|:-|
|`int`|无|
|`long int`|`L`|
|`long long int`|`LL`|
|`unsigned int`|`U`|
|`unsigned long int`|`UL`|
|`unsigned long long int`|`ULL`|

在表中提到的“无后缀”表示`int`… 但实际上，情况比这复杂得多。

所以当你有一个没有后缀的数字时会发生什么，比如：

``` {.c}
int x = 1234;
```

它是什么类型？

C 通常会选择从 `int` 开始的最小类型，可以容纳这个值。

但具体来说，这取决于数字的基数（十进制、十六进制或八进制）。

规范中有一张很棒的表，指示了对于没有后缀的值使用哪种类型。实际上，我要全部复制过来。

C11 §6.4.4.1¶5 写道："整数常量的类型是可以代表其值的相应列表中的第一个的第一个。"

然后继续展示这个表：

```c
+----------------+------------------------+-------------------------+
|Suffix          |Decimal Constant        |Octal or Hexadecimal\    |
|                |                        |Constant                 |
+:===============+:=======================+:========================+
| 无             |`int`\                  |`int`\                   |
|                |`long int`              |`unsigned int`\          |
|                |                        |`long int`\              |
|                |                        |`unsigned long int`\     |
|                |                        |`long long int`\         |
|                |                        |`unsigned long long int`\|
|                |                        |                         |
+----------------+------------------------+-------------------------+
|`u` 或 `U`      |`unsigned int`\         |`unsigned int`\          |
|                |`unsigned long int`\    |`unsigned long int`\     |
|                |`unsigned long long int`|`unsigned long long int`\|
|                |                        |                         |
+----------------+------------------------+-------------------------+
|`l` 或 `L`      |`long int`\             |`long int`\              |
|                |`long long int`         |`unsigned long int`\     |
|                |                        |`long long int`\         |
|                |                        |`unsigned long long int`\|
|                |                        |                         |
+----------------+------------------------+-------------------------+
|`u` 或 `U`和    |`unsigned long int`\    |`unsigned long int`\     |
|`l` 或 `L`      |`unsigned long long int`|`unsigned long long int`\|
|                |                        |                         |
+----------------+------------------------+-------------------------+
|`ll` 或 `LL`    |`long long int`         |`long long int`\         |
|                |                        |`unsigned long long int`\|
|                |                        |                         |
+----------------+------------------------+-------------------------+
|`u` 或 `U`和    |`unsigned long long int`|`unsigned long long int` |
|`ll` 或 `LL`    |                        |                         |
+----------------+------------------------+-------------------------+
```

```c
[i[`L`长整型常量]>]
[i[`LL`长长整型常量]>]
[i[`UL`无符号长整型常量]>]
[i[`ULL`无符号长长整型常量]>]

这是在说，举个例子，如果你指定一个像`123456789U`这样的数字，C 会先看能不能当`unsigned int`用。如果不行，它会尝试`unsigned long int`，然后是`unsigned long long int`。它会使用能容纳该数字的最小类型。

[i[`U`无符号常量]>]

[i[整数常量]>]

### 浮点常量

[i[浮点常量]<]

你可能会认为像`1.23`这样的浮点常量默认类型是`float`，对吧？

意外！原来没有后缀的浮点数是类型`double`！迟来的生日快乐！

[i[`F`浮点常量]<]
[i[`L`长双精度浮点常量]<]

你可以通过追加`f`（不区分大小写）强制其为`float`类型。追加`l`（或`L`）可以强制其为`long double`类型。

|类型|后缀|
|:-|:-|
|`float`|`F`|
|`double`|无|
|`long double`|`L`|

例如：

``` {.c}
float x       = 3.14f;
double x      = 3.14;
long double x = 3.14L;
```

[i[`F`浮点常量]>]
[i[`L`长双精度浮点常量]>]

不过，这段时间我们一直在这样做，对吗？

``` {.c}
float x = 3.14;
```

左边是`float`，右边是`double`？对！但C在自动数字转换方面表现得很不错，所以未指定后缀的浮点常量比较常见。稍后我们会详细说明。

[i[浮点常量]>]

#### 科学计数法

[i[科学计数法]<]

还记得之前提过浮点数可以由含义、底数和指数表示吗？
```

```c
// 你知道嘛，其实有一种常见的写法来表示这种数字，下面是展示的方式，后面跟着它更容易认出的等价形式，这个就是你运行数学计算得到的结果：

$1.2345\times10^3 = 1234.5$

以 $s\times b^e$ 的形式写数字被称为[flw[_科学计数法_|Scientific_notation]]。在 C 语言中，使用 "E 表示法" 来书写这些数字，因此下面是等价的：

|科学计数法|E 表示法|
|:-|:-|
|$1.2345\times10^{-3}=0.0012345$|`1.2345e-3`|
|$1.2345\times10^8=123450000$|`1.2345e+8`|

你可以用 `%e` 来以这种表示法打印数字：

``` {.c}
printf("%e\n", 123456.0);  // 打印出 1.234560e+05
```

关于科学计数法的一些有趣事实：

* 在小数点前面，你不必写入单个领先数字。任意数量的数字都可以放在前面。

  ``` {.c}
  double x = 123.456e+3;  // 123456
  ```

  但是，当你打印它时，它会改变指数，所以小数点前面只会有一个数字。

* 指数部分的正号可以省略，因为默认就是正号，但根据我看到的实践，这在实际中比较少见。

  ``` {.c}
  1.2345e10 == 1.2345e+10
  ```

* 你可以对 E-表示法常数应用 `F` 或 `L` 后缀：

  ``` {.c}
  1.2345e10F
  1.2345e10L
  ```

[i[科学计数法]>]

#### 十六进制浮点数常数

[i[十六进制浮点数常数]<]

但是等等，还有更多浮点工作要做！

事实证明，还有十六进制浮点数常数！

它们的工作方式类似于十进制浮点数，但是它们以 `0x` 开头，就像整数一样。

要注意的是，你 _必须_ 指定一个指数，这个指数产生的是 2 的幂。也就是说：$2^x$。

然后，当你书写这个数字时，你需要用 `p` 替换 `e`：

所以 `0xa.1p3` 是 $10.0625\times2^3 == 80.5$。
```

当使用浮点十六进制常量时，
我们可以使用 `%a` 打印十六进制科学计数法：

``` {.c}
double x = 0xa.1p3;

printf("%a\n", x);  // 0x1.42p+6
printf("%f\n", x);  // 80.500000
```

[i[十六进制浮点常量]>]