<!-- Beej的C指南

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 退出程序

发现有很多方法可以实现程序的退出，甚至有方法可以设置“钩子”，在程序退出时运行一个函数。

在本章中，我们将深入研究并查看它们。

我们已经在 [退出状态](#exit-status) 部分讨论了退出状态代码的含义，所以如果有必要，请返回那里复习一下。

本节中的所有函数都在 `<stdlib.h>`中。

## 正常退出

我们将从正常退出程序的常规方式开始，然后转向一些更罕见、更神秘的方式。

当您正常退出程序时，所有打开的 I/O 流都会被刷新，临时文件将被删除。基本上，这是一个很好的退出，所有事情都会被清理和处理。除非您有其他理由，否则这几乎是您几乎总是想要做的。

### 从`main()`返回

[i[退出-->从 `main()` 返回]<]

如果您注意到了，`main()`的返回类型是 `int`... 但我很少，几乎从来没有，从`main()`中 `return` 任何东西。

这是因为对于 `main()` 来说（我再次强调，这个特殊情况 _只_ 适用于 `main()`，不适用于任何其他地方的函数），如果你掉到尾部，有一个 _隐式_ `return 0`。

您可以随时从 `main()` 明确地 `return`，一些程序员觉得在 `main()` 的末尾始终有一个 `return` 更为 _正确_。但如果您省略它，C 将为您加上一个。

所以... 这里是 `main()` 的 `return` 规则：

* 你可以使用 `return` 语句从 `main()` 中返回一个退出状态。`main()`是唯一有这种特殊行为的函数。在任何其他函数中使用 `return` 只是从那个函数返回到调用者。
* 如果你没有显式地使用 `return` 而是退出了 `main()`，就像你返回了 `0` 或 `EXIT_SUCCESS` 一样。

退出-->从 `main()` 返回

### `exit()`

退出-->从 `main()` 返回

这个也出现了几次。如果你在程序的任何地方调用 `exit()`，程序会在那个点退出。

你传递给 `exit()` 的参数是退出状态。

### 用 `atexit()` 设置退出处理程序

`atexit()` 函数

你可以注册函数，当程序退出时调用这些函数，无论是通过从 `main()` 返回还是调用 `exit()` 函数。

使用处理程序函数名调用 `atexit()` 就可以了。你可以注册多个退出处理程序，它们将按照注册的相反顺序调用。

这里是一个例子：

``` {.c .numberLines}
#include <stdio.h>
#include <stdlib.h>

void on_exit_1(void)
{
    printf("调用退出处理程序 1！\n");
}

void on_exit_2(void)
{
    printf("调用退出处理程序 2！\n");
}

int main(void)
{
    atexit(on_exit_1);
    atexit(on_exit_2);
    
    printf("即将退出...\n");
}
```

输出是：

``` {.default}
即将退出...
调用退出处理程序 2！
调用退出处理程序 1！
```

`atexit()` 函数

## 通过 `quick_exit()` 快速退出

`quick_exit()` 函数

这类似于正常退出，不同之处在于：

- 打开的文件可能未被刷新。
- 临时文件可能未被移除。
- `atexit()` 处理程序不会被调用。

但是有一种注册退出处理程序的方式：类似于调用 `atexit()`，调用 `at_quick_exit()`。

``` {.c .numberLines}
#include <stdio.h>
#include <stdlib.h>

void on_quick_exit_1(void)
{
    printf("快速退出处理程序 1 被调用！\n");
}

void on_quick_exit_2(void)
{
    printf("快速退出处理程序 2 被调用！\n");
}

void on_exit(void)
{
    printf("正常退出--我不会被调用！\n");
}

int main(void)
{
    at_quick_exit(on_quick_exit_1);
    at_quick_exit(on_quick_exit_2);

    atexit(on_exit);  // 这部分不会被调用

    printf("即将快速退出...\n");

    quick_exit(0);
}
```

会输出以下内容：

``` {.default}
即将快速退出...
快速退出处理程序 2 被调用！
快速退出处理程序 1 被调用！
```

它的功能类似于 `exit()`/`atexit()`，唯一的区别在于文件刷新和清理可能不会被执行。

## 异常退出：`abort()`

如果出现严重问题并且希望向外部环境指示此情况，可以使用这个函数。这并不一定会清理任何打开的文件等。

我很少见到有人使用这个函数。

有关信号的预告：该函数实际上是通过引发 `SIGABRT` 信号来工作的，这将结束进程。

之后会发生什么取决于系统，但在类Unix系统上，程序终止时通常会进行核心转储。