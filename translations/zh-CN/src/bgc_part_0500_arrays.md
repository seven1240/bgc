<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 数组 {#arrays}

> _“数组的索引应该从0开始还是1开始呢？我的妥协值0.5被拒绝了，我觉得没有得到应有的考虑。”_
>
> ---Stan Kelly-Bootle，计算机科学家

[i[数组]<]
幸运的是，C 有数组。我是说，我知道它被视为一种底层语言^[不过如今是这样]，但至少它内置了数组的概念。而且由于许多语言都从 C 的语法中汲取灵感，你可能已经熟悉使用 `[` 和 `]` 来声明和使用数组。

但是C里的数组只是_勉强_存在！正如我们将在稍后了解的，数组在 C 中只是一种语法糖---它们实际上都是指针之类的深层东西。_吓一跳！_但现在，让我们把它们当作数组来使用。_放心_。

## 简单示例

我们来举个简单的例子：

[i[数组-->索引]<]
``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;
    float f[4];  // 声明一个包含4个浮点数的数组

    f[0] = 3.14159;  // 索引从0开始，当然。
    f[1] = 1.41421;
    f[2] = 1.61803;
    f[3] = 2.71828;

    // 把它们全部打印出来：

    for (i = 0; i < 4; i++) {
        printf("%f\n", f[i]);
    }
}
```

当你声明一个数组时，你必须指定它的大小。并且大小必须是固定的^[再次说明，实际上并非如此，但可变长度数组---我其实不太喜欢---是另一个时间的故事]。

在上面的例子中，我们创建了一个包含4个`float`的数组。声明中方括号中的值告诉了我们这一点。

在随后的行中，我们通过方括号再次访问数组中的值、设置它们或获取它们。
[i[数组-->索引]>]

希望这个看起来对你来说是熟悉的！

## 获取数组的长度

[i[Arrays-->getting the length]<]
你不...呃。C语言不记录这个信息^[因为数组本质上只是一个指针指向数组的第一个元素，底层并没有额外记录长度的信息。]。你需要额外用另一个变量去管理长度。

当我说"不行"时，其实也有一些情况下是_可以_的。有一个技巧可以在数组声明的作用域内获得数组的长度。但是，一般情况下，如果你将数组传递给一个函数，这个方法可能不会按照你期望的方式工作^[因为当你将数组传递给函数时，实际上只是传递了一个指向该数组第一个元素的指针，并不是整个数组。]。

让我们看看这个技巧。基本思路是利用[i[`sizeof` operator-->with arrays]<]`sizeof`操作符来获取数组的大小，然后除以每个元素的大小来得到数组的长度。例如，如果`int`是4字节，数组是32字节长，那里面就可以容纳$\frac{32}{4}$或者$8$个`int`。

``` {.c}
int x[12];  // 12个整数

printf("%zu\n", sizeof x);     // 总共48字节
printf("%zu\n", sizeof(int));  // 每个整数4字节

printf("%zu\n", sizeof x / sizeof(int));  // 48/4 = 12个整数!
```

如果是`char`数组，那么`sizeof`数组的大小_就是_元素的个数，因为`sizeof(char)`被定义为1。对于其他类型，你需要除以每个元素的大小。

但是，这个技巧只在数组声明的作用域内有效。如果你将数组传递给函数，这个方法不起作用。即使你在函数签名中将数组定义得"很大"：

``` {.c}
void foo(int x[12])
{
    printf("%zu\n", sizeof x);     // 8?! 48去哪了？
    printf("%zu\n", sizeof(int));  // 每个整数4字节
```

```c
printf("%zu\n", sizeof x / sizeof(int));  // 8/4 = 2 ints?? 错了。
}
```

因为当你向函数"传递"数组时，实际上只传递了指向第一个元素的指针，这就是`sizeof`所测量的内容。关于这个问题，还有更多内容请参见下面的 [传递一维数组给函数](#passing1darrays) 部分。

使用 `sizeof` 和数组的另一个用途是获取固定数量元素数组的大小，而无需声明这个数组。这类似于通过 `sizeof(int)` 获取 `int` 的大小。

例如，要查看需要多少字节来存储 48 个 `double` 类型的数组，可以这样做：

``` {.c}
sizeof(double [48]);
```
[i[`sizeof`操作符-->对于数组使用]>]
[i[数组-->获取长度]>]

## 数组初始化器

[i[数组初始化器]<]
你可以提前使用常量初始化一个数组：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;
    int a[5] = {22, 37, 3490, 18, 95};  // 使用这些值进行初始化

    for (i = 0; i < 5; i++) {
        printf("%d\n", a[i]);
    }
}
```

在初始化器中的项目数不应多于数组的容量，否则编译器会抱怨：

``` {.zsh}
foo.c: In function ‘main’:
foo.c:6:39: warning: excess elements in array initializer
    6 |     int a[5] = {22, 37, 3490, 18, 95, 999};
      |                                       ^~~
foo.c:6:39: note: (near initialization for ‘a’)
```

但你可能不知道的是，实际上你可以在初始化器中少于数组容量的项目数。数组中剩余的元素会自动初始化为零。这对于所有类型的数组初始化器都是通用的：如果有一个初始化器，那么任何未显式设置数值的内容都会被设为零。

``` {.c}
int a[5] = {22, 37, 3490};

// 就相当于：

int a[5] = {22, 37, 3490, 0, 0};
```

在初始化器中看到这种写法很常见，当你想把整个数组设为零时：

``` {.c}
int a[100] = {0};
```

这表示，“让第一个元素为零，然后自动将其余元素也置为零。”

你也可以通过为值指定索引来在初始化器中设置特定的数组元素！这样做时，C会很乐意继续帮你初始化后续的值，直到初始化器用完为止，并用 `0` 填充其余的值。

只需将索引放在方括号内并在后面加上 `=`，然后设置值即可。

下面是一个构建数组的例子：

``` {.c}
int a[10] = {0, 11, 22, [5]=55, 66, 77};
```

因为我们将索引 5 标记为 `55` 的起始位置，所以数组中的数据如下所示：

``` {.default}
0 11 22 0 0 55 66 77 0 0
```

你也可以在那里放入简单的常量表达式。

``` {.c}
#define COUNT 5

int a[COUNT] = {[COUNT-3]=3, 2, 1};
```

这会得到：

``` {.default}
0 0 3 2 1
```

最后，你也可以让C根据初始化器计算数组的大小，只需忽略掉大小即可：

``` {.c}
int a[3] = {22, 37, 3490};

// 就相当于：

int a[] = {22, 37, 3490};  // 忽略掉了大小！
```
[i[数组初始化器]>]

## 越界访问！

[i[数组-->越界]<]
C不会阻止你访问超出数组边界的元素。甚至可能不会警告你。

让我们继续使用上述例子，并尝试在数组末尾打印超出数组长度的数据。虽然数组只有5个元素，但我们尝试打印10个元素，看看会发生什么：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;
    int a[5] = {22, 37, 3490, 18, 95};
```

```c
for (i = 0; i < 10; i++) {  // 坏消息：打印了太多元素！
    printf("%d\n", a[i]);
}
```

在我的计算机上运行后打印出：

``` {.default}
22
37
3490
18
95
32765
1847052032
1780534144
-56487472
21890
```

哎呀！这是什么情况？嗯，事实证明在数组末尾打印会导致 C 开发者所谓的**未定义行为**。我们稍后会详细讨论这个怪兽，但现在它意味着：“你做了些坏事，你的程序运行时可能出现任何情况。”

而所谓的任何情况，通常会导致发现零、发现垃圾数或崩溃。但实际上，C 规范表示在这种情况下，编译器允许生成执行**任何事情**的代码^[在没有内存保护的好旧 MS-DOS 时代，我曾编写一些特别滥用 C 代码，故意参与各种未定义行为。但我知道自己在做什么，事情一直进展得相当顺利。直到我一失足，导致系统冻结，并在重启时发现，所有 BIOS 设置都已丢失。那真是有趣。对@man的那些欢乐时光表示致意。]。

简而言之：不要做任何会引起未定义行为的事情。永远^[会导致未定义行为的事情有很多，不仅仅是数组越界访问。这正是让 C 语言如此**令人激动**的原因。]。[i[数组-->越界访问]>]

## 多维数组

[i[数组-->多维]<]
你可以为数组添加任意多维度。

``` {.c}
int a[10];
int b[2][7];
int c[4][5][6];
```

这些在内存中以[行优先顺序|行和列优先顺序]存储。这意味着对于二维数组，第一个索引指示行，第二个指示列。

你也可以通过嵌套初始化器来对多维数组进行初始化：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int row, col;

    int a[2][5] = {      // 初始化一个二维数组
        {0, 1, 2, 3, 4},
        {5, 6, 7, 8, 9}
    };

    for (row = 0; row < 2; row++) {
        for (col = 0; col < 5; col++) {
            printf("(%d,%d) = %d\n", row, col, a[row][col]);
        }
    }
}
```

对输出为:

``` {.default}
(0,0) = 0
(0,1) = 1
(0,2) = 2
(0,3) = 3
(0,4) = 4
(1,0) = 5
(1,1) = 6
(1,2) = 7
(1,3) = 8
(1,4) = 9
```

而你也可以使用显式索引初始化：

``` {.c}
// 创建一个3x3的单位矩阵

int a[3][3] = {[0][0]=1, [1][1]=1, [2][2]=1};
```

得到一个如下的二维数组：

``` {.default}
1 0 0
0 1 0
0 0 1
```
[i[数组-->多维数组]>]

## 数组和指针

[i[数组-->作为指针]<]
[_Casual_] 嗯...我在上面可能提到过数组其实是指针，本质上？我们现在稍微深入了解一下，以免心中一把梭。稍后再来探讨数组和指针的真正关系，但现在只讲一下如何向函数传递数组。

### 获取数组的指针

我想告诉你一个秘密。通常情况下，当C程序员谈论指向数组的指针时，实际上是指向数组的 _第一个元素_ 的指针^[从技术上讲，指向数组和指向数组第一个元素的指针有不同的类型。但我们可以等到那时再讨论这个问题]。

让我们获取一个指向数组的第一个元素的指针。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int a[5] = {11, 22, 33, 44, 55};
    int *p;

    p = &a[0];  // p指向数组
                // 实际上是指向第一个元素

    printf("%d\n", *p);  // 输出 "11"
}
```

这在C中是如此普遍，以至于语言允许我们使用一个简洁的写法：

``` {.c .numberLines}
p = &a[0];  // p指向数组

// 相当于：

p = a;      // p指向数组，看起来漂亮多了！
```

只提到数组名就像获得数组第一个元素的指针一样！在接下来的示例中，我们将会广泛使用这个特性。

但等等---`p`不是`int*`吗？而`*p`得到的是`11`，就像`a[0]`一样？对。你开始一窥数组和指针在C中是如何关联的了。

### 将一维数组传递给函数 {#passing1darrays}

让我们来看一个单维数组的示例。我将编写一些函数，我们可以将数组传递给它们，然后函数会做一些不同的事情。

准备好一些惊艳的函数签名！

``` {.c .numberLines}
#include <stdio.h>

// 作为指向第一个元素的指针传递
void times2(int *a, int len)
{
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 2);
}

// 相同的操作，但使用数组符号
void times3(int a[], int len)
{
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 3);
}

// 相同的操作，但使用带有大小的数组符号
void times4(int a[5], int len)
{
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 4);
}

int main(void)
{
    int x[5] = {11, 22, 33, 44, 55};

    times2(x, 5);
    times3(x, 5);
    times4(x, 5);
}
```

所有这些在函数中将数组列为参数的方法都是相同的。

``` {.c}
void times2(int *a, int len)
void times3(int a[], int len)
void times4(int a[5], int len)
```

在C程序员中的实际使用中，第一个方法是最常见的，远远超过其他方法。

实际上，在后一种情况下，编译器甚至不在乎你传递了什么数字进去（除了它必须大于零^[C11 §6.7.6.2¶1要求必须大于零。但你可能会看到一些代码在`struct`的末尾声明了零长度的数组，并且GCC在没有使用`-pedantic`编译选项的情况下对此特别宽容。这种零长度数组是一种用于创建可变长度结构的巧妙机制。不幸的是，访问此类数组其实是未定义行为，尽管它基本上在所有地方都能正常工作。C99为此提供了一个定义明确的替代方法，称为_flexible array members_，我们稍后会讨论。]）。它完全不强制执行任何规定。

既然我说了，函数声明中数组的大小实际上是有关系的，尤其当你将多维数组传递给函数时，但我们稍后会详细讨论这一点。
[i[Arrays-->传递给函数]>]

### 在函数中修改数组

[i[Arrays-->函数内修改]<]
我们已经说过数组只是伪装成指针。这意味着如果你将数组传递给函数，你实际上是在传递对数组中第一个元素的指针。

但如果函数有指向数据的指针，它就能够操纵这些数据！因此，函数对数组所做的更改将在调用者那里可见。

下面是一个示例，我们将一个数组的指针传递给函数，函数修改了该数组中的值，这些更改在调用者那里是可见的。

``` {.c .numberLines}
#include <stdio.h>

void double_array(int *a, int len)
{
    // 将每个元素乘以2
    //
    // 这将使main()函数中x数组的值加倍，因为x和a都指向内存中同一数组！

```c
for (int i = 0; i < len; i++)
        a[i] *= 2;
}

int main(void)
{
    int x[5] = {1, 2, 3, 4, 5};

    double_array(x, 5);

    for (int i = 0; i < 5; i++)
        printf("%d\n", x[i]);  // 2, 4, 6, 8, 10!
}
```

即使我们将数组作为类型为`int*`的参数`a`传递，看看我们如何使用`a[i]`的数组表示方式访问它！什么鬼。这是完全允许的。

稍后当我们谈论数组和指针之间的等价性时，我们会看到这更有道理。目前，知道函数可以修改在调用者处可见的数组就足够了。
[i[Arrays-->modifying within functions]>]

### 将多维数组传递给函数

[i[Arrays-->passing to functions]<]
当谈论多维数组时，情况有些变化。C语言需要知道所有维度（除了第一个维度），以便能够找到存储在内存中的值的位置。

下面是一个我们明确指定所有维度的示例：

``` {.c .numberLines}
#include <stdio.h>

void print_2D_array(int a[2][3])
{
    for (int row = 0; row < 2; row++) {
        for (int col = 0; col < 3; col++)
            printf("%d ", a[row][col]);
        printf("\n");
    }
}

int main(void)
{
    int x[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    print_2D_array(x);
}
```

但在这种情况下，这两者^[这也是等效的：`void
print_2D_array(int (*a)[3])`，但现在不想深入讨论。]是等价的：

``` {.c}
void print_2D_array(int a[2][3])
void print_2D_array(int a[][3])
```

```c
// 编译器实际上只需要第二维，以便确定内存中每一次增加第一维时跳过多远。通常情况下，除了第一个维度外，它需要知道所有的维度。

// 另外，请记住编译器在编译时只进行最少量的边界检查（如果你足够幸运），而 C 语言在运行时根本不检查边界。没有安全带！不要因为访问超出边界的数组元素而导致崩溃！
```