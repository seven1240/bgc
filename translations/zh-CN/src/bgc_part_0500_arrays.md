# 数组

> _“数组索引应该从0开始还是1开始？我的折中方案0.5被拒绝了，我认为没有得到适当的考虑。”_
>
> ---Stan Kelly-Bootle，计算机科学家

幸运的是，C语言拥有数组。我是说，我知道它被认为是一种底层语言^[如今是这样]，但至少它内建了数组的概念。由于许多语言从C的语法中获得了灵感，你可能已经熟悉使用 `[` 和 `]` 来声明和使用数组。

但是C语言中只是 _勉强_ 支持数组！正如我们之后会发现的，数组在C语言中只是一种语法糖---实际上都是指针之类的深层内容。_吓一跳！_ 不过现在，我们就当它们是普通数组就好。_松了口气_。

## 简单示例

让我们来看一个例子：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;
    float f[4];  // 声明一个包含4个浮点数的数组

    f[0] = 3.14159;  // 索引从0开始，当然。
    f[1] = 1.41421;
    f[2] = 1.61803;
    f[3] = 2.71828;

    // 打印所有元素：

    for (i = 0; i < 4; i++) {
        printf("%f\n", f[i]);
    }
}
```

当你声明一个数组时，你必须给它一个大小。而且这个大小必须是固定的^[虽然实际上并不是这样，但可变长度数组---我实际上并不喜欢---是另一个故事了]。

在上面的例子中，我们创建了一个包含4个 `float` 的数组。声明时方括号中的值告诉我们这一点。

之后在后续的代码中，我们使用方括号访问数组中的值，设置或获取它们。

数组-->获取长度

你...不可以。 C语言不记录这个信息。你必须单独管理另一个变量。

当我说“不可以”时，实际上是指在某些情况下你是可以的。有一个技巧可以获取数组在其声明的作用域中的元素数量。但是一般来说，如果你把数组传递给一个函数，这种方法可能并不按你想的那样工作。

让我们看看这个技巧。基本思路是你使用数组的`sizeof`操作符，然后除以每个元素的大小来得到数组的长度。例如，如果`int`是4字节，数组有32字节长，那里面必须能容纳$\frac{32}{4}$或$8$个`int`。

``` {.c}
int x[12];  // 12 个int

printf("%zu\n", sizeof x);     // 48 字节总
printf("%zu\n", sizeof(int));  // 每个int 4 字节

printf("%zu\n", sizeof x / sizeof(int));  // 48/4 = 12 个int！
```

如果是`char`数组，那么数组的`sizeof`就是元素的数量，因为`sizeof(char)`被定义为1。对于其他类型，你必须通过每个元素的大小进行除法。

但是这个技巧仅在数组被定义的作用域内有效。如果你将数组传递给函数，它将无效。即使你在函数签名中把它定义为“大”：

``` {.c}
void foo(int x[12])
{
    printf("%zu\n", sizeof x);     // 8?! 48 发生了什么？
    printf("%zu\n", sizeof(int));  // 每个int 4 字节
```

``` {.c}
printf("%zu\n", sizeof x / sizeof(int));  // 8/4 = 2 个int?? 错误。
}
```

这是因为当你将数组"传递"给函数时，实际上只传递了指向第一个元素的指针，而这就是 `sizeof` 测量的内容。有关更多信息，请参考下面的[将一维数组传递给函数](#passing1darrays)部分。

使用 `sizeof` 与数组还可以得到没有声明数组的固定元素数量的数组的大小。这类似于使用 `sizeof(int)` 来获取 `int` 的大小。

例如，要查看48个 `double` 元素的数组需要多少字节，可以这样做：

``` {.c}
sizeof(double [48]);
```
[i[`sizeof` 运算符-->对数组]>]
[i[数组-->获取长度]>]

## 数组初始化程序

[i[数组初始化程序]<]
您可以提前使用常量初始化数组：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;
    int a[5] = {22, 37, 3490, 18, 95};  // 使用这些值初始化

    for (i = 0; i < 5; i++) {
        printf("%d\n", a[i]);
    }
}
```

在初始化程序中的项目数不应当超过数组中的空间大小，否则编译器会抱怨：

``` {.zsh}
foo.c: In function ‘main’:
foo.c:6:39: warning: excess elements in array initializer
    6 |     int a[5] = {22, 37, 3490, 18, 95, 999};
      |                                       ^~~
foo.c:6:39: note: (near initialization for ‘a’)
```

但是（乐趣的事实！），在数组的初始化程序中可以少于数组的空间大小。数组中的其余元素将会自动初始化为零。总的来说，对于所有类型的数组初始化程序都是如此：如果有初始化器，任何未显式设置值的内容将会被设为零。

``` {.c}
int a[5] = {22, 37, 3490};

// 与下面这行代码等价：

int a[5] = {22, 37, 3490, 0, 0};
```

这在初始化器中是一种常见的简化方式，当你想要将整个数组设置为零时：

``` {.c}
int a[100] = {0};
```

这意味着，“将第一个元素设为零，然后自动将其余的元素也设为零。”

你也可以在初始化器中设置特定的数组元素，只需为值指定索引即可！这样做时，C会很高兴地继续为你初始化后续值，直到初始化器用完为止，并用`0`来填充剩下的所有内容。

为此，将索引放在方括号中，并在后面加上`=`，然后设置值。

下面是一个构建数组的示例：

``` {.c}
int a[10] = {0, 11, 22, [5]=55, 66, 77};
```

因为我们将索引5列为`55`的开始，数组中的数据如下：

``` {.default}
0 11 22 0 0 55 66 77 0 0
```

你也可以在其中放置简单的常量表达式。

``` {.c}
#define COUNT 5

int a[COUNT] = {[COUNT-3]=3, 2, 1};
```

这将得到：

``` {.default}
0 0 3 2 1
```

最后，你也可以通过不指定大小，让C从初始化器中计算数组的大小：

``` {.c}
int a[3] = {22, 37, 3490};

// 与下面这行代码等价：

int a[] = {22, 37, 3490};  // 省略了大小！
```

```s
// 糟糕消息：打印了太多元素！
``` 

在我的电脑上运行后打印出：

```s
22
37
3490
18
95
32765
1847052032
1780534144
-56487472
21890
``` 

天哪！那是什么？嗯，原来打印数组末尾会导致 C 开发者所谓的 **未定义行为**。稍后我们会更详细地讨论这个问题，但现在意味着，“你做了一些不好的事情，在程序运行时可能发生任何事情。”

任何事情，通常是找到零、找到垃圾数字或崩溃。但实际上，在这种情况下，C 标准规定编译器允许发出可以做 **任何事情** 的代码^[在 MS-DOS 时代，在内存保护出现之前，我写了一些特别边缘的 C 代码，故意涉及各种未定义行为。但我知道自己在做什么，事情进行得很顺利。直到我犯了一个错误，引发了冻结，然后发现重启后所有 BIOS 设置都被清空了。那很有趣（感谢 @man 为我带来的乐趣时光）。]。

简而言之：不要做任何导致未定义行为的事情。永远不要^[有很多事情会导致未定义行为，不仅仅是数组访问越界。这就是使 C 语言如此 _激动人心_ 的原因。]。

## 多维数组

可以给数组添加任意多的维度。

```s
int a[10];
int b[2][7];
int c[4][5][6];
```

这些在内存中以 [行主序|行主序和列主序] 的方式存储。这意味着在二维数组中，第一个索引表示行，第二个表示列。

您还可以使用嵌套初始化器来初始化多维数组：
```

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int row, col;

    int a[2][5] = {      // 初始化一个二维数组
        {0, 1, 2, 3, 4},
        {5, 6, 7, 8, 9}
    };

    for (row = 0; row < 2; row++) {
        for (col = 0; col < 5; col++) {
            printf("(%d,%d) = %d\n", row, col, a[row][col]);
        }
    }
}
```

输出为：

``` {.default}
(0,0) = 0
(0,1) = 1
(0,2) = 2
(0,3) = 3
(0,4) = 4
(1,0) = 5
(1,1) = 6
(1,2) = 7
(1,3) = 8
(1,4) = 9
```

你也可以用明确的索引初始化：

``` {.c}
// 创建一个3x3的单位矩阵

int a[3][3] = {[0][0]=1, [1][1]=1, [2][2]=1};
```

构建一个如下所示的二维数组：

``` {.default}
1 0 0
0 1 0
0 0 1
```

## 数组和指针

[_随意_] 所以…我可能之前说过数组就是指针，实际上是隐含的意思？我们现在应该来浅谈一下这方面，不然会变得完全混乱。稍后，我们会真正探讨数组和指针之间的关系，但现在我只想看看如何将数组传递给函数。

### 获取数组的指针

我想告诉你一个秘密。通常情况下，当C程序员谈论数组的指针时，他们说的是指向数组_第一个元素_的指针^[技术上讲是不正确的，因为数组的指针和数组的第一个元素的指针有不同的类型。但等到我们深入讨论的时候再来探讨这一点]。

所以让我们获取一个指向数组第一个元素的指针。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int a[5] = {11, 22, 33, 44, 55};
    int *p;

    p = &a[0];  // p指向数组
                // 实际上，是指向第一个元素

    printf("%d\n", *p);  // 输出 "11"
}
```

在 C 语言中，这样做是非常常见的，语言允许我们使用简化语法：

``` {.c .numberLines}
p = &a[0];  // p 指向数组

// 等同于：

p = a;      // p 指向数组，更加简洁！
```

仅仅引用数组名就等同于得到数组的第一个元素的指针！我们将在接下来的示例中广泛使用这个技巧。

但是等一下---`p` 不是一个 `int*` 吗？`*p` 不是给了我们 `11`，和 `a[0]` 一样吗？没错。你开始窥视数组和指针在 C 中是如何相关的了。

### 将一维数组传递给函数

让我们来看一个单维数组的示例。我将写几个函数，我们可以将数组传递给这些函数，这些函数会执行不同的操作。

准备好迎接一些让你大开眼界的函数声明！

``` {.c .numberLines}
#include <stdio.h>

// 作为指向第一个元素的指针传递
void times2(int *a, int len)
{
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 2);
}

// 相同的操作，但使用数组表示法
void times3(int a[], int len)
{
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 3);
}

// 相同的操作，但使用数组表示法并指定长度
void times4(int a[5], int len)
{
    for (int i = 0; i < len; i++)
        printf("%d\n", a[i] * 4);
}

int main(void)
{
    int x[5] = {11, 22, 33, 44, 55};

    times2(x, 5);
    times3(x, 5);
    times4(x, 5);
}
```

将数组作为函数参数列出的所有方式都是相同的。

``` {.c}
void times2(int *a, int len)
void times3(int a[], int len)
void times4(int a[5], int len)
```

在 C 语言常用者中，第一个方法是最常见的。

实际上，在后一种情况中，编译器甚至不在乎您传入的是什么数字（除了必须大于零[C11§6.7.6.2¶1要求大于零。但您可能会看到一些代码中，结构体末尾声明了零长度的数组，而GCC对此非常宽容，除非您使用`-pedantic`编译。这种零长度的数组是一种用来制作可变长度结构体的hackish机制。不幸的是，尽管基本上这种方法在任何地方都能正常工作，但访问这样的数组却属于技术上未定义的行为。 C99规范化了一个名为_flexible array members_的替代物，我们稍后会详细讨论。]）。它根本不执行任何内容。

现在我已经说了，函数声明中数组的大小实际上_是_有影响的，当您将多维数组传递给函数时，但我们稍后再回来讨论。
[Arrays-->传递给函数]

### 在函数中修改数组

[Arrays-->在函数中修改]<]

我们说过，数组实际上只是伪装成指针。这意味着如果将数组传递给函数，您实际上是将数组中第一个元素的指针传递给了函数。

但如果函数有指向数据的指针，就能够操纵这些数据！因此，函数对数组所做的更改将在调用者那里可见。

这是一个示例，我们将数组的指针传递给函数，该函数操纵该数组中的值，并且这些更改在调用者那里是可见的。

``` {.c .numberLines}
#include <stdio.h>

void double_array(int *a, int len)
{
    // 将每个元素乘以2
    //
    // 这会使main()函数中的x中的值翻倍，因为x和a都指向内存中的同一个数组！

```c
for (int i = 0; i < len; i++)
    a[i] *= 2;
}

int main(void)
{
    int x[5] = {1, 2, 3, 4, 5};

    double_array(x, 5);

    for (int i = 0; i < 5; i++)
        printf("%d\n", x[i]);  // 2, 4, 6, 8, 10!
}
```

尽管我们将数组作为参数`a`以`int*`类型传递，但看看我们如何使用`a[i]`的数组表示法来访问它！哇。这是完全允许的。

稍后当我们讨论数组和指针之间的等价性时，我们会看到这是多么合理。暂时来说，知道函数可以改变调用方可见的数组就足够了。

### 将多维数组传递给函数

故事在谈论多维数组时有些变化。C语言需要了解所有的维度（除了第一个维度），以便有足够的信息在内存中查找值的位置。

下面是一个我们明确指定所有维度的示例：

```c
#include <stdio.h>

void print_2D_array(int a[2][3])
{
    for (int row = 0; row < 2; row++) {
        for (int col = 0; col < 3; col++)
            printf("%d ", a[row][col]);
        printf("\n");
    }
}

int main(void)
{
    int x[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };

    print_2D_array(x);
}
```

但在这种情况下，这两个函数声明是等效的：

```c
void print_2D_array(int a[2][3])
void print_2D_array(int a[][3])
```

编译器实际上只需要第二维度，这样它就能够确定在内存中跳过多远以便每次增加第一维度。通常情况下，它需要知道除了第一个维度之外的所有维度。

还要记住，编译器进行最小的编译时边界检查（如果你很幸运的话），而C语言在运行时不检查边界。没座椅带！不要通过访问超出范围的数组元素导致崩溃！