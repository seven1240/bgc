<!-- Beej的C指南

# vim：ts = 4：sw = 4：nosi：et：tw = 72
-->
# 指针---畏惧吧! {#pointers}

> _"你怎样才能到达卡内基音乐厅呢？"_ \
> _"练习！"_
>
> ---来自未知来源的20世纪笑话

[i[Pointers]<]指针是C语言中最令人畏惧的东西之一。事实上，它们是使这门语言具有挑战性的唯一原因。但是为什么呢？

因为坦率地说，它们可能会导致电击从键盘上传来，将你的手臂永久焊接在那里，诅咒你一生都要在这门来自70年代的语言中度过！

真的吗？嗯，并不是。我只是想让你成功。

根据你来自哪种语言，你可能已经了解"引用"的概念，其中一个变量指向某种类型的对象。

这与引用非常相似，只是在C语言中我们必须更加明确地表明我们是在谈论引用还是其引用的对象。


## 内存和变量 {#ptmem}

计算机内存保存各种数据，对吧？它可以保存`float`、`int`或其他任何类型。为了方便处理内存，每个内存字节都由一个整数标识。当你在内存中向上移动时，这些整数会顺序递增^[通常来说是这样。我确信在计算历史的幽暗走廊中会有一些例外情况。]。你可以把它想象成一堆编号的盒子，每个盒子都保存一个字节^[一个字节是由不多于8个二进制数字或简称为"位"组成的数字。这意味着像奶奶过去使用的十进制数字一样，它可以保存一个介于0和255之间的无符号数。]的数据，或者像一个大数组，其中每个元素都保存一个字节，如果你来自一种带有数组的语言。表示每个盒子的数字被称为其"地址"[i[内存地址]]。

现在，并非所有数据类型都只使用一个字节。例如，一个 `int` 通常是四个字节，一个 `float` 也是如此，但这实际取决于系统。您可以使用 `sizeof` 运算符来确定某种类型使用了多少字节的内存。

``` {.c}
// %zu 是类型 size_t 的格式说明符

printf("an int uses %zu bytes of memory\n", sizeof(int));

// 这段代码输出的是 "4"，但在不同系统中可能会有所不同。
```

> **内存趣闻**: 当你有一个数据类型（比如你典型的 `int`）使用超过一个字节的内存时，组成数据的字节在内存中总是相邻的。有时它们的顺序符合你的预期，有时则不是。而 C 语言并不保证任何特定的内存顺序（这取决于平台），但通常仍然可以编写与平台无关的代码，而无需考虑这些令人头痛的字节顺序问题。

所以 _无论如何_，如果我们可以继续下去，并打起鼓点，让一些令人担忧的音乐为指针的定义奏响，_指针是一个保存地址的变量_。想象一下在这一点上来自《2001太空漫游》的古典配乐。Ba bum ba bum ba bum BAAAAH!

好的，也许有点过火了，是吧？指针并没有太多神秘之处。它们是数据的地址。就像 `int` 变量可以保存值 `12` 一样，指针变量可以保存数据的地址。

这意味着所有这些东西都表示相同的意思，即代表内存中某个位置的数字：

* 内存中的索引（如果你将内存想象成一个大数组）
* 地址
* 位置

我会把它们交替使用。是的，我刚才加入了“位置”这个词，因为意思相同的词越多越好。

指针变量保存着那个地址编号。就像一个 `float` 变量可能保存 `3.14159` 一样。

想象一下你有一堆便利贴，每张便利贴都按顺序编号着地址。（第一张的索引号为 `0`，下一张为索引 `1`，依此类推。）

除了数字表示它们的位置外，你还可以在每张便利贴上写另一个你选择的数字。可以是你有的狗的数量。或火星周围的卫星数量...

...或者，它可以是另一张便利贴的索引！

如果你写下你拥有的狗的数量，那只是一个普通的变量。但如果你在那里写下了另一张便利贴的索引号，那就是一个指针。它指向另一张便利贴！

另一个类比可以是房屋地址。你可以拥有一座带有特定特征的房子，院子、金属屋顶、太阳能等。或者你可以拥有那座房子的地址。地址并不等同于房子本身。一个是一座完整的房子，另一个只是几行文字。但房子的地址则是指向那座房子的指针。它不是房子本身，但告诉你在哪里找到它。

在计算机中，我们也可以用数据做同样的事情。你可能有一个数据变量保存着某个值。而那个值在内存中的某个地址。另一个不同的_指针变量_ 可以保存那个数据变量的地址。

它并不是数据变量本身，但就像房屋地址一样，它告诉我们在哪里找到它。

当我们拥有这个时，我们称之为对这个数据的“指针”。我们可以跟随指针以访问数据本身。

（尽管目前看起来似乎不是特别有用，但当与函数调用一起使用时，这一切将变得必不可少。请耐心等待，直到我们到达那里。）

因此，如果我们有一个`int`，并且我们想要一个指向它的指针，我们想要的是一种获取该`int`地址的方法，是吗？毕竟，指针只是保存数据的地址。你觉得我们会使用什么操作符来找到`int`的地址？

[i[`&` 取地址运算符]<]由于这个令人震惊的惊喜可能会对你这位亲切的读者产生某种震惊，我们使用`取地址`操作符（恰好是一个安培手："`&`"）来找到数据的地址。安培手。

因此，举个快速示例，我们将介绍一个新的`printf()`的_格式说明符_，这样你就可以打印一个指针。你已经知道`%d`是如何打印十进制整数的，对吗？嗯，`%p`[i[`printf()` 函数-->与指针一起]]打印一个指针。现在，这个指针看起来可能像一个垃圾数字（并且可能以十六进制^[也就是基数为16，使用数字0、1、2、3、4、5、6、7、8、9、A、B、C、D、E和F。]而不是十进制来打印），但它只是数据存储在内存中位置的索引。（或者如果数据是多字节的，则是第一个数据字节存储在内存中的索引。）在几乎所有情况下，包括这个，打印的数字实际值对你来说并不重要，我在这里展示它仅是为了演示`取地址`操作符。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i = 10;

    printf("i的值是%d\n", i);
    printf("它的地址是%p\n", (void *)&i);

// %p 期望参数是一个指向 void 的指针
// 因此我们进行强制类型转换以让编译器满意。

```

在我的计算机上，这会打印：

``` {.default}
i 的值是 10
它的地址是 0x7ffddf7072a4
```

如果你感兴趣，这个十六进制数在十进制（和奶奶以前用的十进制一样）中是 140,727,326,896,068。这是变量 `i` 的数据存储的内存索引。它是 `i` 的地址。它是 `i` 的位置。它是指向 `i` 的指针。

这是一个指针，因为它告诉你 `i` 在内存中的位置。就像一张写有特定房子位置的纸条告诉你可以在哪里找到一栋特定的房屋一样，这个数字告诉我们在内存中的哪里可以找到 `i` 的值。它指向 `i`。

再次强调，通常我们并不关心地址的具体数值。我们只关心它是指向 `i` 的指针。

## 指针类型 {#pttypes}

所以... 这都挺不错的。你现在可以成功地取得一个变量的地址并打印在屏幕上了。对于老简历来说，这算是点睛之笔，对吧？接下来，让我来解释一下指针有什么用。

这是一个很好的问题，我们将在接下来的篇章中讨论这个问题。

> `ACME 机器人住宅清洁服务。你的家园将得到显著改善，否则你将被终结。消息结束。`

欢迎回到 Beej's Guide 的另一期。上次我们讨论了如何使用指针。接下来我们将把一个指针存储在一个变量中，以便以后使用。你可以通过变量名前后的星号 (`*`) 辨认出这是一个 _指针类型_：

``` {.c .numberLines}
int main(void)
{
    int i;  // i的类型是"int"
    int *p; // p的类型是"指向int的指针"

}
```

嘿，这里有一个变量，类型是指针，可以指向其他 `int`。也就是说，它可以保存其他 `int` 的地址。我们知道它指向 `int`，因为它的类型是 `int*`（读作“int-pointer”）。

当你将值赋给一个指针变量时，赋值右侧的类型必须与指针变量的类型相同。幸运的是，当你取一个变量的地址时，得到的类型是该变量类型的指针，因此类似以下的赋值是完美的：

``` {.c}
int i;
int *p;  // p是一个指针，但未初始化且指向垃圾

p = &i;  // p被赋值为i的地址，p现在“指向”i
```

在赋值的左边，我们有一个类型为指向 `int` 的指针（`int*`），而在右边，我们有一个类型为指向 `int` 的表达式，因为 `i` 是一个 `int`（因为取 `int` 的地址得到指针）。一个事物的地址可以存储在一个指向该事物的指针中。

明白了吗？我知道这还不太有意义，因为你还没有看到指针变量的实际用途，但我们正在一步一步地向前走，以免有人迷路。现在，让我们引入反取地址运算符。它有点像奇异世界中的 `address-of`。

当你有一个指向变量的指针（大致意思为“变量的引用”），你可以通过对指针进行“解引用”来使用原始变量。（你可以将这看作是对指针进行“去指向”，但没有人会说“去指向”。）

重新回到我们的比喻，这有点像查看一个家庭地址，然后前往那所房子。

那么，我所说的“访问原始变量”是什么意思呢？嗯，如果你有一个名为 `i` 的变量，以及一个指向 `i` 的指针，名为 `p`，你可以像使用原始变量 `i` 一样使用被解引用的指针 `p`！

你差不多掌握了足够的知识来处理一个例子了。你需要知道的最后一点是：什么是解引用操作符？它实际上被称为 _间接操作符_，因为你是通过指针间接访问值。并且它还是星号，再一次：`*`。现在，不要将这个与你之前在指针声明中使用的星号搞混了。它们是相同的字符，但在不同的上下文中有着不同的含义。

这里是一个完整的例子：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;
    int *p;  // 这不是一个解引用——这是一个类型 "int*"

    p = &i;  // 现在 p 指向 i，p 包含 i 的地址

    i = 10;  // i 现在是 10
    *p = 20; // p 指向的东西（即 i！）现在是 20！！

    printf("i is %d\n", i);   // 输出 "20"
    printf("i is %d\n", *p);  // "20"！解引用 p 就等同于 i！
}
```

记住 `p` 保存着 `i` 的地址，你可以看到我们在第8行对 `p` 赋值。间接操作符所做的是告诉计算机使用指针指向的对象，而不是使用指针本身。这样，我们已经将 `*p` 转换成了 `i` 的一种别名。

不错，但为什么？为什么要做这些事情？

## 将指针作为参数传递 {#ptpass}

此时，你可能会觉得你对指针有很多了解，但完全没有应用，对吧？我的意思是，如果你可以简单地说 `i` 而不是 `*p`，那 `*p` 有什么用呢？

嗯，朋友，指针的真正威力在于当你开始将它们传递给函数时发挥作用。这为什么那么重要？也许你还记得之前提到过，你可以将各种参数传递给函数，它们会被忠实地复制到参数中，然后你可以在函数内部操作这些变量的本地副本，然后只能返回一个值。

如果你想从函数中取回多个数据呢？我的意思是，你只能返回一个东西，对吧？如果我用另一个问题回答那个问题呢？...哦，还是两个问题？

当你将指针作为参数传递给函数时会发生什么？指针的副本会被放入对应的参数中吗？_当然会。_  还记得之前我一直在啰嗦 _每一个参数_ 都会被复制到参数中，函数使用的是参数的副本吗？这里也是一样的。函数将会获得指针的一个副本。

但，这里的巧妙之处在于：我们事先会设置指针指向一个变量...然后函数可以对指针的副本进行解引用，以返回到原始变量上！函数看不到变量本身，但它肯定可以解引用指向该变量的指针！

这就好比在一张纸上写下家庭地址，然后将其复制到另一张纸上。现在你有了两个指向那个房子的指针，两者同样有效地指向房子本身。

在函数调用中，其中一个副本存储在调用作用域中的指针变量中，另一个存储在函数的参数中的指针变量中。

举个例子！让我们重新审视一下我们之前的`increment()`函数，但这一次让它实际上递增调用者中的值。

``` {.c .numberLines}
#include <stdio.h>

void increment(int *p)  // 注意它接受一个整型指针
{
    *p = *p + 1;        // 将指针p指向的东西加一
}

int main(void)
{
    int i = 10;
    int *j = &i;  // 注意地址-of操作符；将其转换为指向i的指针

    printf("i is %d\n", i);        // 输出"10"
    printf("i也是 %d\n", *j);  // 输出"10"

    increment(j);                  // j是一个int*--指向i

    printf("i is %d\n", i);        // 输出"11"！
}
```

好！这里有几件事情要注意... 至少其中之一是`increment()`函数接受一个`int*`作为参数。我们在调用中传递了一个`int*`，将`int`变量`i`通过`地址-of`操作符转换为`int*`。（记住，指针保存一个地址，所以我们通过`地址-of`操作符将变量转换为指针。）

`increment()` 函数会得到指针的一个副本。原始指针 `j`（在 `main()` 中）和指针副本 `p`（`increment()` 函数中的参数）都指向相同的地址，即保存变量 `i` 值的那个地址。（用类比的方法来看，就像两张写有相同家庭地址的纸张。）对任何一个进行解引用都可以修改原始变量 `i`！函数可以修改其他作用域的变量！太棒了！

上面的例子通常在调用时更加简洁，只需在参数列表中直接使用取地址运算符：

``` {.c}
printf("i is %d\n", i);  // 输出 "10"
increment(&i);
printf("i is %d\n", i);  // 输出 "11"！
```

作为一般规则，如果你希望函数修改传入的东西以便查看结果，那么你必须传递一个指向该东西的指针。

## `NULL`指针

任何指针类型的指针变量都可以设置为一个特殊值称为 `NULL`。这表示这个指针不指向任何内容。

``` {.c}
int *p;

p = NULL;
```

由于它不指向一个值，对它进行解引用是未定义的行为，可能会导致崩溃：

``` {.c}
int *p = NULL;

*p = 12;  // 可能会导致崩溃或其他糟糕情况。最好避免。
```

尽管被其创造者称为 [flw[十亿美元的错误|Null_pointer#History]]，`NULL`指针是一个很好的 [flw[哨兵值|Sentinel_value]]和普通指示器，表示该指针尚未被初始化。

（当然，就像其他变量一样，除非你明确将其分配给一个地址或 `NULL`，否则指针指向的是垃圾。）
[i[`NULL`指针]>]

## 关于声明指针的说明

[i[指针-->声明]<]声明指针的语法可能有些怪异。让我们看看这个示例：

我们可以将这两行合并成一行，是吧？

``` {.c}
int a, b;  // 同样的意思
```

所以 `a` 和 `b` 都是 `int` 类型。没问题。

但是这种情况呢？

``` {.c}
int a;
int *p;
```

我们能把它写成一行吗？能。但 `*` 应该放在哪里呢？

规则是 `*` 放在任何指针类型的变量前面。也就是说，在这个例子中 `*` 不是 `int` 的一部分，而是变量 `p` 的一部分。

有了这个理解，我们可以这样写：

``` {.c}
int a, *p;  // 同样的意思
```

需要注意的是，以下行并不声明两个指针：

``` {.c}
int *p, q;  // p 是指向 int 的指针；q 只是一个 int。
```

如果程序员写下以下有效的代码行，这可能看起来特别隐蔽，但与上面的代码在功能上是相同的。

``` {.c}
int* p, q;  // p 是指向 int 的指针；q 只是一个 int。
```

所以看一眼以下代码，并确定哪些变量是指针，哪些不是：

``` {.c}
int *a, b, c, *d, e, *f, g, h, *i;
```

我将在脚注里给出答案。[i[Pointers-->declarations]>]

## `sizeof` 和指针

[i[Pointers-->with `sizeof`]<]这里有一点小小的语法，可能会让人困惑，而且你可能会时不时看到。

记住 `sizeof` 操作的是表达式的 _类型_。

``` {.c}
int *p;

// 打印 'int' 的大小
printf("%zu\n", sizeof(int));

// p 的类型是 'int *'，所以打印 'int*' 的大小
printf("%zu\n", sizeof p);

// *p 的类型是 'int'，所以打印 'int' 的大小
printf("%zu\n", sizeof *p);
```

你可能会在代码里看到最后面有这个 `sizeof`。只要记住，`sizeof` 是关于表达式的类型，而不是表达式中的变量。