C语言指南

# vim：ts=4:sw=4:nosi:et:tw=72

# 类型 IV：限定符和说明符

现在我们已经学习了更多类型，原来我们可以为这些类型添加一些额外属性来控制它们的行为。这些是 _类型限定符_ 和 _存储类说明符_。

## 类型限定符

[i[类型限定符]<]

这些将允许你声明常量值，并为编译器提供可以使用的优化提示。

### `const`

[i[`const` 类型限定符]<]

这是你会经常看到的最常见的类型限定符。它意味着变量是常量，任何试图修改它的操作都会导致编译器报错。

``` {.c}
const int x = 2;

x = 4;  // 编译器会报错，无法给常量赋值
```

你无法修改一个 `const` 值。

通常你会在函数的参数列表中看到 `const`：

``` {.c}
void foo(const int x)
{
    printf("%d\n", x + 30);  // 没问题，不会修改"x"
}
```

#### `const` 和指针

[i[`const` 类型限定符-->和指针]<]

这会有点混乱，因为对于指针有两种用法，涉及到两种不同的含义。

首先，我们可以设置指针指向的内容无法修改。这可以通过在类型声明中将 `const` 放在类型名字前面（星号之前）来实现。

``` {.c}
int x[] = {10, 20};
const int *p = x; 

p++;  // 我们可以修改 p，没有问题

*p = 30; // 编译错误！无法修改指针指向的内容
```

有些困惑的是，下面这两个是等价的：

``` {.c}
const int *p;  // 无法修改p指向的内容
int const *p;  // 无法修改p指向的内容，与上一个行相同
```

很好，所以我们无法改变指针指向的东西，但可以改变指针本身。那如果我们想要相反的情况呢？我们想要能够改变指针指向的内容，但是 _不_ 可以改变指针本身吗？

只需将`const`移到声明中星号的后面：

``` {.c}
int *const p;   // 我们无法通过指针算术修改“p”

p++;  // 编译器错误！
```

但我们可以修改它们指向的内容：

``` {.c}
int x = 10;
int *const p = &x;

*p = 20;   // 将“x”设置为20，没问题
```

你也可以同时将两者都设置为`const`：

``` {.c}
const int *const p;  // 无法修改 p 或 *p！
```

最后，如果有多级间接引用，应该为适当的级别添加`const`修饰符。仅仅因为一个指针是`const`，并不意味着它所指向的指针也必须是。你可以像以下示例中 expliclty 设置它们：

``` {.c}
char **p;
p++;     // OK!
(*p)++;  // OK!

char **const p;
p++;     // 错误！
(*p)++;  // OK!

char *const *p;
p++;     // OK!
(*p)++;  // 错误！

char *const *const p;
p++;     // 错误！
(*p)++;  // 错误！
```

[i[`const` 类型修饰符-->和指针]>]

#### `const` 正确性

[i[`const` 类型修饰符-->正确性]<]

我还需要提一件事是编译器会对类似下面这样的代码发出警告：

``` {.c}
const int x = 20;
int *p = &x;
```

并显示类似以下的信息：

``` {.default}
initialization discards 'const' qualifier from pointer type target
```

那里发生了什么？

我们需要看一下赋值号两侧的类型：

``` {.c}
    const int x = 20;
    int *p = &x;
//    ^       ^
//    |       |
//  int*    const int*
```

编译器警告我们赋值语句右侧的值是 `const`，但左侧的值并非如此。编译器告诉我们它会丢弃右侧表达式的 "const-ness"。

也就是说，我们_可以_尝试执行以下操作，但是这是错误的。编译器会发出警告，并且其行为是未定义的：

``` {.c}
const int x = 20;
int *p = &x;

*p = 40;  // 未定义行为——可能修改了 "x"，也可能没有！

printf("%d\n", x);  // 如果你幸运的话是 40
```

[i[`const` 类型限定符-->正确性]>]
[i[`const` 类型限定符]>]

### `restrict`

[i[`restrict` 类型限定符]<]

TLDR：你永远不需要使用它，每次看到它都可以忽略。如果正确使用它，可能会获得一些性能提升。如果使用不正确，会导致未定义行为。

`restrict` 是向编译器提示的信息，一块特定的内存只会被一个指针访问，而不是另一个。 （也就是说，`restrict` 指针指向的特定对象没有别名。）如果开发者声明一个指针为 `restrict`，然后以另一种方式访问它指向的对象（比如通过另一个指针），其行为是未定义的。

基本上你在告诉C语言，"嘿——我保证只有这一个指针是我访问这块内存的方式，如果我说谎，你可以对我施加未定义行为。"

而C语言会利用这些信息进行一些优化。例如，如果你在循环中重复解引用 `restrict` 指针，C语言可能会决定在寄存器中缓存结果，并且只在循环完成时存储最终结果。如果任何其他指针引用同一块内存，并且在循环中访问它，结果将不准确。

请注意，如果指向的对象从未被写入，`restrict` 将不起作用。 这完全围绕对内存的写入进行优化。

让我们编写一个交换两个变量的函数，并使用 `restrict` 关键字来确保 C 知道我们永远不会传入指向相同东西的指针。 然后让我们来试着传入指向相同东西的指针。

``` {.c .numberLines}
void swap(int *restrict a, int *restrict b)
{
    int t;

    t = *a;
    *a = *b;
    *b = t;
}

int main(void)
{
    int x = 10, y = 20;

    swap(&x, &y);  // OK！上面的 "a" 和 "b" 指向不同的东西

    swap(&x, &x);  // 未定义行为！"a" 和 "b" 指向相同的东西
}
```

如果去掉上面的 `restrict` 关键字，那么两次调用都会安全工作。 但是编译器可能无法进行优化。

`restrict` 具有块作用域，即其约束仅在其使用的作用域内有效。 如果它在函数的参数列表中使用，它将在该函数的块作用域中。

如果限制指针指向数组，则仅适用于数组中的各个对象。 其他指针可以从数组读取和写入，只要它们没有读取或写入与受限制指针相同的任何元素即可。

如果它位于文件范围内任何函数之外，则限制将覆盖整个程序。

你可能会在像 `printf()` 这样的库函数中看到这样的用法：

``` {.c}
int printf(const char * restrict format, ...);
```

再次说明一下：如果由于某种原因在函数参数中使用数组表示法而非指针表示法，你可以这样使用 `restrict`：

``` {.c}
void foo(int p[restrict])     // 没有大小

void foo(int p[restrict 10])  // 或者有大小
```

但是指针表示法更常见。

[i[`restrict` 类型修饰符]>]

### `volatile`

[i[`volatile` 类型修饰符]<]

除非直接处理硬件，否则不太可能看到或需要这个。

`volatile` 告诉编译器，一个值可能会在其背后发生变化，应该每次查找时重新查看。

一个示例可能是编译器在内存中查看一个地址，该地址在后台不断更新，例如某种硬件计时器。

如果编译器决定进行优化并将值存储在寄存器中一段时间，内存中的值将会更新，但在寄存器中不会反映出来。

通过声明某些内容为`volatile`，你告诉编译器，“嘿，指向的东西可能随时因为程序代码范围之外的原因而发生变化。”

``` {.c}
volatile int *p;
```

### `_Atomic`

这是一个可选的C语言特性，我们将在[原子操作章节](#chapter-atomics)中讨论。

[i[`volatile` 类型修饰符]>]
[i[类型修饰符]>]

## 存储类说明符

[i[存储类说明符]<]

存储类说明符类似于类型修饰符。它们向编译器提供有关变量类型的更多信息。

### `auto`

[i[`auto` 存储类]<]

你很少会看到这个关键字，因为`auto`是块作用域变量的默认设置。它是隐含的。

以下两者是相同的：

``` {.c}
{
    int a;         // auto 是默认的...
    auto int a;    // 因此这是冗余的
}
```

`auto` 关键字指示这个对象具有 _自动存储期_。也就是说，它存在于定义它的作用域中，并且在退出作用域时会自动释放。
```

关于自动变量的一点需要注意的是，在显式初始化它们之前，它们的值是不确定的。我们说它们充满了“随机”或“垃圾”数据，但这两个词都不太让人满意。无论如何，除非你初始化它，否则你不知道其中包含什么。

在使用前始终初始化所有自动变量！

### `static` {#static}

该关键字有两个含义，取决于变量是文件作用域还是块作用域。

让我们从块作用域开始。

#### 块作用域中的 `static`

在这种情况下，我们基本上是在说：“我只希望存在这个变量的单个实例，供调用之间共享。”

也就是说，它的值将在调用之间保持不变。

在块作用域中具有初始化程序的 `static` 变量只会在程序启动时初始化一次，而不是每次调用函数时重新初始化。

让我们来看一个例子：

``` {.c .numberLines}
#include <stdio.h>

void counter(void)
{
    static int count = 1;  // 这个值只初始化一次

    printf("这已被调用 %d 次\n", count);

    count++;
}

int main(void)
{
    counter();  // "这已被调用 1 次"
    counter();  // "这已被调用 2 次"
    counter();  // "这已被调用 3 次"
    counter();  // "这已被调用 4 次"
}
```

看到 `count` 的值在调用之间保持不变了吗？

需要注意的一点是，`static` 块作用域变量默认初始化为 `0`。

``` {.c}
static int foo;      // 默认起始值为 `0`...
static int foo = 0;  // 因此 `0` 的分配是多余的
```

最后，请注意，如果你在编写多线程程序，务必确保不要让多个线程破坏相同的变量。

### 在文件作用域中的`static`

当你走到文件作用域之外，超出任何块之外时，含义会有所改变。

文件作用域中的变量在函数调用之间已经保持不变，因此行为已经确定。

在这种情况下，`static`的意思是这个变量在这个特定源文件之外是不可见的。有点像"全局"，但只在这个文件中。

关于如何在多个源文件中构建更多的内容，请参考后面的部分。

### `extern`

`extern`存储类说明符为我们提供了一种引用其他源文件中的对象的方法。

举个例子，假设文件`bar.c`中仅有以下内容：

``` {.c .numberLines}
// bar.c

int a = 37;
```

就只有这么多。在文件作用域中声明了一个新的`int a`。

但是如果我们有另一个源文件`foo.c`，我们想要引用`bar.c`中的`a`怎么办呢？

使用`extern`关键字很简单：

``` {.c .numberLines}
// foo.c

extern int a;

int main(void)
{
    printf("%d\n", a);  // 37，来自bar.c！

    a = 99;

    printf("%d\n", a);  // 来自bar.c的相同"a"，但现在是99
}
```

我们也可以将`extern int a`放在块作用域内，它仍然会引用`bar.c`中的`a`：

``` {.c .numberLines}
// foo.c

int main(void)
{
    extern int a;

    printf("%d\n", a);  // 37，来自bar.c！

    a = 99;

    printf("%d\n", a);  // 来自bar.c的相同"a"，但现在是99
}
```

现在，如果`bar.c`中的`a`被标记为`static`，这个方法就不会奏效。文件作用域中的`static`变量在该文件之外是不可见的。

关于函数上的 `extern` 还有一点需要注意。对于函数来说，`extern` 是默认的，因此是多余的。如果你仅希望函数在单个源文件中可见，你可以将函数声明为 `static`。

`register`

这是一个关键字，用来提示编译器这个变量会频繁使用，应尽可能快地访问。编译器没有义务同意这个要求。

现在，现代的 C 编译器优化器在这方面已经非常有效了，所以很少见到这种情况。

但如果你一定要：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    register int a;   // 让 “a” 尽可能快地使用。

    for (a = 0; a < 10; a++)
        printf("%d\n", a);
}
```

不过，这种做法是有代价的。你不能取得寄存器变量的地址：

``` {.c}
register int a;
int *p = &a;    // 编译错误! 不能取寄存器的地址
```

同样的情况也适用于数组的任何部分：

``` {.c}
register int a[] = {11, 22, 33, 44, 55};
int *p = a;  // 编译错误! 不能取a[0]的地址
```

或者对数组的部分进行间接引用：

``` {.c}
register int a[] = {11, 22, 33, 44, 55};

int a = *(a + 2);  // 编译错误! 取地址 a[0]
```

有趣的是，对于使用数组表示的这种等价情况，gcc 只会发出警告：

``` {.c}
register int a[] = {11, 22, 33, 44, 55};

int a = a[2];  // 编译警告!
```

其中报出：

``` {.default}
warning: ISO C forbids subscripting ‘register’ array
```

不能取寄存器变量的地址这一事实，使编译器可以在假设还未解决该问题时围绕这一假设进行优化。此外，将 `register` 添加到 `const` 变量中可以防止意外将其指针传递给另一个忽略其 `constness` 的函数^[https://gustedt.wordpress.com/2010/08/17/a-common-misconsception-the-register-keyword/]。

稍微了解一下历史背景：在 CPU 深处有一些专用的“变量”（称为 [flw[_registers_|Processor_register]]）。与 RAM 相比，它们的访问速度非常快，因此使用它们会提高速度。但它们不在 RAM 中，因此它们没有相关的内存地址（这就是为什么你不能取地址或获取它们的指针）。

但是，正如我所说的，现代编译器非常擅长生成最佳代码，无论您是否指定了 `register` 关键字，它们总是尽可能地使用寄存器。不仅如此，规范允许它们将其视为您键入了 `auto`，如果它们想的话。因此不提供任何保证。

### `_Thread_local`

当您使用多线程并且有一些变量位于全局或 `static` 块作用域中时，这是一种确保每个线程都获得变量副本的方法。这将帮助您避免竞态条件和线程相互干扰。

如果您在块作用域中，您必须与 `extern` 或 `static` 一起使用该存储类。

此外，如果包含 `<threads.h>`，您可以使用更舒服的 `thread_local` 作为更难看的 `_Thread_local` 的别名。

更多信息请参阅[线程部分](#thread-local)。