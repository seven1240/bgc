C语言指南

# vim: ts=4:sw=4:nosi:et:tw=72

第三章：类型转换

在本章中，我们将讨论从一种类型转换为另一种类型的所有内容。C 有多种方法可以实现这一点，其中一些可能与您在其他语言中所习惯的方式有所不同。

在谈论如何进行转换之前，让我们先谈一下当它们发生时它们是如何工作的。

## 字符串转换

与许多语言不同，C 并不像对数值转换那样流畅地进行字符串转换（反之亦然）。

对于这些转换，我们需要调用函数来完成这些繁琐的工作。

### 数值转换为字符串

当我们想要将数字转换为字符串时，我们可以使用 `sprintf()`（发音为 _SPRINT-f_）或 `snprintf()`（_s-n-print-f_）^[它们基本上像 `printf()` 一样工作，只是输出到字符串而已，稍后可以打印该字符串，或者进行其他操作。]

例如，将值 π 的一部分转换为字符串：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    char s[10];
    float f = 3.14159;

    // 将"f"转换为字符串，并存储在"s"中，最多写入 10 个字符，包括 NUL 终止符

    snprintf(s, 10, "%f", f);

    printf("字符串值：%s\n", s);  // 字符串值：3.141590
}
```

因此，您可以像对整数一样使用 `%d` 或 `%u`。

### 字符串转换为数值

在C中有一些函数族可完成这项工作。我们将其称为`atoi`（发音为 _a-to-i_）族和 `strtol`（_stir-to-long_）族。

对于从字符串转换为数字的基本转换，尝试使用`<stdlib.h>`中的`atoi`函数。这些函数具有糟糕的错误处理特性
（包括如果传入错误的字符串会导致未定义行为），所以要小心使用。

|函数|描述|
|:-|:-|
|`atoi`|字符串到`int`|
|`atof`|字符串到`float`|
|`atol`|字符串到`long int`|
|`atoll`|字符串到`long long int`|

尽管规范没有明确说明，但函数名称开头的`a`代表[flw[ASCII|ASCII]]，所以实际上`atoi()`是“ASCII到整数”的意思，但如今这么说有点偏向ASCII。

这里有一个将字符串转换为`float`的示例：

``` {.c .numberLines}
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    char *pi = "3.14159";
    float f;

    f = atof(pi);

    printf("%f\n", f);
}
```

但就像我之前说的，我们会通过奇怪的事情得到未定义行为，比如：

``` {.c}
int x = atoi("what");  // "What"不是我听说过的任何数
```

（当我运行它时，会返回`0`，但你真的不应该依赖这点。你可能会得到完全不同的结果。）

为了更好的错误处理特性，让我们来看看所有那些`strtol`函数，它们也在`<stdlib.h>`中。不仅如此，它们还能转换更多的类型和更多的进制！

|函数|描述|
|:-|:-|
|`strtol`|字符串到`long int`|
|`strtoll`|字符串到`long long int`|
|`strtoul`|字符串到`unsigned long int`|
|`strtoull`|字符串到`unsigned long long int`|
|`strtof`|字符串到`float`|
|`strtod`|字符串到`double`|
|`strtold`|字符串到`long double`|

这些函数都遵循相似的使用模式，是许多人第一次接触指针的体验！但不要担心---比看起来更简单。

让我们做一个示例，将一个字符串转换为一个 `unsigned long`，丢弃错误信息（即输入字符串中的无效字符信息）：

``` {.c .numberLines}
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    char *s = "3490";

    // 将字符串 s 转换为十进制的无符号长整型数。
    // NULL 表示我们不关心任何错误信息。

    unsigned long int x = strtoul(s, NULL, 10);

    printf("%lu\n", x);  // 3490
}
```

请注意几点。尽管我们没有捕获任何关于字符串中错误字符的信息，`strtoul()` 不会导致未定义行为；它只会返回 `0`。

另外，我们指定这是一个十进制（以 10 为基数）的数字。

这是否意味着我们可以转换不同进制的数字？当然可以！让我们来做一个二进制的示例吧！

``` {.c .numberLines}
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    char *s = "101010";  // 这个数字是什么意思呢？

    // 将字符串 s 转换为二进制的无符号长整型数。

    unsigned long int x = strtoul(s, NULL, 2);

    printf("%lu\n", x);  // 42
}
```

好了，这都很有趣，但那个 `NULL` 是什么意思？这是干什么用的？

这有助于我们确定处理字符串时是否出现错误。这是一个指向指针的 `char`，听起来很吓人，但一旦你理解了它，就会觉得并不复杂。

让我们来一个例子，我们输入一个故意不良的数字，看看 `strtol()` 如何告诉我们第一个无效数字在哪里。

``` {.c .numberLines}
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    char *s = "34x90";  // "x" 不是十进制中有效的数字！
    char *badchar;

    // 将字符串 s 转换为十进制的无符号长整型数。
```

```c
unsigned long int x = strtoul(s, &badchar, 10);

// 它会尽可能地转换，所以达到了这个程度：

printf("%lu\n", x);  // 34

// 但是我们可以看到错误的字符，因为 badchar
// 指向了它！

printf("无效字符：%c\n", *badchar);  // "x"
}
```

所以我们看到 `strtoul()` 修改了 `badchar` 指向的位置来显示我们在哪里出错了。

但是如果没有出错呢？在这种情况下，`badchar` 将指向字符串末尾的 `NUL` 终止符。因此我们可以检查它：

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    char *s = "3490";  // "x" 在十进制中不是一个有效的数字！
    char *badchar;

    // 将字符串 s（一个十进制数）转换为一个无符号长整型数。

    unsigned long int x = strtoul(s, &badchar, 10);

    // 检查转换是否成功

    if (*badchar == '\0') {
        printf("成功！%lu\n", x);
    } else  {
        printf("部分转换：%lu\n", x);
        printf("无效字符：%c\n", *badchar);
    }
}
```

所以这就是它。`atoi()`-风格的函数在某些情况下用起来很方便，但是 `strtol()`-风格的函数让你更加控制错误处理和输入的进制。

[i[类型转换-->字符串]>]

## `char` 类型转换

[i[类型转换-->`char`]<]

如果你有一个带有数字的单个字符，比如 `'5'`... 它和数值 `5` 是相同的吗？

让我们试一试。

```c
printf("%d %d\n", 5, '5');
```

在我的UTF-8系统上，这段代码输出：

``` {.default}
5 53
```

所以...不是。53？那是什么？那是字符符号 `'5'` 的UTF-8（和ASCII）代码点。^[每个字符在任何给定的字符编码方案中都有一个关联的值。]

那么，我们如何将字符 `'5'` （显然值为53）转换为值 `5` 呢？

就靠一个巧妙的技巧！

C标准保证这些字符的代码点是按顺序且按此顺序的：

``` {.default}
0  1  2  3  4  5  6  7  8  9
```

思考一下——我们如何利用这点？接下来有剧透...

让我们看看UTF-8中的字符及其代码点：

``` {.default}
0  1  2  3  4  5  6  7  8  9
48 49 50 51 52 53 54 55 56 57
```

你可以看到 `'5'` 是 `53`，就像我们得到的那样。而 `'0'` 是 `48`。

所以我们可以从任何数字字符中减去 `'0'` 来得到它的数字值：

``` {.c}
char c = '6';

int x = c;  // x 的值是 54，即 '6' 的代码点

int y = c - '0'; // y 的值是 6，正如我们所期望的
```

另一方向的转换也可以，只需要加上相应的值。

``` {.c}
int x = 6;

char c = x + '0';  // c 的值是 54

printf("%d\n", c);  // 输出 54
printf("%c\n", c);  // 使用 %c 输出 6
```

你可能会认为这是一种奇怪的转换方式，从今天的标准来看，它确实是。但在计算机被真正用木头制造的古老时代，这就是进行此转换的方法。而且它没有出错，所以C也没有更改它。

[i[类型转换-->`char`]>]

## 数值转换

[i[类型转换-->数值]<]

### 布尔值

[i[类型转换-->布尔值]]

如果将零转换为 `bool`，结果是 `0`。否则就是 `1`。

### 整数到整数的转换

[i[类型转换-->整数]<]

如果将整数类型转换为无符号类型且无法适应，则无符号的结果会以类似读数表样式绕回，直到适应为止。

如果将整数类型转换为有符号数字并且无法适应，则结果是实现定义的！会发生记录在案的事情，但您需要查看。

整数和浮点数转换

如果将浮点数类型转换为整数类型，则小数部分会被丢弃。

但是——这里有个问题——如果数字太大而无法适应整数，则会获得未定义行为。所以不要这样做。

在从整数或浮点数转换为浮点数时，C会尽力找到与其最接近的浮点数。

但是，如果原始值无法表示，则会有未定义的行为。

隐式转换

这些是当您混合不同类型时编译器为您自动执行的转换。

在一些情况下，如果`int`可以用于表示`char`或`short`（有符号或无符号）的值，那么该值会被提升到`int`。 如果它不适合`int`，则会被提升为`unsigned int`。

这就是我们可以这样做的方式：

``` {.c}
char x = 10, y = 20;
int i = x + y;
```

在这种情况下，C在执行数学运算之前将`x`和`y`提升为`int`。

整数提升发生在标准算术转换期间，涵盖可变参数函数^[具有可变数量参数的函数。]、一元`+`和`-`运算符，或在没有原型的情况下传递值给函数^[这很少这样做，因为编译器会报错，而拥有原型是正确的做法。我认为这仍然适用于历史原因，在原型出现之前是这样的。]。

### 标准算术转换 {#usual-arithmetic-conversions}

这些是C在您请求的数字操作周围执行的自动转换。（顺便说一句，这确实是它们的名称，根据C11 §6.3.1.8。）请注意，对于本节，我们只谈论数字类型--- 字符串将稍后介绍。

这些转换回答了当您混合类型时会发生什么的问题，就像这样：

``` {.c}
int x = 3 + 1.2;   // 混合int和double
                   // 4.2转换为int
                   // 4 存储在x中

float y = 12 * 2;  // 混合float和int
                   // 24 转换为float
                   // 24.0 存储在y中
```

它们会变成`int`吗？ 会变成`float`吗？ 它是如何工作的？

以下是简化后的步骤，以便易于理解。 

1. 如果表达式中的一个元素是浮点类型，则将另一个元素转换为该浮点类型。

2. 否则，如果两种类型都是整数类型，则对每种类型执行整数提升，然后将操作数类型扩展到能够容纳最大值的大小。有时，这涉及将有符号类型更改为无符号类型。

如果您想了解细节，请查看C11 §6.3.1.8。但您可能不想了解。

通常记住，如果其中有浮点类型，则整数类型会变成浮点类型，编译器会尽力确保混合整数类型不会溢出。

最后，如果从一种浮点类型转换为另一种，编译器会尝试进行精确转换。如果无法完成，它将尽其所能进行最佳近似。如果要转换为的类型无法容纳太大的数字，_boom_：未定义行为！

### `void*`

`void*` 类型很有趣，因为它可以从任何指针类型转换为或转换为。

``` {.c}
int x = 10;

void *p = &x;  // &x 是 int* 类型，但我们将其存储在 void* 中

int *q = p;    // p 是 void* 类型，但我们将其存储在 int* 中
```

[i[Type conversions-->implicit]>]

## 显式转换

[i[Type conversions-->explicit]<]

这些是您必须请求的类型之间的转换；编译器不会为您执行。

您可以通过使用 `=` 将一种类型赋给另一种类型来进行从一种类型到另一种类型的转换。

您还可以使用 _强制转换_ 明确地进行转换。

[i[Type conversions-->numeric]>]

### 强制转换

[i[Type conversions-->casting]<]

您可以通过在表达式前面括号中放入新类型来明确更改表达式的类型。有些 C 开发人员不赞同这种做法，除非绝对必要，但您可能会遇到一些包含这些内容的 C 代码。

让我们做一个例子，我们想将一个 `int` 转换为一个 `long`，以便我们可以将其存储在一个 `long` 中。

注意：这个例子是刻意构造的，在这种情况下执行强制转换是完全不必要的，因为`x + 12`表达式会自动转换为`long int`以匹配更宽的`y`类型。

在这个例子中，尽管`x`之前是`int`类型，表达式`(long int)x`的类型为`long int`。我们说，“我们将`x`强制转换为`long int`”。

更常见的情况是，您可能会看到一个强制转换被用来将一个`void*`转换为特定的指针类型，以便可以对其进行解引用。

内置的`qsort()`函数中的回调可能会显示这种行为，因为它传入的是`void*`：

``` {.c}
int compar(const void *elem1, const void *elem2)
{
    if (*((const int*)elem2) > *((const int*)elem1)) return 1;
    if (*((const int*)elem2) < *((const int*)elem1)) return -1;
    return 0;
}
```

但您也可以用一个赋值语句清晰地编写它：

``` {.c}
int compar(const void *elem1, const void *elem2)
{
    const int *e1 = elem1;
    const int *e2 = elem2;

    return *e2 - *e1;
}
```

您经常会看到强制转换的一个地方是为了避免在打印指针值时出现警告，使用很少见的`%p`要求除了`void*`以外的任何东西都不允许：

``` {.c}
int x = 3490;
int *p = &x;

printf("%p\n", p);
```

会生成如下警告：

``` {.default}
warning: format ‘%p’ expects argument of type ‘void *’, but argument
         2 has type ‘int *’
```

您可以用一个强制转换来解决这个问题：

``` {.c}
printf("%p\n", (void *)p);
```

另一个地方是在明确指针更改时使用，如果您不想使用中间的`void*`，但这也是相当罕见的：

``` {.c}
long x = 3490;
long *p = &x;
unsigned char *c = (unsigned char *)p;
```

通常需要进行类型转换的第三个情况是在[fl[`<ctype.h>`|https://beej.us/guide/bgclr/html/split/ctype.html]]中的字符转换函数中，您应该将存在疑问的有符号值转换为`unsigned char`，以避免未定义的行为。

再次强调，实际中很少需要进行强制类型转换。如果发现自己需要进行类型转换，可能有另一种方法可以实现相同的功能，或者您可能是不必要地进行了强制类型转换。

但也有可能是必需的。就个人而言，我尽量避免使用强制类型转换，但如果有必要的话也不排斥使用。

[i[类型转换-->显式]>]
[i[类型转换-->强制类型转换]>]
[i[类型转换]>]