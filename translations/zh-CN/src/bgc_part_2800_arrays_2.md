```c
// 数组第二部分

我们在本章将讨论关于数组的一些额外杂项内容。

* 带有数组参数的类型限定符
* 带有数组参数的`static`关键字
* 部分多维数组初始化器

虽然不是很常见，但我们会看一下它们，因为它们是较新规范的一部分。

## 参数列表中数组的类型限定符

如果你还记得之前提到过的，这两种在函数参数列表中是等效的：

``` {.c}
int func(int *p) {...}
int func(int p[]) {...}
```

你可能也记得，你可以像这样给指针变量添加类型限定符：

``` {.c}
int *const p;
int *volatile p;
int *const volatile p;
// 等等
```

但是当我们在参数列表中使用数组表示法时怎么做呢？

原来类型限定符应该放在方括号内。你可以在后面添加可选计数。下面的两行是等效的：

``` {.c}
int func(int *const volatile p) {...}
int func(int p[const volatile]) {...}
int func(int p[const volatile 10]) {...}
```

如果你有一个多维数组，你需要将类型限定符放在第一组方括号里。

## 参数列表中数组的`static`

同样，在参数列表中的数组中可以使用关键字static。

这是我从未见过的东西。它**总是**后跟一个尺寸：

``` {.c}
int func(int p[static 4]) {...}
```
```

在上面的例子中，这意味着编译器将假定您传递给函数的任何数组都至少包含4个元素。

其他情况属于未定义行为。

``` {.c}
int func(int p[static 4]) {...}

int main(void)
{
    int a[] = {11, 22, 33, 44};
    int b[] = {11, 22, 33, 44, 55};
    int c[] = {11, 22};

    func(a);  // 没问题！a有4个元素，是最小值
    func(b);  // 没问题！b至少有4个元素
    func(c);  // 未定义行为！c少于4个元素！
}
```

这基本上是设置您可以拥有的最小大小数组。

重要提示：编译器中没有任何东西禁止您传入一个更小的数组。编译器可能不会警告您，并且不会在运行时检测到。

通过在其中加入`static`，您在说，“我特别承诺永远不会传入比这更小的数组。” 然后编译器说，“好的，行”，并相信您不会这样做。

然后编译器就可以进行某些代码优化，放心地相信您，作为程序员，会始终做正确的事情。

[i[数组--->参数列表中的`static`]>]

## 等效的初始化器

[i[数组--->多维数组的初始化器]<]

当涉及到数组初始化时，C语言有点，我们可以说，_灵活_。

我们已经看到了其中的一些情况，即缺失的值将被替换为零。

例如，我们可以使用以下方法将一个具有5个元素的数组初始化为`1, 2, 0, 0, 0`：

``` {.c}
int a[5] = {1, 2};
```

或者将一个数组完全设置为零：

``` {.c}
int a[5] = {0};
```

但在初始化多维数组时一切变得有趣起来。

让我们创建一个3行2列的数组：

``` {.c}
int a[3][2];
```

让我们编写一些代码来初始化它并打印结果：

``` {.c}
#include <stdio.h>
```

```c
int main(void)
{
    int a[3][2] = {
        {1, 2},
        {3, 4},
        {5, 6}
    };

    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 2; col++)
            printf("%d ", a[row][col]);
        printf("\n");
    }
}
```

当我们运行它时，我们得到了预期的输出：

``` {.default}
1 2
3 4
5 6
```

让我们省略一些初始化元素，看看它们是否会被设置为零：

``` {.c}
    int a[3][2] = {
        {1, 2},
        {3},    // 漏掉了4！
        {5, 6}
    };
```

这将产生：

``` {.default}
1 2
3 0
5 6
```

现在让我们完全省略最后一个嵌套元素：

``` {.c}
    int a[3][2] = {
        {1, 2},
        // {3, 4},   // 整行删掉了
        {5, 6}
    };
```

现在我们得到了这个结果，可能不是你所期待的：

``` {.default}
1 2
5 6
0 0
```

但如果你仔细想想，我们只提供了足够的初始化值来填充两行，所以它们被用于前两行。剩下的元素被初始化为零。

目前一切顺利。通常，如果我们省略了初始化器的一部分，编译器会将相应的元素设置为`0`。

但让我们变得“疯狂”一点。

``` {.c}
    int a[3][2] = { 1, 2, 3, 4, 5, 6 };
```

什么---？ 这是一个二维数组，但却只有一维的初始化值！

事实证明这是合法的（虽然使用适当的警告时，GCC会发出警告）。

基本上，它从左到右开始填充第0行，然后是第1行，然后是第2行。

因此，当我们打印时，它按顺序打印：

``` {.default}
1 2
3 4
5 6
```

如果我们省略了一些：

``` {.c}
    int a[3][2] = { 1, 2, 3 };
```

它们将被填充为`0`：

``` {.default}
1 2
3 0
0 0
```

所以，如果你想将整个数组填充为`0`，那就继续：

``` {.c}
    int a[3][2] = {0};
```

```c
// 但是我的建议是，如果你有一个二维数组，最好使用二维初始化器。
// 这样代码看起来更清晰易懂。（除非你要将整个数组初始化为 `0`，在这种情况下，无论数组的维数如何，惯用的做法是使用 `[{0}]`）

[i[Arrays-->multidimensional initializers]>
```