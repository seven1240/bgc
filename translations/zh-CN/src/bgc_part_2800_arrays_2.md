# 数组第二部分

本章我们将继续讨论有关数组的一些额外杂项内容。

* 参数中的数组类型修饰符
* 参数中的`static`关键字
* 部分多维数组初始化器

虽然它们并不是很常见，但我们会一探究竟，因为它们是较新规范的一部分。

## 参数列表中的数组类型修饰符

如果您还记得之前提到的，以下两个函数参数列表的方式是等效的：

``` {.c}
int func(int *p) {...}
int func(int p[]) {...}
```

您可能也记得，您可以像这样给指针变量添加类型修饰符：

``` {.c}
int *const p;
int *volatile p;
int *const volatile p;
// 等等
```

但是当我们在参数列表中使用数组表示法时，我们该怎么做呢？

原来修饰符应该放在方括号中。您还可以在其后添加可选的计数。以下两行是等效的：

``` {.c}
int func(int *const volatile p) {...}
int func(int p[const volatile]) {...}
int func(int p[const volatile 10]) {...}
```

如果您有一个多维数组，则需要将类型修饰符放在第一组方括号中。

## 参数列表中的`static`数组

类似地，您可以在参数列表中的数组中使用关键字static。

这是我从未见到的东西。它**始终**后跟一个维度：

``` {.c}
int func(int p[static 4]) {...}
```

在上面的示例中，这意味着编译器将假设您传递给函数的任何数组都**至少**包含4个元素。

其他情况属于未定义行为。

这基本上设定了您可以拥有的最小尺寸数组。

重要提示：编译器中没有任何东西会禁止您传递一个更小的数组。编译器可能不会警告您，并且它在运行时也不会检测到它。

通过将`static`放在那里，您是在说：“我双倍保证我永远不会传入比这个更小的数组。” 编译器会说：“好的，好的”，并相信您不会这样做。

然后编译器可以进行某些代码优化，对您这个程序员总是做正确的事情保持信心。

[对等的初始化程序]

多维初始化器

当涉及到数组初始化程序时，C语言有点，我们可以说，_灵活_。

我们已经看到了一些，其中任何缺失的值都将被替换为零。

例如，我们可以使用以下方式将包含5个元素的数组初始化为`1,2,0,0,0`：

``` {.c}
int a[5] = {1, 2};
```

或者用以下方式将整个数组设置为零：

``` {.c}
int a[5] = {0};
```

但是当初始化多维数组时情况变得有趣。

让我们创建一个有3行2列的数组：

``` {.c}
int a[3][2];
```

我们来编写一些代码来初始化它并打印结果：

``` {.c}
#include <stdio.h>
```

```c
int main(void)
{
    int a[3][2] = {
        {1, 2},
        {3, 4},
        {5, 6}
    };

    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 2; col++)
            printf("%d ", a[row][col]);
        printf("\n");
    }
}
```

当我们运行时，得到了预期的输出：

```c
1 2
3 4
5 6
```

让我们省略一些初始化元素，看看它们会被设置为零：

```c
    int a[3][2] = {
        {1, 2},
        {3},    // 没有写入4！
        {5, 6}
    };
```

这将产生：

```c
1 2
3 0
5 6
```

现在让我们完全省略最后一个中间元素：

```c
    int a[3][2] = {
        {1, 2},
        // {3, 4},   // 整个省略掉了
        {5, 6}
    };
```

现在我们得到了这个结果，可能不是你期望的：

```c
1 2
5 6
0 0
```

但是如果你仔细想想，我们只提供了足够的初始值来初始化两行，因此它们被用于前两行。其余元素被初始化为零。

到目前为止还好。通常，如果我们省略了初始化器的一部分，编译器会将相应的元素设置为`0`。

但让我们“疯狂”一下。

```c
    int a[3][2] = { 1, 2, 3, 4, 5, 6 };
```

什么？那是一个二维数组，但初始化只有一维数组！

实际上，这是合法的（尽管 GCC 在打开适当警告时会发出警告）。

基本上，它从左至右开始填充第0行元素，然后是第1行，然后是第2行。

因此，如果我们打印输出，会按顺序打印：

```c
1 2
3 4
5 6
```

如果我们省略了一些：

```c
    int a[3][2] = { 1, 2, 3 };
```

它们会被填充为`0`：

```c
1 2
3 0
0 0
```

所以，如果你想将整个数组填充为`0`，那就：

```c
    int a[3][2] = {0};
```

但是我的建议是，如果你有一个二维数组，使用一个二维初始化器。
这只是让代码更容易阅读。(除了用`0`初始化整个数组的情况，这种情况下不管数组的维度如何，习惯上都使用`{0}`)