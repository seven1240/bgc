``` {.c .numberLines}
# 函数 {#functions}

> _"先生，在这种环境中不适合这样做。这也是为什么我被设计了超过三十个辅助功能的原因。"_
>
> ---C3PO，被粗鲁地打断，报告了一个现在看起来不那么显著的额外功能数量，《星球大战》剧本

[Functions]
就像你熟悉的其他语言一样，C语言也有函数的概念。

函数可以接受各种参数，并返回一个值。然而有一件重要的事情：参数和返回值类型是预先声明的——因为这是C语言的偏好！

让我们看一个函数。这是一个以`int`为参数并返回`int`的函数。

``` {.c .numberLines}
#include <stdio.h>

int plus_one(int n)  // 函数定义
{
    return n + 1;
}
 
```

`plus_one`前面的`int`表示返回类型。

`int n`表示这个函数接受一个`int`类型的参数，存储在名为`n`的参数中。参数是一种特殊的本地变量，其中复制了传入的参数值。

这里我要强调这一点，参数值会被复制到参数中。如果你知道参数是参数值的 _副本_ 而不是参数值本身，会更容易理解C语言中的很多事情。稍后我们会详细讨论这一点。

继续我们的程序，在`main()`中我们可以看到对函数的调用，我们将返回值赋给本地变量`j`：

``` {.c .numberLines startFrom="8"}
int main(void)
{
    int i = 10, j;
    
    j = plus_one(i);  // 函数调用

    printf("i + 1 是 %d\n", j);
}
```

在我忘记之前，要注意我在使用函数之前就定义了它。如果我没有这样做，编译器在编译`main()`时还不知道这个函数，会导致未知函数调用错误。有一种更合适的方法来编写上述代码，使用_函数原型_，但我们以后再讨论。

另外要注意，`main()`函数！

返回一个`int`。

但是这个`void`是什么鬼？这是一个关键字，用来表明这个函数不接受任何参数。

你也可以返回`void`来表示你不返回任何值：

``` {.c .numberLines}
#include <stdio.h>

// 这个函数不接受任何参数，也不返回任何值

void hello(void)
{
    printf("Hello, world!\n");
}

int main(void)
{
    hello();  // 输出 "Hello, world!"
}
```

## 按值传递 {#passvalue}

在我前面提到当你将一个参数传递给函数时，该参数的一个副本会被制作并存储在相应的参数中。

如果参数是一个变量，那么该变量的值的副本会被制作并存储在参数中。

更普遍地说，整个参数表达式会被评估，并确定它的值。这个值被复制到参数中。

无论如何，参数中的值都是独立的。它与你在函数调用时使用的任何值或变量无关。

接下来让我们看一个例子。先学习并确定输出结果，然后再运行代码：

``` {.c .numberLines}
#include <stdio.h>

void increment(int a)
{
    a++;
}

int main(void)
{
    int i = 10;

    increment(i);

    printf("i == %d\n", i);  // 这会打印什么？
}
```

```c
//程序解释
等一开始，看似 `i` 是 `10`，然后我们将它传递给 `increment()` 函数。在那里，值被递增，所以当我们打印它时，应该是 `11`，对吧？

> _"习惯失望吧。"_
>
> --- Dread Pirate Roberts，《公主新娘》

但实际上不是 `11` —— 打印出来的是 `10`！怎么回事？

这一切关乎你传递给函数的表达式会被 _复制_ 到相应的参数上。参数是一个拷贝，而非原始值。

所以在 `main()` 中，`i` 是 `10`。然后我们将其传递给 `increment()`。在函数中，相应的参数名为 `a`。

拷贝就像是一种赋值一样进行。可以理解为 `a = i`。那么此时，`a` 是 `10`。而在 `main()` 中，`i` 也是 `10`。

接着我们将 `a` 递增至 `11`。但实际上我们并没有改变 `i`！它仍然是 `10`。

最后，函数执行完毕。所有局部变量被丢弃（再见，`a`！），我们回到 `main()`，此时 `i` 仍然是 `10`。

我们打印它，得到 `10`，然后结束。

这就是为什么在前面的 `plus_one()` 函数示例中，我们`return`了局部修改过的值，以便在 `main()` 中再次看到它。

看起来有些受限制，是吧？好像你只能从函数中得到一个数据返回。但是，还有另一种获取数据的方式；C 程序员称之为 _引用传递_，这个话题我们以后再讲。

但是，没有什么花里胡哨的名字会让你忽视这样一个事实：_你传递给函数的_ **每一样东西，没有例外地** _都会被复制到相应的参数中，并且函数会在本地拷贝上进行操作，_ **无论如何** _。记住这一点，即使我们谈论所谓的引用传递也是如此。
[i[按值传递]>]

## 函数原型 {#prototypes}
```

```c
[i[功能原型]<]所以如果你回忆起前几节讲的冰河时代的内容，我提到过你必须在使用函数之前先定义它，否则编译器就不会提前知道这个函数，最终会因为错误而中断。

事实并非完全如此。你可以预先告诉编译器你将使用某种类型、带有特定参数列表的函数。这样一来，函数可以随意定义在任何地方（甚至是另一个文件中），只要在调用该函数之前已经声明了_函数原型_。

幸运的是，函数原型非常简单。它只是函数定义的第一行复制粘贴到最后加上分号。例如，以下代码调用的函数稍后才被定义，因为事先有个原型声明：

``` {.c .numberLines}
#include <stdio.h>

int foo(void);  // 这就是函数的原型！

int main(void)
{
    int i;
    
    // 在这里我们可以调用foo()，即使它的定义在下面，
    // 因为原型已经在上面声明了！

    i = foo();
    
    printf("%d\n", i);  // 3490
}

int foo(void)  // 这是定义，和原型一样！
{
    return 3490;
}
```

如果你在使用函数之前没有声明（用原型或定义），那就是在进行所谓的_隐式声明_[i[隐式声明]]。在第一个C标准（C89）中允许这样做，并有相关规则，但在今天已不被允许。因此在新代码中依赖此方法是没有正当理由的。
```

```markdown
你可能已经注意到我们一直在使用的示例代码有个问题... 就是，我们一直在使用老旧的 `printf()` 函数，却没有定义或声明原型！我们怎么能做到这种违反规则的事情呢？实际上我们并没有偷懒。其实是有原型的；就在我们用 `#include` 包含的那个头文件 `stdio.h` 里，还记得吗？所以我们是合法的，警官！

## 空参数列表

有时候在旧代码里可能会看到这种写法，但在新代码里绝对不应该这样写。应该始终使用 `void` 来表示一个函数不接受参数。现代代码中永远都没有 [永远别说"永远"] 忽略这一点的理由。

如果你习惯于在函数和原型的空参数列表中记得加入 `void`，那么可以跳过这一部分剩下的内容。

存在两种情况：

* 在函数定义中省略所有参数
* 在原型中省略所有参数

让我们先看一个潜在的函数定义：

``` {.c}
void foo()  // 应该真的加上 `void`
{
    printf("Hello, world!\n");
}
```

虽然规范规定在这种情况下的行为就好像你已经加上了 `void` 一样（C11 §6.7.6.3¶14），但 `void` 类型是有它存在的理由的。要使用它。

但是在函数原型的情况下，使用 `void` 与不使用有 _显著_ 差别：

``` {.c}
void foo();
void foo(void);  // 不同！
```

在原型中省略 `void` 表示告诉编译器关于函数参数没有额外信息。这将有效地关闭所有类型检查。

对于一个原型，**一定** 要在空参数列表中使用 `void`。

[i[Functions]>]
```