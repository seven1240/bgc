```c
int frotz(int a)
{
    int b;

    b = 10; /* in scope (from the local definition) */
    a = 20; /* in scope (from the parameter list) */
    c = 30; /* ERROR, out of scope (declared in another block, in main()) */
}

int main(void)
{
    int c;

    c = 20; /* in scope */
    b = 30; /* ERROR, out of scope (declared above in frotz()) */
}
```

所以你可以看到必须在本地声明变量才能使其处于作用域范围内。还请注意参数`a`也在函数`frotz()`中处于作用域内
```

看看_local variables_到底是什么意思？这些变量只存在于代码的一个基本块中，并且只有在这个基本块中才能看到（也就是被大括号包围的代码），在其中的基本块中也是如此。例如：

``` {.c}
int main(void)
{  /* 基本块的开始 */
    int a = 5; /* 局部于 main() */

    if (a != 0) {
        int b = 10; /* 局部于 if 的基本块 */
        
        a = b; /* 完全合法--这里的 a 和 b 都是可见的 */
    }

    b = 12; /* 错误 -- b 在这里不可见--只在 if 里才可见 */

    { /* 注意我开始了一个没有语句的基本块--这是合法的 */
        int c = 12;
        int a; /* 等等！等等！main() 中不是已经有一个 "a" 了吗！ */

        /* 这个基本块中的 a 掩盖了 main() 中的 a */
        a = c; /* 这将使这个基本块中的 a 修改为 12 */
    }

    /* 但是 main() 中的 a 仍然是 10（因为我们在 if 里设置了它）： */
    printf("%d\n", a);
}
```

这个示例中有很多内容，但其基本上是对一个简单规则的阐述：在处理局部变量时，你只能在声明它们的基本块中使用，或者在其中的基本块中使用。看看示例中的“错误”行，以了解到底什么操作是不行的。

让我们稍微离题一下，考虑一下传递给函数的参数的特殊情况。这些参数在整个函数范围内都是可见的，你可以随心所欲地修改它们。它们对于函数来说就像局部变量一样，只是它们有你传入的数据的副本，显然是这样的。

``` {.c}
void foo(int a)
{
    int b;

    a = b; /* 完全合法 */
}
```


### 全局变量 {#globals}

在局部变量之外，还有其他类型的变量。比如说_全局变量_。听起来很了不起，是吧。尽管出于许多原因，它们并不是万灵药，但仍是语言中强大的一部分。谨慎地使用这种力量，因为如果滥用它，你可能会编写很难维护的代码。

全局变量在它所定义的整个文件中是可见的（或者是声明的---稍后会详细说明）。所以它就像一个局部变量，只不过你可以从任何地方使用它。我想，那么它实际上并不像局部变量。但下面是一个例子：

``` {.c}
#include <stdio.h>

/* 这是一个全局变量。我们知道它是全局的，因为它在“全局范围”中声明，而不是在某个基本块中 */
int g = 10;

void afunc(int x)
{
    g = x; /* 这将全局变量设为x的值 */
}

int main(void)
{
    g = 10; /* 全局变量g现在是10 */
    afunc(20); /* 但这个函数会将它设为20 */
    printf("%d\n", g); /* 因此这将打印“20” */
}
```

记得局部变量都是存放在栈上吗？而全局变量是存放在堆上的，又是另一块内存。二者永远不会相遇。你可以将堆视为在很多方面比栈更“永久”的地方。

（该死---C标准也没有提到堆。但像栈一样，所有C程序员都使用这种术语并知道你在谈论什么。）

现在，我提到了全局变量可能会很危险。为什么呢？想象一下一个大型项目中，有上百万个全局变量是由上百万个不同的程序员声明的。如果它们起相同的名字会怎样？如果你以为你在使用一个局部变量，但却忘记声明它，所以你实际上在使用全局变量呢？

```c
（Ooo. 这里有一个很重要的注记：如果你在局部变量中声明了一个与全局变量同名的变量，它会隐藏全局变量，而且在该作用域中的所有操作都会在局部变量上进行。）

还有什么问题可能会出现？有时使用全局变量会导致人们的代码结构不如其他方式那样清晰。在没有其他合理的方式传递数据之前，最好不要使用全局变量。

另一点需要考虑的是：将数据存储在全局范围内供所有人查看是否真的有意义？例如，如果你有一个游戏，在很多不同的地方使用"世界的温度"，那么它可能是一个很好的全局变量候选。为什么？因为传递数据会很麻烦，而且每个人都对它有相同的需求。

另一方面，"这个人的小指头的温度"可能对于宇宙其他部分并不那么有趣。最好将这些数据存储在更与这个人相关联的方式中，而不是全局存储。我们稍后会更多地讨论如何将数据与事物相关联（听起来挺模糊的，对吧？）。

## 存储类别 {#stclasses}

什么是存储类别？它是用来存储变量的类别。

不客气。

切勿将其与任何C++类混淆，因为它们完全不是一回事。

那么存储类别声明有什么作用呢？它告诉编译器数据应该存储在哪里，例如堆栈或堆中，或者数据存储已经在其他地方声明过。

"什么？"

让我们举几个例子，你就会明白了。

### 来点静态的！{ #static}
```

准备好了吗？这里有一个例子：我正坐在BART（旧金山湾区快速交通地铁）上，打字的同时在回家的路上。在我前面的座位上，有一对年轻情侣正在甜蜜地亲吻，让人完全分心。

...嗯，什么。不是例子！是的！好吧，这是：

``` {.c}
void print_plus_one(void)
{
    static int a=0; /* 静态存储类！ */

    printf("%d\n", a);

    a++;  /* 增加静态值 */
}

int main(void)
{
    print_plus_one(); /* 输出 "0" */
    print_plus_one(); /* 输出 "1" */
    print_plus_one(); /* 输出 "2" */
    print_plus_one(); /* 输出 "3" */
    print_plus_one(); /* 输出 "4" */
}
```

我们这里有什么？这是如何实现的？`print_plus_one()` 中的局部变量不是在堆栈上分配然后在函数返回后消失吗？它怎么可能记住上一次的值呢？

答案是：这用到了现代魔法——`static`关键字。这个指示（在类型前面给出）告诉编译器实际上将这些数据存储在某个固定的地方，而不是堆栈上！哦哦！这个值在定义时初始化一次，以后就不再初始化，所以对它的所有操作都是累加的。

另外，如果你将局部变量简单地定义为静态变量，除非另有说明，它将自动初始化为零。

你以后可能会看到更多这方面的用法，但这种情况很常见，你应该要了解一下。


### 其他存储类 {#otherstor}

有其他存储类，是的。默认是`auto`，但实际上从未在实际中看到过，因为这是默认设置。

```c
// 从另一个文件引用变量就要用 `extern` 关键字。这样编译器就知道这个变量的定义在其他文件里。这样一来，即使变量的定义在别的地方，你也可以从一个文件中引用一个全局变量。定义两次是不合法的，而且因为它是全局变量，最好能在不同的源文件中使用。

我知道，我知道。现在很难想象，但是程序最终会变得足够庞大，需要跨越多个文件。`:-)`

 

# 结构体和联合体 {#structs}

你已经花了相当长的时间处理变量了，到处都创建了一堆变量来做各种事情，对吧？通常你会把它们捆绑到同一个基本块中，然后就这样处理了。

但有时候，把它们放到一个 _结构体_ 中会更有意义。结构体可以让你把变量逻辑地（甚至不合逻辑地，如果你乐意的话）分组起来。然后你可以将整个组作为一个整体来引用。一个很方便的地方是如果你想向函数传递 13 亿参数，但又不想函数声明那么长。你只需要把所有变量放到一个结构体中，然后将该结构体传递给函数。 （实际上，人们通常传递一个指向结构体的指针，但这个我们以后再说。）

那么你怎么使用这些东西呢？首先，`struct` 本身是一种新类型。如果你创建了一个 `struct foo` 类型的变量，它的类型就是 "`struct foo`"，就像数字 12 的类型是 "`int`" 一样。这有点吓人，因为这可能是你第一次创建一个新类型，不太清楚它是如何工作的。
```

向混淆的情况中添加更多困惑，结果发现创建和使用新的 `struct` 类型有多种方式，几乎没有一种特别直观。我们将举一个声明新 `struct` 的一种方式的示例：

``` {.c}
#include <stdio.h>

/* 在这里我们声明类型以便以后使用: */
struct stuff {
    int val;
    float b;
};

/* 请注意，我们实际上还没有任何该类型的变量。 */

int main(void)
{
    /* 好的，现在让我们声明一个类型为 "struct stuff" 的变量"s" */
    struct stuff s;

    s.val = 3490;  /* 将值赋给一个结构体！ */
    s.b = 3.14159;

    printf("s 中的 val 字段是: %d\n", s.val);
}
```

编译器允许我们像示例中一样预先声明一个 `struct`。然后我们可以后续使用它，就像我们在 `main()` 中赋值一样。当我们说像`s.val = 3490` 这样的话时，我们使用一个特殊的操作符来访问 `val` 字段，被称为 _点操作符_(`.`)。

## 指向`struct`的指针 {#structpt}

现在让我们稍微谈谈如何将这些 `struct` 传递给其他函数和操作。之前我提到过，你可能会希望传递指向 `struct` 的指针，而不是 `struct` 本身。为什么呢？

难道不讨厌教授问你这样的问题吗，但你在听讲时太累了，根本不想去考虑吗？"告诉我，我们继续"，这是你心里在想的，对吧？

好吧！就这样吧！那么，请记住，当你将参数传递给函数时，我会在此清清嗓子，准备再次强调，_每个参数都会在调用函数时被复制到堆栈上！_ 因此，如果你有一个大小为 80,000 字节的巨大 `struct`，那么在传递它时会将其复制到堆栈上。这需要时间。

而不妨传递一个指向`struct`的指针？我明白你的意思——难道指针不也要在栈上进行一次复制吗？确实要，不过如今一个指针只有4或8个字节，所以对机器更轻松，速度也更快。

而且，还有一点极其巧妙的 _语法糖_ 可以帮助我们访问指向`struct`的指针。对于那些不了解的人来说，语法糖是编译器的一种功能，简化了代码，尽管还有其他方法来实现同样的功能。比如，我已经多次提到`+=`……它做什么？我有没有告诉过你？老实说，在所有的兴奋中，我自己也给忘了。下面是一个示例，展示它如何像另外两个运算符一样工作，但使用起来更方便。这就是语法糖：

``` {.c}
i = i + 12;  /* i加12 */
i += 12;     /* <-- 和"i = i + 12"完全一样 */
```

看到了吧？它不是必需的运算符，因为还有其他方法可以实现同样的功能，但是人们喜欢这种捷径。

但我们岔开话题了，伙计。我在谈论指向`struct`的指针，但这里我们谈论的是如何访问它们。下面是一个示例，其中我们有一个`struct`变量，以及一个指向该`struct`类型的指针变量，以及对两者的一些使用（这将使用上面的`struct stuff`）：

``` {.c}
#include <stdio.h>

/* 这里我们声明这种类型，以便稍后使用： */
struct antelope {
    int val;
    float something;
};

int main(void)
{
    struct antelope a;
    struct antelope *b; /* 这是一个指向struct antelope的指针 */

    b = &a; /* 让我们把b指向a，只是娱乐一下 */

    a.val = 3490; /* 正常的struct使用，正如我们已经见过的那样 */
```

```c
/* 由于b是一个指针，我们必须在使用前对其进行解引用: */
    
(*b).val = 3491;

/* 但是这看起来有点糟糕，所以让我们做完全相同的事情 */
/* 除了这一次我们将使用"箭头运算符"，这是一种语法糖: */

b->val = 3491; /* 完全等同于 (*b).val = 3491; */
}
```

所以在这里我们看到了一些事情。首先，我们有一种方式来对指向 `struct` 的指针进行解引用，然后使用点运算符 (`.`) 来访问它。这是一种经典的做事方式：我们有一个指针，所以我们对它进行解引用以访问它指向的变量，然后我们可以像访问那个变量一样对待它。

但是，语法糖来拯救了我们，我们可以使用箭头运算符 (`->`) 来代替点运算符！在代码中避免了看起来很丑，是不是？箭头运算符内置解引用，所以在有` struct` 的指针时，你不必在那时乱搞那个语法。所以规则是：如果你有一个 `struct`，使用点运算符；如果你有一个指向 `struct` 的_指针_，使用箭头运算符 (`->`)。

## 将`struct`指针传递给函数 {#ptsfunc}

这将是一个非常简短的关于将指向struct的指针传递给函数的章节。我是说，你已经知道如何将变量作为参数传递给函数，你也知道如何创建和使用指向`struct`的指针，所以这里真的没什么好说的。一个示例应该足够直接地展示它。("直接地" - 如果我见过的话确实是一个矛盾的词。)

Grrrr. 为什么我总是坐在公交车这边呢？我是说，我知道太阳从这边照射进来，而且明亮的光线让我几乎无法看清屏幕。你会觉得我现在应该学习了。所以_无论如何_...

``` {.c}
#include <stdio.h>

struct mutantfrog {
    int num_legs;
    int num_eyes;
};

void build_beejs_frog(struct mutantfrog *f)
{
    f->num_legs = 10;
    f->num_eyes = 1;
}

int main(void)
{
    struct mutantfrog rudolph;

    build_beejs_frog(&rudolph);  /* 传递一个指针给结构体 */

    printf("leg count: %d\n", rudolph.num_legs); /* 输出 "10" */
    printf("eye count: %d\n", rudolph.num_eyes); /* 输出 "1" */
}
```

另一个需要注意的地方是：如果我们传递`struct`而不是指向`struct`的指针，在函数`build_beejs_frog()`中更改值会发生什么呢？没错：值只会在本地副本中更改，而不会反映到`main()`中。简而言之，传递`struct`给函数时，指针才是更好的选择。

## 联合 {#unions}

现在我们已经在一定程度上了解了 `struct`，让我们来谈谈一个相关的实体，被称为 `union`。在语法上，`union` 与 `struct` 非常相似；拿上面的例子，把 `struct` 换成 `union` 就行了。不过你需要注意它们之间的重要区别。

这个重要的区别在于：`union` 对所有成员共享同一块内存空间。例如，考虑这个 `union`：

``` {.c}
union misc_stuff{
    int train_type;
    char *crab_name;
    float cups_of_coffee;
};
```

``` {.c}
// 如果你在`train_type`字段中存储了什么东西，它将会混淆`crab_name`字段和`cups_of_coffee`字段中的内容。这是因为这三个字段的数据都存储在内存中的同一个位置。

//`union`存在的原因是为了允许你在不同时使用字段时在`struct`-like构造中节省内存。一个更实际的例子可能是，如果你想要存储数据及其类型，你可以将类型存储为`int`(或一个[枚举](#enum)，稍后会讨论)，然后在其下使用`union`存储数据。

#include <stdio.h>

struct variable {
    // 0 = int, 1 = float, 2 = string
    int type;

    union data {
        int i;
        float f;
        char *s;
    } data;
};

void print_variable(struct variable *v)
{
    switch(v->type) {
    case 0: // int
        printf("%d\n", v->data.i);
        break;
    case 1: // float
        printf("%f\n", v->data.f);
        break;
    case 2: // string
        printf("%s\n", v->data.s);
        break;
    }
}

int main(void)
{
    struct variable v;

    v.type = 1;
    v.data.f = 0.8;

    print_variable(&v);
}
// 这里只是一个简短的提示，让你开始考虑如何将问题分解成基本块。你现在有很多不同的工具可供使用：循环、条件语句、`struct`，尤其是函数。回想一下，你是如何学习将项目分解成小块，并看看你会为什么使用这些独立工具。

# 数组 {#arrays}

在本节中，我们为您提供了各种各样的信息。_*砰*!_ 对不起---那个双关语已经过时了。
```

对啊，数组就是相关数据的线性集合。这玩意儿就是一块连续的内存区，里面装着一堆相同数据类型的东西。为啥要用数组呢？假如没有数组，看看下面这个示例：

``` {.c}
int age0;
int age1;
int age2;
int age3;
int age4;

age1 = 10;
printf("age 1 is %d\n", age1);
```

然后咱们用数组的魔力来改写一下同样的例子：

``` {.c}
int age[5];

age[1] = 10;
printf("age 1 is %d\n", age[1]);
```

哇哦！看着是不是清爽多了？用中括号（`[]`）来访问数组里的_元素_，里面填一个`int`变量或者，就像我们例子里做的那样，填一个常数。因为你可以用一个变量来_索引_数组，这就意味着你可以在循环等地方做些事情。下面给你个更好的例子：

``` {.c}
int i;
int age[5] = {10,20,25,8,2};

for(i = 0; i < 5; i++) {
    printf("age %d is %d\n", i, age[i]);
}
```

哇喔——这里有几个新点。首先，你可以看到在定义数组时我们一次性初始化了整个数组。这只能_在定义时_做。等到实际写代码了，就晚了，得一个个来初始化了。

另一点要注意的是，看看我们在`for`循环里面是怎么访问数组元素的：用的是`age[i]`。所以在这个`for`里，`i`从0跑到4，每个`age`会按顺序被打印出来，就像这样：

```shell
age 0 is 10
age 1 is 20
age 2 is 25
age 3 is 8
age 4 is 2
```

```c
为什么它从0到4而不是从1到5运行？好问题。最简单的答案是数组的索引号是以零为基础的，而不是以一为基础。我知道，这不是一个真正的答案...事实证明，大多数（如果不是全部）处理器在机器码中使用以零为基础的索引来进行内存访问，所以这非常契合。

您可以创建任何类型的数组，包括结构体和指针。

## 将数组传递给函数 {#array2fun}

将数组传递给函数非常简单，但会有一些奇怪的地方。最奇怪的部分是，当您通过将数组名称作为函数参数传递进去来传递“整个”数组时，实际上传递给您的是数组的第一个元素的指针。

现在，在函数内部，您仍然可以使用数组表示法（`[]`）访问数组。这里是一个示例：

``` {.c}
void init_array(int a[], int count)
{
    int i;

    /* 对于每个元素，将其设置为索引号乘以10： */

    for(i = 0; i < count; i++)
        a[i] = i * 10;
}

int main(void)
{
    int mydata[10];

    init_array(mydata, 10);  /* 请注意缺少 [] 符号 */
}
```

这里需要注意的一点是，在 `init_array()` 的声明中，我们不必指定数组的_维度_（即数组中有多少元素）。我们可以指定，但不是必须的。

此外，由于C语言中的数组没有内置的大小概念（即包含多少元素），我们必须友好协作，并将数组大小单独传递到函数中。我们稍后在`for`循环中使用它，以便知道要初始化多少元素。

嘿！我们在调用中没有使用地址运算符！这样会将数组复制到堆栈上吗？这不好吗？嗯，不是的。
```

当你有一个数组时，省略掉方括号会给你数组第一个元素的**指针**。（你可以使用取地址操作符，但实际上会得到一个不同类型的指针，所以可能不是你期望的那样。）事实上，传递给函数调用的是指向数组的指针，而不是整个数组在栈上被复制。

现在你应该意识到，你可以用数组来存储许多东西，并且在经常涉及数据集合的项目中这会对你很有帮助。比如，假设：

> 
我们有一个虚拟世界，里面有许多虚拟生物四处奔跑做虚拟事情。每个生物都有真实的X和Y坐标。总共有12个生物。在模拟的每一步中，生物将处理它们的行为算法并移动到新的位置。新位置应该被展示。

哎呀！是时候构建基础了！我们有什么？好，我们需要为这些生物有X和Y坐标。我们需要12个生物。我们需要一个不断处理每个生物行为的构造体。然后我们需要输出。

生物的坐标。有几种方法可以做到这一点。你可以有两个包含12个元素的数组，一个用来保存X坐标，一个用来保存Y坐标。（这被称为**平行数组**。）不过，让我们尝试想一种方式将这些数据捆绑在一起。我是说，它们都与同一个虚拟生物相关联，所以将它们逻辑相关会不会更好？如果有一种方法的话…等等！没错！一个`struct`!

``` {.c}

``` {.c}
struct creature guys[12];
```

所以还需要什么呢---我们需要执行这些生物的行为。要一遍又一遍地循环执行...是的，使用循环会很方便。但我们要循环多少次呢？我的意思是，规格并没有告诉我们，这是个很棒的问题。通常我们会循环直到某个退出条件为真（比如用户按下ESC键或类似情况），但由于规格作者没有说明，我们就让循环永远执行下去吧。

``` {.c}
for(;;) {  /* 无限循环 */
```

接下来呢？我们需要编写这些生物的行为并放入循环中，对吧？由于即将编写的代码很自成一体，我们可以将它放入一个函数中，并为每个生物调用该函数。但函数的具体实现就交给你了，亲爱的读者。`:-)`

``` {.c}
for(i = 0; i < 12; i++) {
            execute_behavior(&(guys[i]));
        }
```

你注意到我们在函数调用中使用了取地址运算符。在这种情况下，我们并没有传递整个数组；我们只是传递了数组中单个元素的指针。不一定总是需要这么做（你可以在调用中复制单个元素），但由于这是一个`struct`，我传递指针以保持内存开销较低。

最后要做的事情是输出信息。如何完成这一点应该在规格中说明，但没有。如果能够在高分辨率屏幕上展示小图标来显示生物的位置会很酷，不过这超出了我们当前所做的范围，因此我们将简单地编写一个输出生物信息的程序。

最后一个注意事项---在使用数据之前初始化数据总是一个好主意，对吧？所以我会写一个函数，在我们使用之前也初始化这些生物。如何初始化它们在规范中也没有定义，所以我会任意地把它们设置成一条对角线。

完成（除行为之外）的代码：

``` {.c}
#include <stdio.h>

struct creature {
    float x;
    float y;
};

void execute_behavior(struct creature *c)
{
    /* 现在什么都不做 */
    /* --如果你希望它们移动的话，你需要编码！*/
}

main(int main(void)
{
    int i;
    struct creature guys[12];

    /* 初始化它们--可以是自己的函数: */

    for(i = 0; i < 12; i++) {
        guys[i].x = (float)i; /* (float) 是一个“强制转换”--它改变了类型！ */
        guys[i].y = (float)i;
    }

    /* 主循环 */

    for(;;) {   /* 永远循环 */

        /* 让它们做自己的事情：*/

        for(i = 0; i < 12; i++) {
            execute_behavior(&(guy[i]));
        }

        /* 输出结果 */
        for(i = 0; i < 12; i++) {
            printf("creature %d: (%.2f, %.2f)\n", i, guys[i].x, guys[i].y);
        }
    }
}
```

在代码中我加入了一个“强制转换”：`(float)`。
看，`i` 是一个 `int`，但 `guys[i].x` 和 `guys[i].y` 的字段都是 `float`。
这个强制转换将紧跟其后的表达式，本例中为 "`i`"，转换为指定的类型。在赋值运算符 (`=`) 两边使用相同的类型总是个好主意。

另一个新东西是 `printf()` 格式字符串中的 "`%.2f`"。一个普通的 "`%f`" 表示打印一个 `float`，这正是我们传递的内容。额外的 "`.2`" 意味着使用两位小数打印它。你可以尝试去掉 "`.2`" 看看会发生什么。`:-)`

字符串在现代物理学中是一个理论构建，用于帮助解释宇宙本身的结构。

这和C语言的字符串**完全相同**一样，不过实际上又是**完全不同**的东西。

在C语言中，字符串是内存中一系列字节，通常包含一堆字符。C语言中的常量字符串被双引号括起来（`" "`）。你可能在诸如"Hello World"这样的编程**巨制**中见过字符串：

``` {.c}
#include <stdio.h>

int main(void)
{
    printf("Hello, World!\n");
}
```

你看见里面的字符串`"Hello, World!\n"`了吧？

那么这个字符串的类型是什么呢？事实上，常量字符串（即双引号中的字符串）的类型是`char*`。但是你也可以将字符串放入一个`char`数组中，如果你愿意的话。`char*` 指向字符串中的第一个字符。示例：

``` {.c}
char *s = "Hello!";

printf("%s\n", s);    /* 打印 "Hello!" */
printf("%c\n", *s);   /* 打印 'H' */
printf("%c\n", s[0]); /* 打印 'H' */
printf("%c\n", s[1]); /* 打印 'e' */
printf("%c\n", s[4]); /* 打印 'o' */
```

注意这里`printf()`的两个新的格式说明符：`%c` 用于打印单个字符，`%s` 用于打印字符串！这不是太激动人心吗！

看这里，我们以各种不同的方式访问这个字符串。我们打印整个字符串，也打印单个字符。

你还可以在定义期间初始化`char`数组，就像其他数组一样：

``` {.c}
char s[20] = "The aliens are coming!";
```

而且你也可以通过简单地赋值来随意更改数组元素：

``` {.c}
char s[20] = "Give me $10!";

printf("%s\n", s);  /* 打印 "Give me $10!" */

s[9] = '8';
printf("%s\n", s);  /* 打印 "Give me $80!" */
```

在这种情况下，注意我们在赋值语句的右侧放置了一个常量`char`。常量`char`使用单引号(`'`)。

还有一件事要记住的是，当你仅通过名称指定一个数组时，没有使用方括号，就像使用指向数组开头的指针一样。因此，你实际上可以进行这样的赋值：

``` {.c}
char a[20] = "Cats are better.";
char *p;

p = a;  /* p现在指向数组a中的第一个字符 */
```

还有一件事：在C中，字符串以NUL字符结束。也就是说，一个零。最恰当地写为`'\0'`。你可以通过将`'\0'`赋值给字符串中的第一个字节来将字符串截断为零长度。此外，所有标准字符串函数都假定字符串以NUL字符结束。

标准字符串函数，我说过了吗？是的，我说过了。

C提供了一整套函数，你可以用来修改字符串，将它们连接起来，拆分它们等等。查看参考部分，了解你可以使用的所有出色的字符串处理功能。作为地球公民，明智地运用这种终极力量是你的责任！（还得给我80美元。）

# 动态内存 {#dydydynamic}

读者，你今天早上看起来是不是活力十足呢？或者是晚上？我总是对这些事情失去追踪。

到目前为止，我们一直在讨论在程序运行开始时几乎已经设置好的内存。你在这里有一些常量字符串，预先声明长度的数组，以及提前声明的变量。但如果你有以下情况呢？

```c
// Translate the following comment
// Assignment: Implement a program that will read an arbitrary number of integers from the keyboard.

// 翻译以下注释
// 任务：实现一个程序，该程序将从键盘读取任意数量的整数。
```

```c
// 这个非常重要：`malloc()` 就是那个为你要内存时提供内存的家伙。它会为您返回一个指向指定字节数块内存的指针，如果出现某种错误（比如内存不足）则返回`NULL`。实际的返回类型是`void*`，因此可以转换为任何你想要的指针。

// 因为`malloc()`以字节为单位操作，而你通常处理其他数据类型（例如，“为我分配12个`int`”），所以人们经常使用`sizeof()`运算符来确定要分配多少字节，例如：

int *p;

p = malloc(sizeof(int) * 12); // 为我分配12个整数！

// 哦，那基本上就是如何使用`malloc()`的示例。可以使用指针算术或数组表示法引用结果；都可以，因为它是一个指针。但是你真的应该检查结果是否有错误：

int *p;

p = malloc(sizeof(float) * 3490); // 分配3490个浮点数！

if (p == NULL) {
    printf("天哪！我们可能已经没有足够的内存了！\n");
    exit(1);
}

// 更常见的做法是将它们写在一行：

if ((p = malloc(100)) == NULL) { // 分配100字节
    printf("哦呜！内存不足错误！\n");
    exit(1);
}

// 现在记住：你是在堆上分配内存，只有两种方法可以重新获取那块内存：1) 程序退出，或者 2) 调用`free()`来释放`malloc()`分配的块。如果你的程序运行很长时间，一直`malloc()`而没有在应该时`free()`，就会导致内存泄漏。这通常表现为：“嘿，鲍勃。我一周前启动了你的打印作业监控程序，现在它使用了13太字节的RAM。为什么呢？”
```

确保避免内存泄漏！在使用完毕后记得用`free()`释放那块内存！


## `free()` {#gfree}

说到如何释放你分配的内存，就要用上那个名字难以置信的`free()`函数了。

这个函数的参数是你用`malloc()`（或`calloc()`）获取的指针。它会释放与数据相关联的内存。在调用`free()`后千万不要再使用该内存。那样不好。

那么来看一个例子：

``` {.c}
int *p;

p = malloc(sizeof(int) * 37); // 37个整数！

free(p);  // 重新考虑，算了吧！
```

当然，在`malloc()`和`free()`之间，你可以为所欲为地做任何操作。


## `realloc()` {#grealloc}

`realloc()`是一个有趣的小函数，它接收你用`malloc()`（或`calloc()`）分配的一块内存，并改变内存块的大小。也许一开始你以为只需要100个整数，但现在需要200个。你可以使用`realloc()`来调整内存块的大小以符合需求。

这样做很好，不过`realloc()`可能需要将数据移到内存的另一个位置，如果它无法基于某种原因增加当前块的大小。毕竟，它也不是全能的。

这对你这个凡人意味着什么呢？简而言之，意味着你应该谨慎使用`realloc()`，因为它可能是一个耗费昂贵的操作。通常的做法是跟踪内存块中还有多少空间，当用尽时就增加另一个大块的空间。首先，你分配一个你猜测足够大的空间来存储所有你需要的数据，然后如果碰巧用尽了，你就重新分配一个带有下一个最佳猜测空间的块来存储未来需要的数据。什么样的猜测是好的取决于程序。这里有一个例子，根据需要分配更多的“桶”空间：

``` {.c}
#include <stdlib.h>

#define INITIAL_SIZE 10
#define BUCKET_SIZE 5

static int data_count; // 我们存储的整数数量
static int data_size;  // 我们*可以*在这个块中存储的整数数量
static int *data;      // 数据块本身

int main(void)
{
    void add_data(int new_data); // 函数原型
    int i;

    // 首先，初始化数据区域：
    data_count = 0;
    data_size = INITIAL_SIZE;
    data = malloc(data_size * sizeof(int)); // 分配初始区域

    // 现在添加大量数据
    for(i = 0; i < 23; i++) {
        add_data(i);
    }
}

void add_data(int new_data)
{
    // 如果data_count == data_size，表示该区域已满
    // 需要在添加新数据之前重新分配空间：

    if (data_count == data_size) {
        // 我们已经满了，所以加一个“桶”
        data_size += BUCKET_SIZE;
        data = realloc(data, data_size * sizeof(int));
    }

    // 现在存储数据
    *(data+data_count) = new_data;

    // ^^^ 上面这行也可以使用数组表示，就像这样：
    //  data[data_count] = new_data;

    data_count++;
}
```

在上面的代码中，你可以看到一个潜在昂贵的`realloc()`仅在存储了前10个`int`之后才执行，然后再在之后每个块中存储五个之后执行。这远比每次添加一个数字就执行`realloc()`要好。

（是的，在那个完全牵强的例子中，因为我知道我一开始就要添加23个数字，将`INITIAL_SIZE`设置为25或其他值更有意义，但这就违背了这个例子的全部意义，对吧？）

## `calloc()` {#gcalloc}

既然你已经读过关于`malloc()`的部分（你读了，对吧？），这部分就会很简单！耶！这里看看：`calloc()`就像`malloc()`一样，只是它1)会为您将内存清零，2)它接受两个参数而不是一个。

这两个参数分别是内存块中要有的元素数量和每个元素的大小。是的，这与我们在`malloc()`中做的一样，只是`calloc()`为您进行了乘法运算：

``` {.c}
// 这个：
p = malloc(10 * sizeof(int));

// 就像这个一样：
p = calloc(10, sizeof(int));
// (使用calloc()时，内存将被清零)
```

`calloc()`返回的指针可以像使用`malloc()`一样与`realloc()`和`free()`一起使用。

使用`calloc()`的缺点是清除内存需要时间，在大多数情况下，你并不需要清零，因为你会覆盖它。但如果你发现自己在`malloc()`一块内存然后立即将内存清零，你可以使用`calloc()`来一次完成这两个操作。

```c
/* 这段关于 `calloc()` 的内容要是能更激动点就好了，加一些情节、激情和暴力，就像任何一部好莱坞电影一样，但是...我们在讨论 C 编程。而 C 编程本身应该就已经很激动了。抱歉！ */

# 更多内容！{ #morestuff}

这部分是我们详细展开之前完成的一堆事情的地方，只不过更详细罢了。我们甚至加了一两个新东西进去。你可以按照自己希望的任何顺序阅读这些部分，以及你觉得有必要的顺序。

## 指针算术 {#ptarith}

指针算_术_？是的，你没听错：你可以对指针进行数学运算。然而，这究竟意味着什么？好好注意，因为人们经常使用_指针算术_来操作指针并在内存中移动。

你可以对指针进行加法和减法运算。如果你有一个指向 `char` 的指针，递增该指针将移动到内存中的下一个 `char`（往上一个字节）。如果你有一个指向 `int` 的指针，递增该指针将移动到内存中的下一个 `int`（这可能是四个字节，或者根据你的 CPU 架构有其他数字）。重要的是要知道，它移动的内存字节数取决于指针的类型，但这实际上已经为你处理好了。

``` {.c}
/* 这段代码输出： */
/*  50               */
/*  99               */
/*  3490             */

int main(void)
{
    int a[4] = { 50, 99, 3490, 0 };
    int *p;

    p = a;
    while(*p > 0) {
        printf("%i\n", *p);
        p++; /* 移动到内存中的下一个 int */
    }
}
```

``` {.c}
//我们做了什么！这是怎么打印数组中的值的？
//首先，我们把`p`指向数组的第一个元素。
//然后我们会循环直到`p`指向的值小于或等于零为止。在循环体内，我们打印`p`指向的值。最后，_这是复杂的地方_，我们会_increase指针_。这会导致指针移动到内存中的下一个`int`，这样我们就可以打印它。

//在这种情况下，我随意地决定（是的，这令人震惊的事实是：我只是胡乱编造这些内容）用零值标记数组的末尾，这样我就知道何时停止打印。这被称为_哨兵值_...也就是，让你知道某些数据何时结束的东西。如果这听起来很熟悉，那是因为你刚在字符串部分看到过。记住---字符串以零字符(`'\0'`)结束，字符串函数使用这个作为哨兵值来确定字符串的结束位置。

//许多时候，你会看到`for`循环用于处理指针相关的内容。例如，这里有一些复制字符串的代码：

char *source = "Copy me!";
char dest[20];  /* 我们将把该字符串复制到这里 */

char *sp;  /* 源指针 */
char *dp;  /* 目的地指针 */

for(sp = source, dp = dest; *sp != '\0'; sp++, dp++) {
    *dp = *sp;
}

printf("%s\n", dest); /* 打印 "Copy me!" */

//看起来很复杂！这里有一点新的是_逗号运算符_（`,`）。逗号运算符允许你将表达式粘在一起。表达式的总值是逗号后面的最右边的表达式，但是表达式的所有部分都会从左到右进行评估。

//让我们来拆解这个`for`循环并看看发生了什么。在初始化部分，我们将`sp`和`dp`指向源字符串和我们将要复制的目标区域。
```

```c
// 在循环体内，实际进行了拷贝操作。我们使用赋值运算符，将源指针指向的字符复制到目标指针指向的地址。这样，我们会逐个复制字符串中的字母。

// `for` 循环的中间部分是继续条件---在这里我们检查源指针是否指向我们知道存在于源字符串末尾的空字符。当然，起初它指向“Copy me!”字符串的 'C'，所以我们可以继续。

// 在 `for` 语句结束时，我们会递增 `sp` 和 `dp` 以移动到下一个要复制的字符。复制，复制，复制！

## `typedef` {#typedef}

这个并不难理解，但其中可能有一些奇怪的细节，你在实际编程中可能会遇到。基本上 `typedef` 允许你为某种类型起一个别名，这样你可以用那个名称引用它。

为什么要这样做？最常见的原因是另一个名称有点笨拙，你希望有一个更简洁的名称... 这种情况最常发生在你要使用 `struct` 结构体时。

``` {.c}
struct a_structure_with_a_large_name {
    int a;
    float b;
};

typedef struct a_structure_with_a_large_name NAMESTRUCT;

int main(void)
{
    /* 可以这样定义结构体变量： */
    struct a_structure_with_a_large_name one_variable;

    /* 或者，可以这样做： */
    NAMESTRUCT another_variable;
}
```
```

```c
// 上面的代码中，我们定义了一种名为`NAMESTRUCT`的类型，可以用来替代另一种类型`struct a_structure_with_a_large_name`。请注意，这现在是一个完整的类型；你可以在函数调用中使用它，或者在需要使用“正常”类型的任何地方使用它。（不要告诉用`typedef`定义的类型它们不正常 — 这是不礼貌的。）

// 你可能也想知道为什么新类型名称全是大写。在历史上，按照惯例，`typedef`定义的类型在C语言中通常使用全大写（这并非必须的）。在C++中，情况不同，人们更常使用混合大小写。鉴于这是一份C语言指南，我们将坚持采用旧的方式。

//（你可能经常看到的一种情况是，在`typedef`中的`struct`标记名之前有一个下划线。虽然从技术上讲是不合法的，但很多程序员喜欢为`struct`和新类型使用相同的名称，将下划线放在那里有助于视觉上区分这两个。但你不应这样做。）

// 你还可以为“匿名”`struct`进行`typedef`，就像这样

typedef struct {
    int a;
    float b;
} someData;

// 然后你就可以将变量定义为类型`someData`，非常令人兴奋。

## `enum` {#enum}

// 有时你想要使用一组数字来表示不同的事物，但程序员更容易通过名称来表示这些事物，而不是数字。你可以使用`enum`为整数数字创建符号名称，程序员以后可以在他们的代码中使用这些符号名称来代替`int`。

//（我应该指出，C语言在这里比C++更宽松，关于`int`和`enum`之间的互换。我们将在这里保持快乐和C风格。）

// 请注意，`enum`也是一种类型。你可以`typedef`它，可以将其传递给函数等，就像“正常”类型一样。
```

这里有一些枚举以及它们的用法。记住--- 这些基本上就像`int`一样，多多少少嘛。

``` {.c}
enum fishtypes {
    HALIBUT,
    TUBESNOUT,
    SEABASS,
    ROCKFISH
};

int main(void)
{
    enum fishtypes fish1 = SEABASS;
    enum fishtypes fish2;

    if (fish1 == SEABASS) {
        fish2 = TUBESNOUT;
    }
}
```

并没有什么复杂的--- 它们只是唯一数字的符号名称。基本上，这样其他程序员就更容易阅读和维护了。

现在，你可以用`printf()`中的`%d`来输出它们。但是，在大多数情况下，你并不需要知道实际的数字是多少；通常你只需要符号表示。

但是，我知道你是好奇宝宝，我也可以告诉你，`enum`默认从零开始递增。所以在上面的例子中，`HALIBUT`是0，`TUBESNOUT`是1，而`ROCKFISH`是3。

然而，如果你愿意，你可以重写其中任何一个或全部：

``` {.c}
enum frogtypes {
    THREELEGGED=3,
    FOUREYED,
    SIXHEADED=6
};
```

在上面的例子中，两个枚举被明确定义了。对于`FOUREYED`（未定义），它会从上一个定义的值递增一个，所以它的值是4。如果你感兴趣，你也可以有重复值，但是你为什么要这样做呢？

## 更多的`struct`声明 {#morestruct}

还记得许多月前，我提到过有很多方法可以声明`struct`，而且并不是所有方法都很有意义。我们已经看到了如何全局声明一个`struct`以供以后使用，以及在`typedef`情况下的声明，诸如此类：

``` {.c}
/* 单独声明： */

struct antelope {
    int legcount;
    float angryfactor;
};

/* 或者使用typedef： */
```

```markdown
typedef struct _goatcheese {
    char victim_name[40];
    float cheesecount;
} GOATCHEESE;
```

但是你也可以在`struct`声明后直接声明变量：

``` {.c}
struct breadtopping {
    enum toppingtype type; /* BUTTER, MARGARINE or MARMITE */
    float amount;
} mytopping;

/* 就像你后来声明的那样： */

struct breadtopping mytopping;
```

所以我们有点把变量定义粘在`struct`定义的尾部。挺狡猾的，但你会发现在那个所谓的“现实生活”中，这种情况偶尔发生。

而且，就在你以为自己掌握得很好的时候，实际上在许多情况下你可以省略`struct`的名称。例如：

``` {.c}
typedef struct { /* <--嘿！我们忘了加名字！ */
    char name[100];
    int num_movies;
} ACTOR_PRESIDENT;
```

最好是给所有的`struct`取个名字，即使你只使用了`typedef`起的名字而不用原本的名字，但你仍然会在这里那里见到这些裸露的`struct`s。

## 命令行参数 {#clargs}

其实我一直在欺骗你，我必须承认。我以为我可以瞒过你而不被发现，但你意识到有些地方不对劲... 为什么`main()`函数没有返回类型或参数列表呢？

嗯，在很久以前的某个时候，由于某种原因，眼见为实，!!!TODO 研究一下!!! 是完全可以的。直到今天仍然存在。欢迎这样做，事实上， 但这并不能揭示全部事实，是时候让你知道整个真相了！

欢迎来到现实世界：

``` {.c}
int main(int argc, char **argv)
```

```c
// 程序怎样读取这些参数并返回值呢？

// 让我们先从简单的部分开始：返回值。你可能已经注意到`main()`的原型返回一个`int`。
// 太好了！所以你要做的就是要么在`main()`中`return`那个值，要么，作为替代，
// 你可以调用函数`exit()`，并将退出值作为参数传入：

int main(void)
{
    int a = 12;

    if (a == 2) {
        exit(3); /* 就像（从main()）运行"return 3;"一样 */
    }

    return 2; /* 就像调用exit(2);一样 */
}
```

```c
// 这是返回状态。那这些参数呢？嗯，起初整个`argv`的定义看起来太吓人了。那么，换个方向看看这个`argc`呢？其实只是一个`int`类型，而且相当容易理解。它包含了命令行中的参数总数，_包括程序本身的名称_。例如:

```shell
$ makemoney fast alot         # <-- argc == 3
$ makemoney                   # <-- argc == 1
$ makemoney 1 2 3 4 5         # <-- argc == 6
```

（上面的美元符号是一个常见的Unix命令行提示符。还有那个井号 (`#`) 是Unix命令行的注释字符。我是个Unix迷，如果你遇到问题，可以去找那些友好的Stormtroopers。）

很好，很好。`argc`的处理也没那么复杂。接下来是重头戏：`argv`。你可能已经猜到，这里存储着参数本身。但那个`char**`类型怎么处理呢？幸运的是，你通常可以在解引用的地方使用数组符号，因为你应该记得数组和指针是相关的概念。在这种情况下，你可以将`argv`看作是一个指向字符串的指针数组，其中每个指向的字符串都是一个命令行参数：

```shell
$ makemoney   somewhere  somehow
$ # argv[0]    argv[1]   argv[2]   （而 argc 是 3）
```

每个数组元素 `argv[0]`，`argv[1]`，等等都是一个字符串。（记住，字符串就是一个`char`类型或`char`数组的指针，该指针指向数组的第一个元素。）
```

我还没有告诉过你关于字符串能做什么，但是请查看参考部分获取更多信息。现在你知道如何使用"`%s`"格式说明符来`printf()`字符串，也知道如何做循环。所以让我们编写一个程序，简单地打印出它的命令行参数，然后设置退出状态值为4：

``` {.c}
/* showargs.c */

#include <stdio.h>

int main(int argc, char **argv)
{
    int i;

    printf("命令行中有 %d 个参数\n", argc);
    printf("程序名为 \"%s\"\n", argv[0]);

    printf("参数有：\n");
    
    for(i = 1; i < argc; i++) {
        printf("    %s\n", argv[i]);
    }

    return 4; /* 退出状态为4 */
}
```

请注意，我们从索引1开始打印参数，因为在这之前我们已经打印过 `argv[0]`。因此，示例运行和输出（假设我们将其编译为名为`showargs`的程序）：

```shell
$ showargs alpha bravo
命令行中有 3 个参数
程序名为 "showargs"
参数有：
    alpha
    bravo

$ showargs
命令行中有 1 个参数
程序名为 "showargs"
参数有：

$ showargs 12
命令行中有 2 个参数
程序名为 "showargs"
参数有：
    12
```

（`argv[0]`中实际的内容可能因系统而异。有时会包含一些路径信息或其他内容。）

这就是从命令行将内容传递给你的程序的秘诀！

``` {.c}
#include <stdio.h>

int main(void)
{
    int a[2][5] = { { 10, 20, 30, 40, 55 },  /* [2][5] == [rows][cols] */
                    { 10, 18, 21, 30, 44 } };

    int i, j;

    for(i = 0; i < 2; i++) {     /* 遍历所有行... */
        for(j = 0; j < 5; j++) { /* 打印所有列！ */
            printf("%d ", a[i][j]);
        }

        /* 每行结束时，为下一行打印换行符 */
        printf("\n"); 
    }
}
```

看看这是怎么运作的？编译器只是按顺序放置一行接着一行，依此类推。

不过嘿！这不就像是一维数组一样吗？是的，从技术上讲，基本上就是！很多程序员根本就不烦恼使用多维数组，而是只使用单一维度，在手动计算找到特定行和列。你不能随心所欲地在不同维度之间切换，布卡鲁邦萨伊，因为类型是不同的。而且这样做风格也不好。

举个例子...算了，不提“举个例子”了。让我们再次使用单一维度数组做同样的例子：

``` {.c}
#include <stdio.h>

int main(void)
{
    int a[10] = {   10, 20, 30, 40, 55,  /* 10 elements (2x5) */
                    10, 18, 21, 30, 44 };

    int i, j;

    for(i = 0; i < 2; i++) {     /* 对所有的行... */
        for(j = 0; j < 5; j++) { /* 打印所有的列！ */
            int index = i*5 + j; /* 计算索引 */
            printf("%d ", a[index]);
        }

        /* 在行末尾，为下一行打印一个换行符 */
        printf("\n"); 
    }
}
```

因此，在循环的中间我们声明了一个局部变量`index`（是的，你可以这样做---记住局部变量是局部于它们所在的块的（也就是局部于它们周围的花括号）），我们使用`i`和`j`来计算它。仔细看看这个计算，确保它是正确的。这从技术角度来看就是当你使用多维数组的符号访问该数组时，编译器在你的背后所做的操作。

## 类型转换和提升 {#cast}

有时候你有一个类型，而你希望它成为另一种类型。下面是一个很好的例子：

``` {.c}
int main(void)
{
    int a = 5;
    int b = 10;
    float f;

```c
f = a / b;  /* 计算5除以10 */
printf("%.2f\n", f);
}
```

这会打印出：

``` {.c}
0
```

...什么？5除以10等于零？从什么时候开始的？我告诉你：从我们进入只进行整数除法的世界开始。当你把一个`int`除以另一个`int`时，结果也是一个`int`，任何小数部分都会被丢弃。如果我们想要结果变成`float`怎么办，以便结果正确呢？

事实证明，除法中的一个整数（或两个）可以被转换成`float`，然后除法的结果也会是`float`。所以只需要改变一个即可，一切都应该能正常工作。

"继续吧！如何进行类型转换？" 哦，是的---我想我应该真的去做。你可能会从本指南的其他部分想起类型转换，但为了确保，我们将再次展示它：

``` {.c}
f = (float)a / b;  /* 计算5除以10 */
```

噼里啪啦！就是这样！在要转换的表达式前面的括号中放入新类型，它就神奇地变成了那种类型！

你几乎可以将任何东西强制转换为几乎任何其他东西，如果出现了问题，那完全是你的错，因为编译器会盲目地执行你要求的任何操作。`:-)`


## 不完整类型 {#incomplete}

这个主题有点复杂，但请耐心看下去。不完整类型只是特定`struct`名称的声明，可以让你使用对`struct`的指针，而无需实际知道其中存储的字段。当人们不想`#include`另一个头文件时，它经常出现，这可能是因为各种不同的原因。

例如，在这里，我们使用了指向一种类型的指针，而实际上在`main()`中并没有定义它。（但在其他地方有定义。）

``` {.c}
struct foo;  /* 不完整的类型！注意它是不完整的噢。 */

int main(void)
{
    struct foo *w;

    w = get_next_wombat(); /* 抓一只袋獾 */
    process_wombat(w);     /* 在某处使用它 */
}
```

我告诉你这个是因为你可能会发现自己试图包含一个包含另一个头文件的头文件，或者你的构建花了很长时间因为你包含了太多头文件，或者...更有可能的是你会看到类似"无法引用不完整类型"的错误。这个错误意味着你尝试对不完整类型做太多事情（比如你试图对其进行解引用或使用其中的字段），你需要`#include`具有完整声明`struct`的正确头文件。


## `void` 指针 {#voidp}

欢迎来到 _VOID_！就像尼奥·安德森会说的那样，"……哇。" 这个 `void` 是什么东西？

停下！在你困惑之前，`void` 指针不是函数的 `void` 返回值或者 `void` 参数列表。我知道这可能让人困惑，但事实就是如此。等我们讨论所有使用 `static` 关键字的方式之前，先忍耐下。

`void` 指针是一个_指向任意类型的指针_。它会被自动转换为你分配或从中复制的任何类型。为什么你会想要使用这样的东西？我是说，如果你要解引用一个指针以便访问原始值，编译器不需要知道指针是什么类型吗，这样它才能正确使用？

是的。没错。正因如此，你不能解引用一个 `void` 指针。这是不允许的，C警察会比你说杰克·罗宾森还快来敲你的门。在使用之前，你必须将其转换为另一种指针类型。

``` {.c}
#include <stdio.h>

void *pointer_array[10]; /* 我们可以容纳多达 10 个空指针 */
int index=0;

void append_pointer(void *p)
{
    pointer_array[index++] = p;
}

void *get_pointer(int i)
{
    return pointer_array[i];
}
```

检查一下`append_pointer()`函数的代码。那么，这一切是怎么挤在一行里的呢？我们在追加时需要做两件事：存储当前索引处的数据，并将索引移动到下一个可用位置。我们通过赋值操作符复制数据，然后注意到我们使用了_post-increment_操作符(`++`)来增加索引。记得_post_增量是什么意思吗？这意味着递增发生在对表达式的剩余部分进行评估之后，包括该赋值。

另一个函数`get_pointer`，简单地返回指定索引`i`处的`void*`。在这里要注意的是两个函数返回类型之间的细微差异。其中一个声明为`void`，表示不返回任何内容，另一个声明了返回类型为`void*`，这表示返回一个`void`指针。我知道，我知道，重复使用有点麻烦，但你会很快适应的。不然！

最后，我们已经写好了那段代码---那么我们到底如何使用它呢？让我们编写一个`main()`函数来使用这些函数：

``` {.c}
int main(void)
{
    char *s = "some data!";  /* s 指向一个常量字符串 (char*) */
    int a = 10;
    int *b;

    char *s2;  /* 当我们调用 get_pointer() 时，我们将把它们存储在这里 */
    int *b2;

    b = &a; /* b 是指向 a 的指针 */

    /* 现在让我们存储它们，尽管它们是不同类型的 */
    append_pointer(s);
    append_pointer(b);

    /* 它们已经被存储了！让我们取回它们！ */
    s2 = get_pointer(0); /* 这是在索引 0 处的 */
    b2 = get_pointer(1); /* 这是在索引 1 处的 */
}
```

查看指针类型如何通过`void*`互换？ C 允许你毫不留情地将`void*`转换为任何其他指针，而且确保将它们恢复到原始类型取决于你自己。是的，你在这里可能犯错导致程序崩溃，你最好相信这一点。
就像他们说的那样，“C给了你足够的绳子让你自己绞死自己。”

## `NULL`指针 {#nullp}

我想在飞机降落之前刚好有点时间来谈谈指针中的`NULL`。

`NULL`简单地意味着一个指向空的指针。有时候知道指针是否有效，或者是否需要初始化等是很有用的。`NULL`可以用作各种不同事物的哨兵值。记住：它代表“这个指针指向空”！例如：

``` {.c}
int main(void)
{
    int *p = NULL;

    if (p == NULL) {
        printf("p 未初始化！\n");
    } else {
        printf("p 指向 %d\n", *p);
    }
}
```

注意指针在声明时不会被预先初始化为`NULL` --- 你必须明确做到这一点。（没有预初始化的本地非静态变量，包括指针。）

## 更多静态 {#static2}

现代技术让我安全降落在 LAX，我可以自由地在等待飞往爱尔兰的飞机时继续写作。告诉我你至少在某种程度上不嫉妒，我是绝对不会相信的。

但不用再谈论我了；让我们谈谈编程吧。（这是什么样的极客搭讪？如果你用它，请不要提到我的名字。）

```c
/*
您已经看到了如何使用 `static` 关键字来使局部变量在函数调用之间保持持久性。但是，`static` 还有其他令人振奋的完全无关的用途，可能值得拥有自己的关键字，但却没有。您只需习惯于 `static`（以及 C 中许多其他内容）根据上下文具有不同含义这个事实。

如果您在全局范围中将某些内容声明为 `static` 会怎样呢，而不是局部函数中呢？毕竟，全局变量已经持续存在于程序的整个生命周期，所以在这里 `static` 不能意味着相同的事情。相反，在全局范围中，`static` 意味着声明为 `static` 的变量或函数“仅在此特定源文件中可见”，并且不能从其他源文件引用。再次强调，这种对 `static` 的定义仅适用于全局范围。在函数的局部范围中，`static` 仍然表示同样的含义。

您会发现，您的大型项目本身可以将自己拆解成更大的部分（就像那幅图中较小的鱼被较大的鱼吃掉，而后者又被更大的鱼吃掉一样）。当您有足够相关的较小部分时，通常将它们放在自己的源文件中是合理的。

我将从关于 [`void` 指针](#voidp) 部分提取示例，在那里我们有一对可以用于存储任何类型指针的函数。
*/
```

这个示例程序中的一个问题（它存在各种缺陷和错误）是我们声明了一个全局变量叫做`index`。现在，"index"是一个非常常见的词，很有可能在项目的其他地方，有人会自己定义一个同名的变量。这可能会引发各种问题，其中最重要的一点是他们可以修改你的`index`数值，这对你来说非常重要。

一个解决方案是将所有东西放在一个源文件中，然后将`index`声明为`static`全局变量。这样，外部文件就不允许使用它了。你是国王！`static` 是一种方式，可以将代码部分的实现细节挡在他人看不到。相信我，如果让其他人来干涉你的代码，他们一定会尽情地搞破坏！砸大锤砸哈皮！

所以，这里是对代码进行快速重写，并将其放入自己的文件中：

``` {.c}
/** 文件 parray.c **/

static void *pointer_array[10]; /* 现在除了这个文件外，没有人能看到它！ */
static int index=0; /* 对于这个变量也是如此！ */

/* 但是这些函数不是static的 */
/* 所以它们可以被其他文件使用: */

void append_pointer(void *p)
{
    pointer_array[index++] = p;
}

void *get_pointer(int i)
{
    return pointer_array[i];
}

/** 文件 parray.c 结束 **/
```

接下来应该做的是创建一个名为`parray.h`的文件，在其中包含这两个函数的函数原型。然后主文件中有`main()`的地方可以`#include` `parray.h`并在链接时使用这些函数。

喜欢我常说的一句话，项目通常会变得太大，以至于一个文件容纳不下，就像《泥沼怪物》变得庞大并最终被史蒂夫·麦奎因打败一样。不幸的是，麦奎因已经成功逃至天堂，无法帮助你处理代码了。抱歉。

因此，当你拆分项目时，应该尝试将其拆分为合理大小的模块，这些模块可以作为独立文件存在。例如，负责计算快速傅立叶变换（一种数学构造，对于不熟悉的人来说）的所有代码可能适合放在自己的源文件中。又或者，为游戏控制特定人工智能机器人的所有代码可能放在自己的文件中。这更像是一种指南而非规则，但是如果某些内容与特定源文件中的内容没有相关性，也许应该放到其他地方去。在这种情况下的一个完美示例性问题可能是：“为什么 3D 渲染代码混在声音驱动代码中间？”

当你将代码移到自己的源文件中时，几乎总会需要编写一个相应的头文件。新源文件中的代码（将是一堆函数）需要有函数原型和其他内容对其他文件可见，以便可以使用它们。其他源文件使用其他文件的方法是通过`#include`它们的头文件。

例如，让我们编写一组小函数放在一个名为`simplemath.c`的文件中：

``` {.c}
/** 文件 simplemath.c **/

int plusone(int a)
{
    return a+1;
}

int minusone(int a)
{
    return a-1;
}

/** 文件 simplemath.c 结束 **/
```

一对简单的函数，就这些。没有太复杂，对吧？但是单独来看，它们用处不大，想让别人使用它们，我们需要在头文件中分发它们的原型。准备好接受这个…你应该能在其中识别出原型，但我加入了一些新东西：

``` {.c}
/** file simplemath.h **/

#ifndef _SIMPLEMATH_H_
#define _SIMPLEMATH_H_

/* 这里是原型： */

int plusone(int a);
int minusone(int a);

#endif

/** end of file simplemath.h **/
```

恶心。这些`#ifndef`是什么鬼？还有`#define`以及`#endif`？这是_样板代码_ （也就是，通常被固定放在文件中的代码），用于防止头文件被多次包含。

逻辑的简短版本是：如果符号`_SIMPLEMATH_H_`未被定义，则定义它，然后做所有常规的头部工作。如果符号`_SIMPLEMATH_H_`已经被定义，则什么也不做。这样一来，头文件的大部分内容仅在构建过程中被包含一次，无论有多少其他文件试图包含它。这是个好主意，因为重新包含它最多只是多余的浪费时间，最坏的情况下，可能会导致编译时错误。

好了，我们有了头文件和源文件，现在是时候编写一个带有`main()`的文件了，这样我们就可以真正使用这些东西：

``` {.c}
/** file main.c **/

#include "simplemath.h"

int main(void)
{
    int a = 10, b;

    b = plusone(a);  /* 让处理器运转起来！ */
}

/** end of file main.c **/
```

```c
检查一下！我们在`#include`中使用双引号而不是尖括号！这告诉预处理器的行为是，“从当前目录中包含此文件，而不是从标准系统目录中包含。”我猜想你是把所有这些文件都放在同一个地方供本练习使用。

记住，包含一个文件就像把它直接带入你的源代码一样，在那一点上，因此，我们在源代码中直接带入原型，然后这些函数就可以在`main()`中自由使用了。耶！

最后一个问题！我们如何实际构建这整个东西？从命令行：

```shell
$ cc -o main main.c simplemath.c
```

你可以把所有源文件放在命令行上，它会将它们一起构建，又简单又方便。

## 全能的C预处理器 {#cpp}

还记得大约一百万年前当你开始阅读本指南时我提到过菠菜的事情吗？没错---你记得菠菜怎么跟整个计算过程有关联吗？

当然记不得。我刚刚编出来的；我从来没有在本指南中提到过菠菜。我是说，得了吧。菠菜跟什么有关系呢？天啊！

让我为你引导到一个不那么花哨的话题：C预处理器。顾名思义，这个小程序会在C编译器查看源码之前处理它。这会让你对编译的内容以及编译方式有更多控制。

你已经见过最常见的一个预处理指令:`#include`。本指南的其他部分也提到了各种其他指令，但我们将在这里将它们全部列出来，供娱乐。

### `#include` {#cppinclude}

大家耳熟能详的`#include`指令会引入另一个文件中的源代码。在几乎每种情况下，这另一个文件应该是头文件。
```

在每个系统上，有许多标准包含文件可供您用于各种任务。最常见的是你见过的 `stdio.h` 被使用。系统是如何知道在哪里找到它的呢？每个编译器都有一组目录，当您用尖括号指定文件名时，它会在这些目录中查找头文件。（在Unix系统中，它通常会搜索 `/usr/include` 目录。）

如果您想包含源目录中的文件，请在文件名周围使用双引号。以下是一些示例：

``` {.c}
/* 从系统包含目录包含： */

#include <stdio.h>
#include <sys/types.h>

/* 从本地目录包含： */

#include "mutants.h"
#include "fishies/halibut.h"
```

从示例中可以看出，还可以指定一个 _相对路径_ 到主目录之外的子目录。（在Unix下，再次说明，在目录 `/usr/include/sys` 中有一个名为 `types.h` 的文件。）

### `#define` {#cppdefine}

`#define` 是C语言预处理指令中功能更强大的之一。使用它，您可以声明要在编译器在处理源代码之前替换的常量。假设您的程序中散布着许多常量，而且每个数字都是_硬编码_的（也就是说，这个数字在代码中是明确写出的，比如 "2"）。

现在，当您编写它时，您以为它是一个常量，因为给您规格说明的人向您发誓，如果数字是 "2"，他们愿意被折磨也不会有任何变化，这辈子一亿年都不会变，所以他们宁可失明。

听起来不错。如果发生变化，您甚至还有人可以推卸责任，而且它可能根本不会改变，因为他们似乎如此确定。

_不要做傻事。_

规格会发生变化，而且就在你在源代码中大概三十万处放入数字“2”之后，他们会说，“你懂的，2 这个数字就不够用了---我们需要3。这个改动难吗？”

无论责怪与否，你就是得做出这个改变的人。优秀的程序员会意识到像这样硬编码数字并不是一个好主意，避免这种情况的一种方法就是使用`#define`指令。看看下面的例子：

``` {.c}
#define PI 3.14159265358979  /* 比你想象中的π更多 */

int main(void)
{
    float r =10.0;

    printf("pi: %f\n", PI);
    printf("pi/2: %f\n", PI/2);
    printf("area: %f\n", PI*r*r);
    printf("circumference: %f\n", 2*PI*r);
}
```

（通常`#define`都是全大写字母，根据约定。）所以，嘿，我们刚刚打印出来的东西就好像是一个浮点数一样。嗯，它确实就是一个浮点数。记住---C预处理器在编译器看到之前就会替换`PI`的值。就好像你亲自在那里输入一样。

现在假设你在各处都使用了`PI`，而此刻你准备好发布了，设计师却来找你说，“那个π的事情，嗯，我们觉得需要改成4而不是之前的3.14什么的。这个改变难吗？”

在这种情况下没问题，无论改动请求多么怪异。你只需要在顶部改变一个`#define`，当C预处理器遍历代码时，它会自动在所有地方进行相应的更改：

``` {.c}
#define PI 4.0  /* 随你说了算 */
```

挺酷的，是吧。嗯，也许并不像“酷”一样好，
但你还没有见识到这个完全操作的预处理指令的破坏力呢！你实际上可以使用 `#define` 来编写一些小小的 _宏定义_，
就像一些微型函数，它们会在 C 编译器查看代码之前被预处理器评估。要创建这样一个宏定义，你需要给定一个参数列表（不需要类型，因为预处理器对类型一无所知），然后列出如何使用它。例如，如果我们想要一个宏定义，用于计算一个数字乘以3490，我们可以这样做：

``` {.c}
#define TIMES3490(x) ((x)*3490)    /* 注意没有分号！*/

void evaluate_fruit(void)
{
    printf("40 * 3490 = %d\n", TIMES3490(40));
}
```

在这个例子中，预处理器将会 _展开_ 宏定义，以便编译器看到如下的代码：

``` {.c}
void evaluate_fruit(void)
{
    printf("40 * 3490 = %d\n", ((40)*3490));
}
```

（实际上，预处理器可以进行基本的数学运算，所以它可能会直接简化为“139600”。但这是我的例子，我愿意这样做！）

现在问你一个问题：你是在盲目相信你在宏定义中需要所有那些括号，就像某种LISP超级英雄，还是在想，“为什么我要浪费宝贵的生命时光输入这么多括号呢？”

嗯，你 _应该_ 好奇！事实上，有些情况下，你可能没有意识到使用宏定义时可能生成一些非常 _糟糕_ 的代码。看看下面这个示例，它编译时没有问题：

``` {.c}
#define TIMES3490(x) x*3490

void walrus_discovery_unit(void)
{
    int tuskcount = 7;

    printf("(tuskcount+2) * 3490 = %d\n", TIMES3490(tuskcount + 2));
}
```

这里有什么问题？我们在计算 `tuskcount+2`，然后通过 `TIMES3490()` 宏来处理。但是看看宏展开后的结果：

``` {.c}
printf("(tuskcount+2) * 3490 = %d\n", tuskcount+2*3490);
```

我们不是在计算 `(tuskcount+2)*3490`，而是计算了 `tuskcount+(2*3490)`，因为乘法在运算顺序中排在加法之前！看，给宏加上额外的括号可以防止这种情况发生。所以，有良好编程习惯的程序员会自动在宏的参数变量每次使用时加上一对括号，同时也在宏自身外面加上一对括号。

### `#if` 和 {#macif}
`#ifdef`

C预处理器有一些 _条件判断_ 可以用来丢弃代码块，以便编译器不会看到它们。`#if` 指令类似于C的 `if`，你可以传递一个要评估的表达式。它最常用于封闭大段代码块，就像注释一样，当你不希望它被构建时：

``` {.c}
void set_hamster_speed(int warpfactor)
{
#if 0
    哦这段代码还没写。应该有人真的写一下。
#endif
}
```

在C中不能嵌套注释，但是你可以随意嵌套 `#if` 指令，因此它对此非常有用。

另一个if语句，`#ifdef`，是当后续宏已经定义时为真。有一个这个指令的负面版本叫做 `#ifndef`（"如果未定义"）。`#ifndef` 通常与头文件一起使用，以防止它们被多次包含：

``` {.c}
/** file aardvark.h **/

#ifndef _AARDVARK_H_
#define _AARDVARK_H_

int get_nose_length(void);
void set_nose_length(int len);

#endif

/** end of file aardvark.h **/
```

第一次包含此文件时，`_AARDVARK_H_`尚未定义，因此会转到下一行，然后定义它，接着进行一些函数原型声明，最后你会看到整个`#if`类型的指令以`#endif`语句结束。现在，如果再次包含文件（当你有很多包含其他头文件的头文件时，会发生这种情况_ad infinininini---_cough!），宏`_AARDVARK_H_`将已经被定义，因此`#ifndef`将失败，并且直到`#endif`的文件将被预处理器丢弃。

在这里非常有用的另一件事是针对某个平台编译特定代码，让其他代码针对不同的平台进行编译。许多人喜欢在构建软件时为其所在平台定义一个宏，例如`LINUX`或`WIN32`。你可以巧妙地利用这一点，以便你的代码能在不同类型的系统上编译和运行：

``` {.c}
void run_command_shell(void)
{
#ifdef WIN32
    system("COMMAND.EXE");
#elifdef LINUX
    system("/bin/bash");
#else
#error We don't have no steenkin shells!
#endif
}
```

还有几个新的地方，最显著的是`#elifdef`。这是“else ifdef”的缩写，在这种情况下必须使用。如果你使用`#if`，那么你会使用相应的`#elif`。

此外，在那里还加入了`#error`指令。这将导致预处理器立即中断，并显示给定的消息。


## 指针到指针 {#pt2pt}

你已经看到了如何设置变量的指针... 也看到了指针本身是一个变量，那么是否可能有一个 _指向指针的指针_？

不，不可能。

开玩笑的，当然是可能的。如果不可能，我会在此指南中包含这一部分吗？

有几个很好的理由我们会想要使用指向指针的指针，我们先给你一个简单的原因：你想要将一个指针作为参数传递给一个函数，让函数修改它，并将结果反馈给调用者。

请注意，这正是我们在函数调用中使用指针的原因：我们希望函数能够修改指针所指向的内容。不过，在这种情况下，我们想要修改的内容是另一个指针。例如：

``` {.c}
void get_string(int a, char **s)
{
    switch(a) {
        case 0:
            *s = "everybody";
            break;

        case 1:
            *s = "was";
            break;

        case 2:
            *s = "kung-foo fighting";
            break;

        default:
            *s = "errrrrrnt!";
    }
}

int main(void)
{
    char *s;

    get_string(2, &s);

    printf("s is \"%s\"\n", s);  /* 's is "kung-foo fighting"' */
}
```

上面的代码片段将通过指向指针的指针将一个字符串（指向`char`的指针）传递回给调用者。请注意，我们在`main()`函数中将指针`s`的_地址_传递给了函数`get_string()`。这样函数`get_string()`就得到了指向`s`的指针，进而可以对该指针进行解引用，改变它所指向的内容，也就是`s`本身。

这里实际上并没有什么神秘的地方。你有一个指向某个内容的指针，因此你可以对指针进行解引用来改变内容。就像以前一样，只不过现在我们操作的是一个指针，而不只是一个普通的基本类型。

用指向指针的指针还能干啥？你可以动态地构建类似二维数组的结构。下面的例子假设你已经明白函数`malloc()`调用返回一块连续的内存字节，你可以随意使用。在这种情况下，我们将使用它们来创建若干个`char*`。而且我们将拥有一个指向它们的指针，因此它的类型是`char**`。

``` {.c}
int main(void)
{
    char **p;

    p = malloc(sizeof(char*) * 10);  // 分配 10 个 char* 的空间
}
```

好的。那么这些我们可以做什么呢？好吧，它们还没有指向任何东西，但我们可以为每一个调用`malloc()`，然后就可以拥有一个大块内存，我们可以在其中存储字符串。

``` {.c}
int main(void)
{
    char **p;
    int i;

    p = malloc(sizeof(char*) * 10);  // 分配 10 个 char* 大小的字节空间

    for(i = 0; i < 10; i++) {
        *(p+i) = malloc(30); // 每个指针分配 30 个字节

        // 或者我们可以这样写：
        //   p[i] = malloc(30);
        // 不过我们没有。

        sprintf(*(p+i), "this is string #%d", i);
    }

    for(i = 0; i < 10; i++) {
        printf("%d: %s\n", i, p[i]); // p[i] 和 *(p+i) 等价
    }
}
```

好了，正如你可能在想的那样，这是完全疯狂的时候。让我们看看第二个`malloc()`语句，一次解析每一部分。

你知道`p`是指向`char`的指针的指针，换句话说，它是指向`char*`的指针。记住这一点。

```c
// And we know this `char*` is the first of a solid block of
// 10, because we just `malloc()`'d that many before the for
// loop. With that knowledge, we know that we can use some pointer
// arithmetic to hop from one to the next. We do this by adding the
// value of `i` onto the `char**` so that when we
// dereference it, we are pointing at the next `char*` in the
// block. In the first iteration of the loop `i` is zero, so
// we're just referring to the first `char*`.

// And what do we do with that `char*` once we have it? We
// point it at the return value of `malloc()` which will point
// it at a fresh ready-to-use 30 bytes of memory.

// And what do we use that memory for (sheesh, this could go on
// forever!)--well, we use a variant of `printf()` called
// `sprintf()` that writes the result into a string instead of
// to the console.

// And there you have it. Finally, for fun, we print out the results
// using array notation to access the strings instead of pointer
// arithmetic.

// Pointers to Functions

// You've completely mastered all that pointer stuff, right? I mean,
// you are the _Pointer Master_! No, really, I insist!

// So, with that in mind, we're going to take the whole pointer and
// address idea to the next phase and learn a little bit about the machine
// code that the compiler produces. I know this seems like it has nothing
// to do with this section, Pointers to Functions, but it's background that
// will only make you stronger. (Provided, that is, it doesn't kill you
// first. Admittedly, the chances of death from trying to understand this
// section are slim, but you might want to read it in a padded room just as
// a precautionary measure.)
```

```c
// Please translate this part
// Long ago I mentioned that the compiler takes your C source code and
// produces _machine code_ that the processor can execute. These
// machine code instructions are small (taking between one and four bytes
// or memory, typically, with optionally up to, say, 32 bytes of arguments
// per instruction---these numbers vary depending on the processor in
// question). This isn't so important as the fact that these instructions
// have to be stored somewhere. Guess where.
很久以前我提到编译器接收你的C源码并生成处理器能执行的_机器码_。这些机器码指令通常很小（一般占用1到4字节内存，每条指令可选地有多达32字节的参数---这些数字会根据处理器而变化）。这不是很重要，重要的是这些指令需要被存储在某个地方。猜猜看这个地方在哪里。

```

申明一个类型为“函数指针”的变量是比较困难的一部分。困难之处在于语法有点古怪：

``` {.c}
// declare p as a pointer to a function that takes two int
// parameters, and returns a float:
float (*p)(int, int);
```

再次强调，这是一个指向函数的声明，它还没有具体指向任何函数。同时注意在声明指针变量时不必在参数列表中放置虚拟参数名称。好了，让我们创建一个函数，指向它，然后调用它：

``` {.c}
int deliver_fruit(char *address, float speed)
{
    printf("Delivering fruit to %s at speed %.2f\n", address, speed);

    return 3490;
}

int main(void)
{
    int (*p)(char*,float);  // 声明一个函数指针变量

    p = deliver_fruit; // p 现在指向 deliver_fruit() 函数

    deliver_fruit("My house", 5280.0); // 正常调用

    p("My house", 5280.0); // 使用指针进行相同的调用
}
```

这有什么好处呢？通常的原因如下：

- 您想在运行时更改要调用的函数。
- 您有一个包含函数指针的大型数据数组。
- 您在编译时不知道函数是什么；也许它在一个共享库中，您在运行时加载并查询以找到一个函数，该查询返回一个指向函数的指针。我知道这可能有点超出本节的范围，但请耐心听我说。

例如，很久以前，我和一位朋友写了一个程序，模拟了一群在网格中奔跑的生物。每个生物都有一个与之相关联的 `struct`，其中包含它们的位置、健康状况和其他信息。该 `struct`还保留了指向描述它们行为的函数的指针，就像这样：

``` {.c}
struct creature {
    int xpos;
    int ypos;
    float health;
    int (*behavior)(struct useful_data*);
};
```

因此，在模拟的每一轮中，我们会遍历生物列表，并调用它们的行为函数（传递一个指向一堆有用数据的指针，这样函数就可以看到其他生物，了解自身情况等）。这样，很容易将虫子编码为具有不同的行为。

实际上，我写了一个名为"洗脑者"的生物，当它接近另一个生物时，会将该生物的行为指针改为指向洗脑者的行为代码！当然，没过多久它们都成为了洗脑者，然后饥饿地相互 cannibalized to death。让这成为给你的一课。

## 可变参数列表 {#varargs}

曾经想过，闲暇时，在你躺在床上想着C编程语言，为什么像`printf()` 和 `scanf()`这样的函数似乎接受任意数量的参数，而其他函数则接受特定数量的参数吗？你如何为接受变数量参数的函数编写函数原型？

（不要在术语上混淆---在这种情况下，"variable" 保持其通常无聊的含义，即"任意数量的"。）

嗯，在这种情况下已经有一些小技巧可以帮到你。记得吗，当传递给函数时，所有参数都被推到栈上吗？好吧，已经设置了一些宏来帮助你沿着栈行走，并逐个推送参数。通过这种方式，你无需在编译时知道参数列表的样子---你只需要知道如何解析它。

``` {.c}
float average(int count, ...);
```

我们会使用一系列预处理宏（如果你还没有读过关于宏的部分，它们就像迷你函数一样）来操作我们的`va_list`。首先，我们使用`va_start()`来告诉我们的`va_list`栈从哪里开始。然后我们重复使用`va_arg()`来从栈中取出参数。最后，我们使用`va_end()`来告诉我们的`va_list`我们已经使用完毕了。（语言规范表示我们**必须**调用`va_end()`，而且必须在调用`va_start()`的同一个函数中调用它。这样编译器可以进行必要的清理工作，并避免Vararg警察敲响你的门。

来看一个例子吧！让我们编写一个`average()`函数。记住：`va_start()`，`va_arg()`，`va_arg()`，`va_arg()`，以及最后的`va_end()`！

``` {.c}
float average(int count, ...)
{
    float ave = 0;
    int i;
    va_list args; // 这就是我们的va_list！

    va_start(args, count); // 告诉它栈是以"count"开始的

    // 在for()循环中，从栈中取出int类型的参数：

    for(i = 0; i < count; i++) {
        int val = va_arg(args, int); // 获取下一个int参数
        ave += (float)val;  // 将值转换为float类型并加到总数上
    }

    va_end(args);  // 清理工作完成

    return ave / count; // 计算并返回平均值
}
```

就是这样。你可以看到，`va_arg()`宏会依次从给定类型的栈中取出下一个参数。因此你需要事先知道该值的类型。对于我们的`average()`函数，我们知道所有的类型都是`int`，所以没问题。但如果它们是各种不同类型混合在一起怎么办呢？如何告诉下一个是什么类型呢？

如果你注意到，这正是我们的老朋友`printf()`所做的！它知道应该以何种类型调用`va_arg()`，因为格式字符串中明确指定了。

### `vprintf（）` 及其类似功能 {#varargsvp}

有许多函数能够友好地接受`va_list`作为参数传入。这使你能够轻松地将这些函数封装在自己的函数中，后者本身接受可变数量的参数。例如：

> **作业：** 实现一个名为`timestamp_printf（）`的`printf（）`版本，其工作原理与`printf（）`完全相同，唯一的区别是它会先打印时间，然后是一个换行，最后是由`printf（）`风格格式字符串指定的数据输出。

天哪！乍一看，好像你得实现一个`printf（）`的克隆才能在其前面加上时间戳！而`printf（）`在我们行业里可是被称为"复杂"的东西！等着明年再见吧！

等等，不过---等等，等等...肯定**有**简便的方法，否则这个作者也太过分了，给你这种任务，那可不行。哎呀！我的奶酪在哪里呢！布拉拉啊啊！！

啊em。没事，真心话，法官大人。我现在正在研究我的水晶球，我看到...在你的未来有个`va_list`类型。事实上，如果我们采用我们的可变参数列表，用`va_start（）`处理一下，得到我们的`va_list`，如果这种东西存在的话，我们可以直接将其传递给一个已经编写好的版本的`printf（）`，它只能接受这种东西。

欢迎来到`vprintf（）`的世界！它就是这么回事！这里是一个精彩的原型：

``` {.c}
int vprintf（const char *format，va_list args）;
```

好了，那么对于这个任务我们需要哪些基本构件呢？规范要求我们做的事与`printf（）`类似，因此我们的函数，如同`printf（）`一样，将首先接受一个格式字符串，然后是可变数量的参数，就像这样：

``` {.c}
int timestamp_printf（char *format，...）;
```

但在打印内容之前，它需要输出一个时间戳，然后跟着一个换行符。时间戳的确切格式在任务中没有具体规定，所以我打算假设采用类似于"星期 月份 日 时:分:秒 年份"的格式。非常巧合的是，有一个名为 `ctime()` 的函数，可以返回一个字符串，恰好是当前系统时间的这个格式。

所以计划是先打印一个时间戳，然后取出我们的可变参数列表，通过 `va_start` 将其转换为 `va_list`，然后将该 `va_list` 传递给 `vprintf()`，让它发挥其已经编写好的 `printf()` 魔法。然后就开始吧！

``` {.c}
#include <stdio.h>
#include <stdarg.h>
#include <time.h>  // for time() and ctime();

int timestamp_printf(char *format, ...)
{
    va_list args;
    time_t system_time;
    char *timestr;
    int return_value;

    system_time = time(NULL); // 自纪元以来的系统时间（秒）
    timestr = ctime(&system_time); // 准备好打印的时间戳

    // 打印时间戳：
    printf("%s", timestr); // timestr 结尾已有换行符

    // 获取我们的 va_list：
    va_start(args, format);

    // 使用我们的参数列表调用 vprintf()：
    return_value = vprintf(format, args);

    // 完成后，必须调用 va_end()：
    va_end(args);

    // 由于我们希望与 printf() 完全一致，所以保存了它的返回值，我们将在这里继续传递：
    return return_value;
}

int main(void)
{
    // 示例调用：
    timestamp_printf("由数字 %d 带给您\n", 3490);
}
```

如此便完成了！您拥有了自己的小型 `printf()` 功能！

```c
// 非每个函数都在处理可变参数列表时在名称前带有"v"，但最明显的是所有的`printf()`和`scanf()`的变种都有，所以随意使用它们！
```

```c
// 函数执行宽字符、多字节字符输入和输出；
// 提供宽字符串数字转换的函数；
// 执行一般宽字符串操作的函数；
// 宽字符串日期和时间转换的函数；
// 在多字节字符和宽字符序列之间提供扩展能力的函数。
```

```c
* int fwprintf(FILE * restrict stream, const wchar_t * restrict format, ...);
  * 从数组中的字符被转换，就好像通过多次调用mbrtowc函数进行，转换状态由一个mbstate_t对象描述，在转换第一个多字节字符之前被初始化为零
* int fwscanf(FILE * restrict stream, const wchar_t * restrict format, ...);
* int swprintf(wchar_t * restrict s, size_t n, const wchar_t * restrict format, ...);
* int swscanf(const wchar_t * restrict s, const wchar_t * restrict format, ...);
* int vfwprintf(FILE * restrict stream, const wchar_t * restrict format, va_list arg);
* int vfwscanf(FILE * restrict stream, const wchar_t * restrict format, va_list arg);
* int vswprintf(wchar_t * restrict s, size_t n, const wchar_t * restrict format, va_list arg);
* int vswscanf(const wchar_t * restrict s, const wchar_t * restrict format, va_list arg);
* int vwprintf(const wchar_t * restrict format, va_list arg);
* int vwscanf(const wchar_t * restrict format, va_list arg);
* int wprintf(const wchar_t * restrict format, ...);
* int wscanf(const wchar_t * restrict format, ...);
* wint_t fgetwc(FILE *stream);
* wchar_t *fgetws(wchar_t * restrict s, int n, FILE * restrict stream);
* wint_t fputwc(wchar_t c, FILE *stream);
* int fputws(const wchar_t * restrict s, FILE * restrict stream);
* int fwide(FILE *stream, int mode);
* wint_t getwc(FILE *stream);
* wint_t getwchar(void);
* wint_t putwc(wchar_t c, FILE *stream);
* wint_t putwchar(wchar_t c);
* wint_t ungetwc(wint_t c, FILE *stream);

## 转换函数
```

```c
* double wcstod(const wchar_t * restrict nptr, wchar_t ** restrict endptr);
* float wcstof(const wchar_t * restrict nptr, wchar_t ** restrict endptr);
* long double wcstold(const wchar_t * restrict nptr, wchar_t ** restrict endptr);

* long int wcstol(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);
* long long int wcstoll(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);
* unsigned long int wcstoul(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);
* unsigned long long int wcstoull(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);

## 复制

* wchar_t *wcscpy(wchar_t * restrict s1, const wchar_t * restrict s2);

* wchar_t *wcsncpy(wchar_t * restrict s1, const wchar_t * restrict s2, size_t n);
* wchar_t *wmemcpy(wchar_t * restrict s1, const wchar_t * restrict s2, size_t n);

* wchar_t *wmemmove(wchar_t *s1, const wchar_t *s2, size_t n);
* wchar_t *wcscat(wchar_t * restrict s1, const wchar_t * restrict s2);
* wchar_t *wcsncat(wchar_t * restrict s1, const wchar_t * restrict s2,
  size_t n);

## 比较

* int wcscmp(const wchar_t *s1, const wchar_t *s2);
* int wcscoll(const wchar_t *s1, const wchar_t *s2);

* int wcsncmp(const wchar_t *s1, const wchar_t *s2, size_t n);
* size_t wcsxfrm(wchar_t * restrict s1, const wchar_t * restrict s2, size_t n);
* int wmemcmp(const wchar_t *s1, const wchar_t *s2, size_t n);

## 搜索
```

```c
* wchar_t *wcschr(const wchar_t *s, wchar_t c); // 在宽字符字符串 s 中查找字符 c
* size_t wcscspn(const wchar_t *s1, const wchar_t *s2); // 返回 s1 中不含 s2 中字符的最长前缀子串的长度
* wchar_t *wcspbrk(const wchar_t *s1, const wchar_t *s2); // 在 s1 中找到第一个在 s2 中出现的字符
* wchar_t *wcsrchr(const wchar_t *s, wchar_t c); // 在宽字符字符串 s 中查找字符 c 的最后一个匹配位置
* size_t wcsspn(const wchar_t *s1, const wchar_t *s2); // 返回 s1 中只含 s2 中字符的前缀子串的长度
* wchar_t *wcsstr(const wchar_t *s1, const wchar_t *s2); // 在宽字符字符串 s1 中查找子串 s2 的首次出现位置
* wchar_t *wcstok(wchar_t * restrict s1, const wchar_t * restrict s2, wchar_t ** restrict ptr); // 分解字符串 s1 为一组标记字符串
* wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n); // 在宽字符字符串 s 的前 n 个字符中查找字符 c

## 长度和杂项

* size_t wcslen(const wchar_t *s); // 返回宽字符字符串 s 的长度
* wchar_t *wmemset(wchar_t *s, wchar_t c, size_t n); // 将宽字符字符串 s 的前 n 个字符设置为字符 c
* size_t wcsftime(wchar_t * restrict s, size_t maxsize, const wchar_t * restrict format, const struct tm * restrict timeptr); // 根据 format 格式化 timeptr 所指向时间的字符串，并存储在 s 中，最多存储 maxsize 个字符

## 字符串转换

* wint_t btowc(int c); // 将单字节字符 c 转换为宽字符
* int wctob(wint_t c); // 将宽字符 c 转换为对应的单字节字符
* int mbsinit(const mbstate_t *ps); // 检查状态对象是否为初始状态
* size_t mbrlen(const char * restrict s, size_t n, mbstate_t * restrict ps); // 检查多字节字符序列的长度
* size_t mbrtowc(wchar_t * restrict pwc, const char * restrict s, size_t n, mbstate_t * restrict ps); // 将多字节字符转换为宽字符
* size_t wcrtomb(char * restrict s, wchar_t wc, mbstate_t * restrict ps); // 将宽字符转换为多字节字符
* size_t mbsrtowcs(wchar_t * restrict dst, const char ** restrict src, size_t len, mbstate_t * restrict ps); // 将多字节字符串转换为宽字符字符串
* size_t wcsrtombs(char * restrict dst, const wchar_t ** restrict src, size_t len, mbstate_t * restrict ps); // 将宽字符字符串转换为多字节字符串

## 字符分类

`<wctype.h>`
```

```c
int iswalnum(wint_t wc); // 检查字符是否为字母或数字
int iswalpha(wint_t wc); // 检查字符是否为字母
int iswblank(wint_t wc); // 检查字符是否为空白字符
int iswcntrl(wint_t wc); // 检查字符是否为控制字符
int iswdigit(wint_t wc); // 检查字符是否为数字
int iswgraph(wint_t wc); // 检查字符是否为可打印字符，但非空格
int iswlower(wint_t wc); // 检查字符是否为小写字母
int iswprint(wint_t wc); // 检查字符是否为可打印字符
int iswpunct(wint_t wc); // 检查字符是否为标点字符
int iswspace(wint_t wc); // 检查字符是否为空白字符
int iswupper(wint_t wc); // 检查字符是否为大写字母
int iswxdigit(wint_t wc); // 检查字符是否为十六进制数字
int iswctype(wint_t wc, wctype_t desc);// 检查字符是否符合指定条件
iswctype(wc, wctype("alnum")) // iswalnum(wc)
iswctype(wc, wctype("alpha")) // iswalpha(wc)
iswctype(wc, wctype("blank")) // iswblank(wc)
iswctype(wc, wctype("cntrl")) // iswcntrl(wc)
iswctype(wc, wctype("digit")) // iswdigit(wc)
iswctype(wc, wctype("graph")) // iswgraph(wc)
iswctype(wc, wctype("lower")) // iswlower(wc)
iswctype(wc, wctype("print")) // iswprint(wc)
iswctype(wc, wctype("punct")) // iswpunct(wc)
iswctype(wc, wctype("space")) // iswspace(wc)
iswctype(wc, wctype("upper")) // iswupper(wc)
iswctype(wc, wctype("xdigit")) // iswxdigit(wc)
wctype_t wctype(const char *property);// 返回描述特定字符类别的对象
wint_t towlower(wint_t wc);// 将字符转换为小写
wint_t towupper(wint_t wc);// 将字符转换为大写
wint_t towctrans(wint_t wc, wctrans_t desc);// 对字符执行宽字符转换
towctrans(wc, wctrans("tolower")) // towlower(wc)
towctrans(wc, wctrans("toupper")) // towupper(wc)
wctrans_t wctrans(const char *property); // 返回描述特定宽字符映射的对象

## Unicode Utils

`<uchar.h>`

size_t mbrtoc16(char16_t * restrict pc16, const char * restrict s, size_t n, mbstate_t * restrict ps);// 将多字节字符转换为UTF-16编码
size_t c16rtomb(char * restrict s, char16_t c16, mbstate_t * restrict ps);// 将UTF-16字符转换为多字节字符
size_t mbrtoc32(char32_t * restrict pc32, const char * restrict s, size_t n, mbstate_t * restrict ps);// 将多字节字符转换为UTF-32编码
size_t c32rtomb(char * restrict s, char32_t c32, mbstate_t * restrict ps);// 将UTF-32字符转换为多字节字符
```

这是 C11 的一个有趣特性，允许您创建一个没有名称的对象。有时候，这可能会很有用，比如当您需要将一个临时的 `struct` 传递给一个函数，但希望它只存在于函数参数中，而不是作为一个常规变量在其他地方。

首先，让我们看一些牵强附会且无用的语法。

``` {.c}
int a = (int){2};
```

在赋值操作的右边，我们有一个未命名的 `int`，其被初始化为 `2`。然后我们立即将它赋值给变量 `a`。

``` {.c}
int a = (int){2};
int a = 2;         // 同样的意思
```

如果它们是一样的，为什么还要费劲用这种语法呢？这样更难阅读且更啰嗦。

嗯，让我们用一个 `struct` 来尝试一下，并看看会发生什么。

```c
// The sizeof operator shall not be applied to an expression that has function type or an incomplete type, to the parenthesized name of such a type, or to an expression that designates a bit-field member. The _Alignof operator shall not be applied to a function type or an incomplete type.
// sizeof 操作符不得用于具有函数类型或不完整类型的表达式，用于此类类型的带括号的名称，或用于指定位域成员的表达式。 _Alignof 操作符不得应用于函数类型或不完整类型。

fn129

// An incomplete type may only by used when the size of an object of that type is not needed. It is not needed, for example, when a typedef name is declared to be a specifier for a structure or union, or when a pointer to or a function returning a structure or union is being declared. (See incomplete types in 6.2.5.) The specification has to be complete before such a function is called or defined.
// 仅在不需要该类型对象的大小时才可使用不完整类型。例如，当 typedef 名称声明为结构体或共用体的说明符时，或者声明指向结构体或共用体的指针或函数时，就不需要它。必须在调用或定义此类函数之前，规范必须完成。

6.7.6.2p4

// If the size is not present, the array type is an incomplete type.
// 如果没有提供大小，则数组类型为不完整类型。

6.7.6.2p8

// EXAMPLE 2 Note the distinction between the declarations 
// 示例 2 注意声明之间的区别

extern int *x;
extern int y[];

// The first declares x to be a pointer to int; the second declares y to be an array of int of unspecified size (an incomplete type), the storage for which is defined elsewhere.
// 第一个声明 x 为 int 指针；第二个声明 y 为未指定大小的 int 数组（不完整类型），其存储空间在其他地方定义。

6.7.9p31

// EXAMPLE 7 One form of initialization that completes array types involves typedef names. Given the declaration
// 示例 7 完成数组类型所涉及的初始化形式是使用 typedef 名称。鉴于以下声明

typedef int A[]; // OK - declared with block scope
// 声明

A a = { 1, 2 }, b = { 3, 4, 5 };
// 等同于

int a[] = { 1, 2 }, b[] = { 3, 4, 5 };
//由于不完整类型的规则。

6.9.2p3

// If the declaration of an identifier for an object is a tentative definition and has internal linkage, the declared type shall not be an incomplete type.
// 如果对象的标识符声明为试探定义并具有内部链接，则声明的类型不得是不完整类型。

6.9.2p5

// EXAMPLE 2 If at the end of the translation unit containing
// 示例 2 如果在包含以下内容的翻译单元的末尾

int i[];

// the array i still has incomplete type, the implicit initializer causes it to have one element, which is set to zero on program startup.
// 数组 i 仍然具有不完整类型，则隐式初始化程序会使其具有一个元素，在程序启动时，该元素设置为零。

6.2.5p1
```

```c
// 这个[6.2.5p19]位置的代码块需要翻译

在翻译单元的各个部分，一个对象类型可能是不完全的（没有足够的信息来确定该类型对象的大小），或者是完全的（具有足够的信息）。

// 这个[6.2.5p19]位置的代码块需要翻译

该void类型包含一个空值集；它是一个不完全的对象类型，无法被完全化。

// 这个[6.7.2.1p3]位置的代码块需要翻译

结构或联合体不得包含一个具有不完全或函数类型的成员（因此，结构体不得包含自身的实例，但可以包含指向自身实例的指针），除非拥有一个以上有名成员的结构的最后一个成员可以具有不完全的数组类型；这样的结构体（以及任何包含这样一个结构体的成员的联合体，可能是递归的）不得是结构体的成员或数组的元素。

// 这个[6.7.2.1p8]位置的代码块需要翻译

[struct/union]类型在终结列表的}之后立即是不完全的，之后则是完全的。

// 这个[6.7.2.1p18]位置的代码块需要翻译
```

```c
// As a special case, the last element of a structure with more than one
// named member may have an incomplete array type; this is called a
// flexible array member. In most situations, the flexible array member is
// ignored. In particular, the size of the structure is as if the flexible
// array member were omitted except that it may have more trailing padding
// than the omission would imply. However, when a . (or ->) operator has a
// left operand that is (a pointer to) a structure with a flexible array
// member and the right operand names that member, it behaves as if that
// member were replaced with the longest array (with the same element type)
// that would not make the structure larger than the object being accessed;
// the offset of the array shall remain that of the flexible array member,
// even if this would differ from that of the replacement array. If this
// array would have no elements, it behaves as if it had one element but
// the behavior is undefined if any attempt is made to access that element
// or to generate a pointer one past it.

// 某些情况下，具有多个命名成员的结构的最后一个元素可以具有不完整的数组类型；这称为灵活数组成员。在大多数情况下，灵活数组成员会被忽略。特别地，结构的大小就好像灵活数组成员被省略一样，除非它可能比省略部分多出更多的尾部填充。然而，当.（或->）运算符的左操作数是（指向）具有灵活数组成员的结构，并且右操作数命名了该成员时，它的行为就好像将该成员替换为最长的数组（具有相同的元素类型），该数组不会使结构比正在访问的对象更大；数组的偏移量应保持为灵活数组成员的偏移量，即使这可能不同于替换数组的偏移量。如果该数组没有元素，则其行为就好像它有一个元素，但如果试图访问该元素或生成一个超出它的指针，则行为是未定义的。

// Each enumerated type shall be compatible with char, a signed integer
// type, or an unsigned integer type. The choice of type is
// implementation-defined, but shall be capable of representing the
// values of all the members of the enumeration. The enumerated type is
// incomplete until immediately after the } that terminates the list of
// enumerator declarations, and complete thereafter.

// 每个枚举类型都应与char、有符号整数类型或无符号整数类型兼容。类型的选择是由实现定义的，但必须能够表示枚举所有成员的值。枚举类型是不完整的，直到枚举声明列表结束的}之后立即，然后它才是完整的。

// If a type specifier of the form struct-or-union identifier occurs other
// than as part of one of the above forms, and no other declaration of the
// identifier as a tag is visible, then it declares an incomplete structure
// or union type, and declares the identifier as the tag of that type.

// 如果结构体或联合体标识符是以struct-or-union identifier的形式出现的，且没有其他声明将该标识符用作标签，那么它将声明一个不完整的结构体或联合体类型，并将该标识符声明为该类型的标签。
```

```c
// 评估方法确定涉及所有浮点类型的表达式的评估格式，不仅包括实数类型。例如，如果FLT_EVAL_METHOD为1，则两个float _Complex操作数的乘积以double _Complex格式表示，并且其部分被评估为double。

// 有三个复数类型，分别指定为float _Complex，double _Complex和long double _Complex。(复数类型是一个条件特性，实现并非必须支持；请参见6.10.8.3.) 实数浮点类型和复数类型统称为浮点类型。

// 对于每种浮点类型，都有一个对应的实数类型，该实数类型始终为实浮点类型。对于实数浮点类型，它是同一类型。对于复数类型，它是通过从类型名称中删除关键字_Complex而获得的类型。

// 每种复数类型具有与包含恰好两个对应实数类型元素的数组类型相同的表示形式和对齐要求；第一个元素等于复数的实部，第二个元素等于虚部。

#define STDC_NO_COMPLEX
#define __STDC_IEC_559_COMPLEX__

#define complex _Complex

// 浮点复数类型
float complex
double complex
long double complex

// 虚数单位
_Complex_I

// 虚部
_Imaginary
_Imaginary_I

// 如果存在，则I扩展为_Imaginary_I，否则为_Complex_I

// https://en.cppreference.com/w/c/numeric/complex/imaginary

// 声明仅支持有限范围的复数运算
#pragma STDC CX_LIMITED_RANGE

// 所有数学函数

// 使用CMPLX函数组合复数

```