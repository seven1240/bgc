# 变量，续集 {#vars2}

刚刚当你以为你已经了解一切关于变量的知识并且安全时，这部分指南突然从黑暗中扑过来！什么？还有更多？

是的，抱歉，但恐怕确实还有。在这一部分，我们将讨论一些可以极大增加你对变量控制力的事情。是的，到现在你应该意识到夸张成分在这个指南中是一个备受尊敬的部分，所以你可能甚至没有被那个吓到，具有讽刺意味。

我在哪儿？哦，是的；让我们谈一谈变量的 _作用域_ 和 _存储类_。


## "向上作用域" {#varscope}

你还记得在我们之前定义的一些函数中有一些变量是从程序的某些部分可见但从其他部分不可见的吗？如果你可以在程序的某个部分使用变量，那么它被称为 _在作用域内_（相对于 _超出作用域_）。如果变量在当前执行的块（即被花括号包围的块）中声明，则它将处于作用域内。

看看这个例子：

``` {.c}
int frotz(int a)
{
    int b;

    b = 10; /* 在作用域内（来自本地定义） */
    a = 20; /* 在作用域内（来自参数列表） */
    c = 30; /* 错误，超出作用域（在另一个块中声明，在 main() 中） */
}

int main(void)
{
    int c;

    c = 20; /* 在作用域内 */
    b = 30; /* 错误，超出作用域（在 frotz() 中上面声明） */
}
```

所以你可以看到，必须要在本地声明变量才能使其处于作用域内。同时注意参数 `a` 也对函数 `frotz()` 在作用域内。

我到底什么是 _局部变量_？这些变量只存在于代码的一个基本块中，并且只在该基本块内可见（也就是，被花括号包围的代码），以及其内部的基本块。例如：

``` {.c}
int main(void)
{  /* 基本块开始 */
    int a = 5; /* main() 内的局部变量 */

    if (a != 0) {
        int b = 10; /* if 基本块内的局部变量 */

        a = b; /* 完全合法 -- 这里可见的有 a 和 b */
    }

    b = 12; /* 错误 -- b 在这里不可见 -- 只在 if 中可见 */

    { /* 注意我在没有语句的情况下开始了一个基本块--这是合法的 */
        int c = 12;
        int a; /* 嗨！等等！main 中已经有一个 "a" 了！ */

        /* 局部于该基本块的 a 遮蔽了主函数中的 a */
        a = c; /* 这会将此基本块内的 a 设置为 12 */
    }

    /* 但是主函数中的这个 a 仍然是 10（因为我们在 if 中设置了它）： */
    printf("%d\n", a);
}
```

这个例子中有很多内容，但基本上都是对一个简单规则的展示：关于局部变量，你只能在声明它们的基本块中使用，或在那些基本块内使用。看看例子中的 "错误" 行，以了解究竟 _不能_ 行得通的是什么。

让我们稍微偏离一下话题，考虑一下函数参数的特殊情况。这些参数在整个函数范围内都是可见的，你可以随意修改它们。它们就像函数的局部变量一样，只是显然是你传入的数据的副本。

``` {.c}
void foo(int a)
{
    int b;

    a = b; /* 完全合法 */
}
```


### 全局变量 {#globals}

除了局部变量之外，还有其他类型的变量。例如，有全局变量。听起来很了不起，对吧。尽管由于很多原因它们并不完美，但它们仍然是语言中的一个强大组成部分。谨慎地运用这个功能，因为如果滥用的话，可能会写出难以维护的代码。

全局变量可在定义它的整个文件中可见（或声明在其中——稍后会详细讨论）。因此，它就像一个局部变量，只不过可以在任何地方使用。我想，它与局部变量其实并不太像。以下是一个例子：

``` {.c}
#include <stdio.h>

/* 这是一个全局变量。我们知道它是全局的，因为它被 */
/* 声明在"全局范围"中，而不是在某个基本块中 */
int g = 10;

void afunc(int x)
{
    g = x; /* 这将全局变量设置为参数 x 的值 */
}

int main(void)
{
    g = 10; /* 全局变量 g 现在是 10 */
    afunc(20); /* 但这个函数将它设置为 20 */
    printf("%d\n", g); /* 因此这将输出 "20" */
}
```

还记得局部变量存储在堆栈上吗？那么，全局变量是存储在堆上的，堆是另一个内存块。二者永不相交。你可以将堆视为比栈更"永久"的地方，从多个方面看。

（糟糕——C 标准也没有提到堆。但和堆栈一样，所有的 C 程序员都使用这个术语，他们会理解你在说什么。）

现在，我提到了全局变量可能存在一些危险。是什么危险？嗯，一个可能的情况是，在一个大型项目中，可能有成千上万的全局变量，由成千上万个不同的程序员声明。如果它们取了相同的名字会怎么样呢？如果你以为你在用一个局部变量，但你忘记声明它，结果你使用了全局变量呢？

噢。这是一个很好的侧面说明：如果你声明一个和全局变量同名的局部变量，它会隐藏全局变量，作用域内的所有操作都将在局部变量上进行。

还会发生什么问题？有时使用全局变量会导致人们不太注重代码的结构，这不如其他方式更好。最好等没有其他合理的方法传递数据时再使用它们。

另一点要考虑的是：将这些数据存储在全局范围内真的有意义吗？例如，如果你有一个游戏，在很多不同的地方都使用“世界的温度”，那么这可能是一个全局变量的好候选。为什么呢？因为传递它很麻烦，并且每个人都需要它。

另一方面，“这家伙的小指的温度”可能对宇宙的其他部分并不那么重要。最好将这些数据存储在更与这个家伙相关联的方式中，而不是全局。我们稍后会更多地讨论如何将数据与事物相关联（听起来有点含糊，不是吗？）。

## 存储类 {#stclasses}

什么是存储类？它是用于存储变量的类。

不客气。

不要把它与任何C++类混淆，因为它完全不是一回事。

那么存储类声明的作用是什么？它告诉编译器数据应该存储在哪里，比如栈上、堆上，或者数据存储已经在其他地方声明了。

“什么？”

让我们举几个例子，这样就会更容易理解。

### 给我一些静态！ {#static}

准备好了吗？这里有一个例子：我正坐在 BART（旧金山湾区快速交通地铁）上，正在从工作回家的路上输入这些内容。在我前面的座位上有一对年轻情侣在快乐地亲昵，完全分散了我的注意力。

...嗯，什么。哦，例子！是的！好的，这里是：

``` {.c}
void print_plus_one(void)
{
    static int a=0; /* 静态存储类！ */

    printf("%d\n", a);

    a++;  /* 增加静态值 */
}

int main(void)
{
    print_plus_one(); /* 打印 "0" */
    print_plus_one(); /* 打印 "1" */
    print_plus_one(); /* 打印 "2" */
    print_plus_one(); /* 打印 "3" */
    print_plus_one(); /* 打印 "4" */
}
```

我们在这里看到了什么？这是如何发生的奇迹？`print_plus_one()` 中的那不是一个局部变量吗？并且在堆栈上被分配，然后在函数返回后会消失吗？它怎么可能记住上次调用的值呢？

答案是：它使用了现代的魔法，即 `static` 关键字。这个指令（放在类型前面）告诉编译器实际上将这个数据存储在某个永久位置，而不是在堆栈上！哦哦哦！嗯，在定义时初始化一次该值，不会再次初始化，所以对它的所有操作是累积的。

另外，如果你将一个局部变量定义为静态，它将自动初始化为零，除非你另行指定。

你可能会在以后看到更多关于这个的用途，但这很常见，你应该知道这一点。

另一个是 `extern`，它告诉编译器变量的定义在另一个文件中。这允许你从一个文件引用全局变量，即使它的定义在别处。对它进行两次定义是不合法的，而且由于它是全局的，最好可以在不同的源文件中使用它。

我知道，我知道。现在很难想象，但程序最终会变得足够庞大，横跨多个文件。`:-)`

# 结构体和联合体 {#structs}

你已经一段时间搞变量了，到处创建一大堆变量来做各种事情，是吗？通常你会将它们捆绑到同一个基本块中，然后就完成了。

有时，将它们组合成一个 _结构体_ 更有意义。这是一种构造，允许你将变量逻辑地（甚至不合逻辑地，如果你愿意的话）分组到，嗯，组中。然后你可以把这一组作为整体引用。这个非常方便的地方之一是，如果你想向一个函数传递 13 亿个参数，但又不想让函数声明那么长，你只需将所有变量放入一个结构体（或者通常称为 `struct`），然后将该结构体传递给函数。（实际上，人们通常传递结构体的指针，但我们以后会谈到这一点。）

那么要如何使用这些东西呢？首先，`struct` 本身是一种新类型。如果你创建了一个 `struct foo` 类型的变量，它的类型就是 "`struct foo`"，就像数字 12 是 `int` 类型一样。这有点神秘，因为这可能是你第一次创造一个新类型，也许不太清楚它是如何工作的。

增加了混乱的是，原来有多种创建和使用新 `struct` 类型的方式，其中几乎没有一种是特别直观的。我们将通过一个声明新 `struct` 的方式示例：

``` {.c}
#include <stdio.h>

/* 在这里我们声明这个类型以便稍后使用: */
struct stuff {
    int val;
    float b;
};

/* 请注意，我们实际上还没有该类型的任何变量。 */

int main(void)
{
    /* 现在，让我们声明一个名为"s"、类型为"struct stuff"的变量 */
    struct stuff s;

    s.val = 3490;  /* 对struct进行赋值! */
    s.b = 3.14159;

    printf("s中的val字段为: %d\n", s.val);
}
```

编译器允许我们像示例中那样预先声明一个 `struct`。我们可以在以后使用它，就像我们在 `main()` 中赋值一样。当我们说类似 `s.val = 3490` 这样的事情时，我们正在使用一个特殊操作符来访问 `val` 字段，即点操作符(`.`)。


## 指向 `struct` 的指针 {#structpt}

现在让我们来谈谈如何将这些 `struct` 传递给其他函数和内容。我之前提到过，你可能想传递指向 `struct` 的指针，而不是 `struct` 本身。为什么呢？

难道你不讨厌教授问你那种问题吗，但在讲座中你太累了，根本懒得去思考吗？"告诉我答案，然后我们就继续吧，"你是不是这么想呢？

算了! 恩为谁就算谁吧! 那么，记住，当你将参数传递给函数时，我要清清嗓子，再次说一遍，_每一个参数在调用函数时都会被复制到栈上!_ 所以如果你有一个大约 80,000 字节大小的巨大 `struct`，当你传递它时，它就会被复制到栈上。这需要时间。

反正，为什么不传递一个指向结构体的指针呢？我明白你的意思---那指针难道不会在堆栈上被复制吗？确实会，但是这些天指针只有4或8个字节，因此对机器来说更容易，速度更快。

而且还有一点点“语法糖”可以帮助访问指向`struct`的指针中的字段。对于那些不熟悉的人来说，语法糖是编译器的一个功能，它简化代码，尽管实现同样的功能还有其他方法。例如，我已经多次提到`+=`……它是做什么的？我有没有告诉过你？老实说，在所有激动之中，我自己都忘了。这里有一个示例，展示了它如何像另外两个运算符一样工作，但使用起来更加简单。这是语法糖：

``` {.c}
i = i + 12;  /* 将12加到i上 */
i += 12;     /* <-- 和 "i = i + 12" 意义完全相同 */
```

你看吧？这不是必要的运算符，因为还有其他方法可以达到同样的效果，但人们喜欢捷径。

但是我们偏题了。我在谈论指向`struct`的指针，而现在我们讨论如何访问它们。以下是一个示例，其中我们有一个`struct`变量，以及另一个变量是指向该`struct`类型的指针，以及对两者的一些用法（这里会使用上面的`struct stuff`）：

/* 由于 b 是一个指针，在使用之前我们必须对它进行解引用： */

(*b).val = 3491;

/* 但这看起来有点糟糕，所以让我们做完全相同的事情
   除了这一次我们将使用“箭头操作符”，这是一种
   语法糖： */

b->val = 3491; /* 与 (*b).val = 3491; 完全相同 */

这里我们了解到了一些事情。首先，我们看到了如何解引用结构体的指针然后使用点操作符（`.`）访问它。这是一种经典的做法：我们有一个指针，所以我们解引用它以访问它指向的变量，然后我们可以像这个变量一样对待它。

但是，有语法糖来拯救我们，我们可以使用箭头操作符（`->`）代替点操作符！这样我们看起来就不那么丑陋了，对吧？箭头操作符内置了解引用，因此当你有一个指向结构体的指针时，你不需要操心解引用的语法。所以规则就是：如果你有一个结构体，使用点操作符；如果你有一个指向结构体的指针，使用箭头操作符（`->`）。

## 将结构体指针传递给函数 {#ptsfunc}

这将是一个非常简短的部分，讲述关于将指向结构体的指针传递给函数。我的意思是，你已经知道如何将变量作为参数传递给函数，也知道如何创建和使用结构体的指针，所以这里真的没有什么需要多说的。通过示例就可以明白了。
（“直截了当”——如果我看到了一个自相矛盾的词，那就是它了。）

咕噜咕噜。为什么我总是坐在公交车这一侧？我是说，我知道太阳光线从这里进来，而且我几乎无法阅读屏幕，因为明亮的光线直射过来。你觉得我现在该学乖了。所以_无论如何_...

在这里要注意另一件事：如果我们传递`struct`而不是`struct`的指针，在`build_beejs_frog()`函数中改变值会发生什么？没错：它们只会在本地副本中更改，而不会反映到`main()`中。简而言之，当涉及将`struct`传递给函数时，指向`struct`的指针是正确的方法。

## 联合 {#unions}

既然我们已经在一定程度上介绍了`struct`，我们可以谈论一下相关的数据实体，称为`union`。从句法上看，`union`和`struct`非常相似；将上面的示例中的单词`struct`替换为单词`union`就可以了。但是你需要注意这两者之间的重要区别。

重要区别在于：`union`为其所有成员共享相同的内存空间。例如，考虑这个`union`：

如果你将一些东西存储在 `train_type` 字段中，它会影响 `crab_name` 字段和 `cups_of_coffee` 字段中的内容。这是因为这三个字段都存储在内存中的同一位置上。

`union` 存在的原因是允许你在知道不会同时使用字段时在类似 `struct` 结构中节省内存。一个更实际的例子可能是，如果你想要存储数据及其类型，你可以将类型存储为 `int`（或者稍后介绍的 `[enum](#enum)`），然后在其下面的 `union` 中存储数据。

``` {.c}
#include <stdio.h>

struct variable {
    // 0 = int, 1 = float, 2 = string
    int type;

    union data {
        int i;
        float f;
        char *s;
    } data;
};

void print_variable(struct variable *v)
{
    switch(v->type) {
    case 0: // int
        printf("%d\n", v->data.i);
        break;
    case 1: // float
        printf("%f\n", v->data.f);
        break;
    case 2: // string
        printf("%s\n", v->data.s);
        break;
    }
}

int main(void)
{
    struct variable v;

    v.type = 1;
    v.data.f = 0.8;

    print_variable(&v);
}
```

这里简单说明一下，让你想一想如何将内容分解为基本块。现在你有很多不同的工具可供使用：循环、条件语句、`struct`，尤其是函数。回想一下你是如何学会将项目分解为小部分然后看看你会如何使用这些单独的工具。

# 数组 {#arrays}

在这一节中，我们为您提供了如此广泛的信息数组。_*BLAM*!_ 我们很抱歉---这个双关语已经过时了。

一个数组：相关数据的线性集合。嗯？它是一个连续的内存块，存储着若干个相同的数据类型。为什么我们要这么做呢？好吧，这里有一个没有使用数组的示例：

``` {.c}
int age0;
int age1;
int age2;
int age3;
int age4;

age1 = 10;
printf("年龄 1 是 %d\n", age1);
```

这里是使用数组魔力的同样示例：

``` {.c}
int age[5];

age[1] = 10;
printf("年龄 1 是 %d\n", age[1]);
```

哦哦哦！看看这是多么优雅！你可以使用方括号表示法（`[]`）通过在其中放置一个 `int` 变量或者像示例中那样的一个常数来访问数组中的_元素_。由于你可以使用一个变量来对数组进行_索引_，这意味着你可以在循环等地方进行操作。这里有一个更好的示例：

``` {.c}
int i;
int age[5] = {10,20,25,8,2};

for(i = 0; i < 5; i++) {
    printf("年龄 %d 是 %d\n", i, age[i]);
}
```

哇---我们在这里做了一些新的事情。首先，你会注意到在数组定义中，我们一次性初始化了整个数组。这只允许在_定义中_这样做。一旦你到了代码部分，使用这种方法初始化数组就为时已晚，必须逐个元素进行初始化。

另一个要注意的是我们在`for`循环内部如何访问数组元素：使用 `age[i]`。在这个`for`循环中会发生什么是，`i`从0取值到4，因此每个`age`会依次被打印出来，如下所示：

```shell
年龄 0 是 10
年龄 1 是 20
年龄 2 是 25
年龄 3 是 8
年龄 4 是 2
```

为什么它从0到4运行而不是从1到5？好问题。最简单的答案是数组的索引数字是_从零开始计数_而不是从一开始计数。我知道这不是一个真正的答案...嗯，事实证明大多数（如果不是所有）处理器在进行内存访问时使用零为基准的索引。因此，这非常适配。

您可以创建任何类型的数组，包括`structs`和指针。

## 将数组传递给函数 {#array2fun}

将数组传递给函数相当轻松，但情况会有点奇怪。最奇怪的部分是，当您通过将数组的名称作为参数传递给函数来传递“整个”数组时，实际上传递给你的是数组的第一个元素的_指针_。

现在，在函数内部，您仍然可以使用数组符号 (`[]`) 访问该数组。以下是一个示例：

``` {.c}
void init_array(int a[], int count)
{
    int i;

    /* 对于每个元素，将其设置为其索引号乘以10： */

    for(i = 0; i < count; i++)
        a[i] = i * 10;
}

int main(void)
{
    int mydata[10];

    init_array(mydata, 10);  /* 注意缺少[]符号 */
}
```

这里需要注意的几点是，在`init_array()`的声明中，我们不必指定数组的_维度_（即数组中有多少个元素）。我们可以指定，但并不是必须的。

此外，由于C语言中的数组没有内置的大小概念（即包含多少元素），我们必须友好地配合，并将数组的大小单独传递给函数。我们稍后在`for`循环中使用它以知道要初始化多少个元素。

嘿！我们在调用中没有使用取地址运算符！这样做会导致将数组复制到栈上吗？这不好吗？嗯，不会。

当你有一个数组时，去掉方括号会得到数组第一个元素的一个指针。（如果你想的话，可以使用取地址运算符，但实际上会得到不同的指针类型，所以可能不是你所期望的。） 因此，实际上是将一个指向数组的指针复制到栈上进行函数调用，而不是整个数组。

现在，你应该意识到你可以使用数组来保存很多东西，并且在常涉及数据集合的项目中会对你很有帮助。例如，假设：

> 
我们有一个虚拟世界，里面有许多虚拟生物四处奔跑做虚拟事情。每个生物都有一个真实的 X 和 Y 坐标。总共有 12 个生物。在模拟的每一步中，生物们会处理它们的行为算法并移动到一个新的位置。新的位置需要被展示。

噢噢！是时候搞建设积木了！我们有些什么？好的，我们需要为生物有一个 X 和 Y 坐标。我们需要 12 个生物。我们需要一个重复处理每个生物行为的结构。还有输出。

所以生物的坐标。有几种方法可以实现这个。你可以有两个包含 12 个元素的数组，一个用来保存 X 坐标，一个用来保存 Y 坐标。（这些被称为_并行数组_。）但是我们来想一种将这些数据捆绑在一起的方法。我的意思是，它们都与同一个虚拟生物相关联，所以能不能有一种逻辑上相关的方式呢？如果有一个方法就好了...但等等！对了！一个 `struct`！

这样就行了。现在我们需要 12 个它们；12 个 `struct creature` 类型的项目。如何有效地保存相同类型的集合呢？对，对！数组！

``` {.c}
struct creature guys[12];
```

那么还需要什么---我们需要能够反复执行这些生物的行为。就像一遍又一遍地循环...是的，用循环很适合。但我们应该循环多少次呢？我的意思是，规范没有告诉我们这一点，所以这是一个很好的问题。通常我们会循环直到某个退出条件为真（比如用户按下 ESC 键或者类似的情况），但由于规范作者没有说明，让我们就一直循环下去吧。

``` {.c}
for(;;) {  /* 无限循环 */
```

接下来呢？我们需要编写这些生物的行为并将其放入循环中，是吗？由于我们即将写的是很多独立的代码，我们不妨将其放入一个函数中，然后为每个生物调用该函数。但具体的函数实现我会留给你这位读者来完成。`:-)`

``` {.c}
for(i = 0; i < 12; i++) {
            execute_behavior(&(guys[i]));
        }
```

你可能注意到我们在调用中使用了取地址运算符。在这种情况下，我们并不是传递整个数组；我们只是传递数组中的单个元素的指针。这不一定总是必要的（你可以在调用中复制单个元素），但由于这是一个 `struct`，我传递指针以保持内存开销较低。

最后一件要做的事情是输出信息。怎样实现这一点应该在规范中，但并没有。将生物在哪里用小图标展示在高分辨率屏幕上会很酷，但这超出了我们当前所做的范围，所以我们只是简单地写一个打印出这些生物信息的简单程序。

最后一点---在使用数据之前初始化数据总是一个好主意，对吧？所以我会编写一个函数，在使用生物之前也对它们进行初始化。它如何进行初始化在规范中也没有定义，所以我将在对角线上任意设置它们。

已完成（除了行为）的代码：

``` {.c}
#include <stdio.h>

struct creature {
    float x;
    float y;
};

void execute_behavior(struct creature *c)
{
    /* 现在什么也不做 */
    /* --如果你希望它们移动，你将需要编写它！ */
}

main(int main(void)
{
    int i;
    struct creature guys[12];

    /* 初始化它们--可以是一个独立的函数： */

    for(i = 0; i < 12; i++) {
        guys[i].x = (float)i; /* (float) 是一个“强制转换”--它改变了类型！ */
        guys[i].y = (float)i;
    }

    /* 主循环 */

    for(;;) {   /* 无限循环 */

        /* 让它们做它们的事情： */

        for(i = 0; i < 12; i++) {
            execute_behavior(&(guy[i]));
        }

        /* 输出结果 */
        for(i = 0; i < 12; i++) {
            printf("生物 %d: (%.2f, %.2f)\n", i, guys[i].x, guys[i].y);
        }
    }
}
```

我在代码中加入了一个“强制转换”：`(float)`。
看到`i`是一个`int`，但每个字段`guys[i].x`和`guys[i].y`是一个`float`。
强制转换会将紧跟其后的表达式，本例中为"`i`"，改变为指定的类型。在赋值操作符（`=`）的两边都有相同的类型总是一个好主意。

另一个新事物是在`printf()`格式字符串中的"`%.2f`"。一个普通的"`%f`"表示打印一个`float`，这就是我们要传递的内容。额外的"`.2`"表示以两位小数打印它。你可以去掉"`.2`"看看会发生什么。`:-)`

字符串是现代物理学中的一个理论构造，用于帮助解释宇宙本身的结构。

这与C字符串**完全相同**，只是实际上是完全不同的。

在C中，字符串是内存中的字节序列，通常包含一组字母。在C中，常量字符串被双引号(`"`)包围。您可能在一些编程大作中见过字符串，比如Hello World：

``` {.c}
#include <stdio.h>

int main(void)
{
    printf("Hello, World!\n");
}
```

你注意到里面的字符串`"Hello, World!\n"`了吗？

那个字符串的类型是什么呢？事实证明，常量字符串（即双引号中的字符串）的类型是`char*`。但是如果愿意，您也可以将字符串放在`char`数组中。`char*`指向字符串中的第一个字符。例如：

``` {.c}
char *s = "Hello!";

printf("%s\n", s);    /* 打印 "Hello!" */
printf("%c\n", *s);   /* 打印 'H' */
printf("%c\n", s[0]); /* 打印 'H' */
printf("%c\n", s[1]); /* 打印 'e' */
printf("%c\n", s[4]); /* 打印 'o' */
```

（注意`printf()`中的两个新的格式说明符：`%c` 用于打印一个 `char`，`%s` 用于打印一个字符串！这不令人兴奋吗？）

看这里，我们以各种不同的方式访问这个字符串。我们打印整个字符串，还打印单个字符。

您还可以在定义时像其他数组一样初始化`char`数组：

``` {.c}
char s[20] = "The aliens are coming!";
```

您还可以通过简单赋值来实时更改数组元素：

``` {.c}
char s[20] = "Give me $10!";

printf("%s\n", s);  /* 打印 "Give me $10!" */

s[9] = '8';
printf("%s\n", s);  /* 打印 "Give me $80!" */
```

在这种情况下，要注意我们将一个常量 `char` 放在赋值语句的右侧。常量 `char` 使用单引号 (`'`)。

还有一件事要记住的是，当你通过名称指定数组时，没有使用方括号，这就像使用指针指向数组的开头一样。因此，您实际上可以执行这样的赋值：

``` {.c}
char a[20] = "Cats are better.";
char *p;

p = a;  /* p现在指向数组 a 中的第一个字符 */
```

还有一件事：C中的字符串以空字符(NUL)结尾。也就是说，是零。它最适当地写为 '\0'。通过将 '\0' 赋给字符串中的第一个字节，您可以将字符串截断为零长度。此外，所有标准字符串函数都假定字符串以空字符结尾。

标准字符串函数，我提到过了吗？是的，我提到了。

C提供了一整套函数，您可以使用这些函数来修改字符串，将它们连接在一起，解析它们等等。查看参考部分，了解您可用的所有出色的字符串处理能力。作为地球公民，您有责任明智地运用这种终极力量！（并支付给我 80 美元。）

# 动态内存 {#dydydynamic}

读者，您今天早上看起来是不是动态的呢？或者是晚上吗？我总是搞混这些东西。

到目前为止，我们一直在讨论程序运行开始时设置的内存。您在各处都有常量字符串，预声明长度的数组以及预先声明的所有变量。但如果您有类似以下的情况呢？

**任务：** 实现一个程序，从键盘读取任意数量的整数。用户输入的第一行将是要读取的 `int` 的数量。这些 `int` 将会出现在接下来的行中，每行一个 `int`。

是的，又到了这个时候了：将其分解成可以实现的组件部分。你需要从键盘读取文本行（这里有一个很酷的函数叫做 `fgets()` 可以帮助这里），并且你需要将第一行转换为一个整数，这样你就知道需要读取多少行了。（你可以使用 `atoi()`，表示 "ascii-to-integer" 来进行这种转换。）然后你需要读取那么多的字符串并且存储它们...存储在哪里呢？

动态内存可以帮助我们——我们需要存储一堆 `int`，但在程序开始运行之后我们不知道需要多少。我们的做法是找出我们需要多少个 `int`，然后计算出每个 `int` 需要多少字节，把这两个数字相乘得到我们需要存储所有内容所需的总字节数，然后要求操作系统在堆上为我们分配这么多字节，以便我们根据自己的选择使用。在这种情况下，我们选择在其中存储 `int`。

这里我们要谈论三个函数。好吧，其实有四个函数，但一个只是另一个的变体：`malloc()`（分配一些内存供我们使用）， `free()`（释放 `malloc()` 先前分配的一些内存），`realloc()`（改变先前分配的一些内存的大小）和 `calloc()`（就像 `malloc()`，只是清除内存为零）。

结合使用这些函数会导致一种繁复而美妙的数据之舞，随着专注用户意志的强大潮汐涌动而往复。

好了。让我们减少噪音，继续下去吧。

## `malloc()` {#mallocg}

这个函数实在太重要了：当你请求内存时，他就是那位为你提供内存的家伙。它会返回一个指向指定字节数的一块内存的指针，如果出现某种错误（比如内存不足），则返回 `NULL`。实际上，返回类型是 `void*`，所以可以转换成你想要的任何类型的指针。

由于 `malloc()` 操作的是字节单位的内存，而你通常操作的是其他数据类型（比如“为我分配 12 个整型变量”），所以人们经常使用 `sizeof()` 运算符来确定要分配多少字节，例如：

``` {.c}
int *p;

p = malloc(sizeof(int) * 12); // 为我分配 12 个整型变量！
```

哦，这基本上就是如何使用 `malloc()` 的一个例子。你可以使用指针算术或数组表示法来引用结果；两种方式都可以，因为它是一个指针。但你真的应该检查结果是否出错：

``` {.c}
int *p;

p = malloc(sizeof(float) * 3490); // 分配 3490 个浮点数！

if (p == NULL) {
    printf("糟糕！我们可能是内存不足了！\n");
    exit(1);
}
```

更常见的做法是，将它写在一行：

``` {.c}
if ((p = malloc(100)) == NULL) { // 分配 100 个字节
    printf("哦哦！内存不足错误！\n");
    exit(1);
}
```

现在记住这一点：你正在在堆上分配内存，只有两种方式可以拿回那块内存：1）程序退出，或者 2）调用 `free()` 释放一个通过 `malloc()` 分配的内存块。如果你的程序运行了很长时间，一直在使用 `malloc()` 分配内存，而却从未在正确时调用 `free()` 释放，那就是所谓的“内存泄漏”。这通常会表现为某种方式，比如“嘿，鲍勃。我一周前启动了你的打印作业监控程序，现在它占用了 13TB 的内存。为什么会这样呢？”

确保避免内存泄漏！在使用完后记得用 `free()` 释放内存！

## `free()` {#gfree}

说到如何释放你分配的内存，你可以使用这个名称不太可信的 `free()` 函数来完成。

这个函数以你用 `malloc()`（或 `calloc()`）得到的指针作为参数。它释放与该数据关联的内存。在调用了 `free()` 后，千万不要再使用这块内存。那样是不对的。

下面举个例子：

``` {.c}
int *p;

p = malloc(sizeof(int) * 37); // 37 个 int！

free(p);  // 仔细想想，还是算了！
```

当然，在 `malloc()` 和 `free()` 之间，你可以随心所欲地处理这块内存。


## `realloc()` {#grealloc}

`realloc()` 是一个有趣的小函数，它接受你用 `malloc()`（或 `calloc()`）分配的内存块，并改变内存块的大小。也许一开始你以为只需要 100 个 int，但现在需要 200 个。你可以使用 `realloc()` 来扩展这个内存块，满足你需要的空间。

这很好，但是如果不能因为某种原因增加当前内存块的大小，`realloc()` 可能会需要将你的数据移动到内存的另一个位置。毕竟它并不全能。

对于你这个凡人而言，这意味着你应该谨慎使用`realloc()`，因为这可能是昂贵的操作。通常的做法是跟踪内存块中有多少空间，然后在用完时添加另一个大块空间。所以首先你会分配你猜测足够容纳所需所有数据的空间，然后如果你用完了，就会用下一个最佳猜测重新分配该块空间来容纳你未来可能需要的数据。什么是一个好的猜测取决于程序。下面是一个例子，它只是根据需要分配更多的 "桶" 空间：

``` 
#include <stdlib.h>

#define INITIAL_SIZE 10
#define BUCKET_SIZE 5

static int data_count; // 我们已存储的整数数量
static int data_size;  // 在这个块中我们 *可以* 存储的整数数量
static int *data;      // 数据块本身

int main(void)
{
    void add_data(int new_data); // 函数原型
    int i;

    // 首先，初始化数据区域：
    data_count = 0;
    data_size = INITIAL_SIZE;
    data = malloc(data_size * sizeof(int)); // 分配初始区域

    // 现在添加一大堆数据
    for(i = 0; i < 23; i++) {
        add_data(i);
    }
}

void add_data(int new_data)
{
    // 如果 data_count == data_size，则该区域已满，需要在添加另一个数据之前重新分配它：

    if (data_count == data_size) {
        // 我们已经满了，所以添加一个桶
        data_size += BUCKET_SIZE;
        data = realloc(data, data_size * sizeof(int));
    }

    // 现在存储数据
    *(data+data_count) = new_data;

    // ^^^ 上面一行也可以使用数组表示法，就像这样：
    //  data[data_count] = new_data;

    data_count++;
}
```

在上面的代码中，你可以看到一个可能昂贵的`realloc()`只有在存储了前10个`int`之后才会执行，然后再在每五个`int`块之后执行一次。这比每次添加一个数字时执行`realloc()`要好得多。

（是的，在那个完全虚构的例子中，因为我知道我一开始就要添加23个数字，将`INITIAL_SIZE`设置为25或其他值会更有意义，但这样做违背了例子的目的，不是吗？）

## `calloc()` {#gcalloc}

由于你已经阅读了关于`malloc()`的部分（你阅读了，对吧？），这部分会很简单！太棒了！下面是重点：`calloc()`就像`malloc()`一样，只是1）为您清零了内存，2）它接受两个参数而不是一个。

这两个参数分别是内存块中的元素数量，以及每个元素的大小。是的，这与我们在`malloc()`中做的一样，只是`calloc()`帮你做了乘法：

``` {.c}
// 这样：
p = malloc(10 * sizeof(int));

// 就像这样：
p = calloc(10, sizeof(int));
//（使用calloc()时内存被清零）
```

`calloc()`返回的指针可以与`realloc()`和`free()`一起使用，就像你使用`malloc()`一样。

使用`calloc()`的缺点在于清零内存需要时间，在大多数情况下，你并不需要清零，因为你会覆写它。但如果你发现自己在`malloc()`一个块然后立即将内存清零，你可以使用`calloc()`来一次完成这个过程。

我希望关于 `calloc()` 的部分更加有趣，像好莱坞的电影那样有情节、激情和暴力，但是...我们谈论的是C编程。这本身就应该很令人兴奋。抱歉！

# 更多内容！{ #morestuff}

这是一个我们详细阐述之前做过的一堆事情的部分，甚至为了进一步探讨，我们还加入了一些新东西。您可以按任何顺序阅读这些部分，按您认为需要的方式阅读。

## 指针算术 {#ptarith}

指针_什么_？是的，没错：您可以对指针进行数学运算。不过，这样做意味着什么呢？嗯，注意听，因为人们经常使用_指针算术_来操作指针并在内存中移动。

您可以对指针进行加法和减法运算。如果您有一个指向 `char` 的指针，递增该指针将移动到内存中的下一个 `char`（向上移动一个字节）。如果您有一个指向 `int` 的指针，递增该指针将移动到内存中的下一个 `int`（这可能是向上四个字节，或者根据CPU架构的不同移动到其他位置）。重要的是要知道，它移动的内存字节数取决于指针的类型，但实际上这一切都已为您处理好了。

``` {.c}
/* 此代码输出: */
/*  50               */
/*  99               */
/*  3490             */

int main(void)
{
    int a[4] = {50, 99, 3490, 0};
    int *p;

    p = a;
    while (*p > 0) {
        printf("%i\n", *p);
        p++; /* 移动到内存中的下一个 int */
    }
}
```

我们做了什么！这怎么打印出数组中的值呢？
首先，我们将`p`指向数组的第一个元素。
然后我们会循环直到`p`指向的元素小于或等于零。在循环内，我们打印`p`指向的值。最后，_这里是棘手的部分_，我们会增加指针。这会导致指针移动到内存中的下一个`int`，这样我们就可以打印它。

在这种情况下，我随意决定（是的，令人震惊地真实：我只是编造了这些）用零值标记数组的末尾，这样我就知道何时停止打印。这被称为_哨兵值_...也就是说，某种让你知道某些数据何时结束的东西。如果这听起来很熟悉，那是因为你刚在字符串部分看到过。记住---字符串以零字符 (`'\0'`) 结尾，并且字符串函数使用这个作为哨兵值来知道字符串的结束位置。

很多时候，你会看到`for`循环用来处理指针的东西。例如，这里是一些复制字符串的代码：

``` {.c}
char *source = "Copy me!";
char dest[20];  /* 我们会将该字符串复制到这里 */

char *sp;  /* 源指针 */
char *dp;  /* 目标指针 */

for(sp = source, dp = dest; *sp != '\0'; sp++, dp++) {
    *dp = *sp;
}

printf("%s\n", dest); /* 输出 "Copy me!" */
```

看起来复杂！这里新的东西是_逗号操作符_（`,`）。逗号操作符允许你将表达式组合在一起。表达式的总值是逗号后的最右表达式，但是表达式的所有部分都会被从左到右评估。

所以让我们拆解这个`for`循环看看发生了什么。在初始化部分，我们将`sp`和`dp`指向源字符串和我们将要复制到的目标区域。

在循环的体中，实际的复制操作发生了。我们使用赋值操作符，将源指针指向的字符复制到目标指针指向的地址。因此，我们将逐个字母地复制字符串。

`for` 循环的中间部分是继续条件---我们在这里检查源指针是否指向一个我们知道存在于源字符串末尾的空字符。当然，一开始，它指向的是 `'C'`（"Copy me!" 字符串中的 'C'），所以我们可以继续执行。

在`for`语句的结尾，我们将同时递增 `sp` 和 `dp` 来移动到下一个要复制的字符。复制，复制，复制！

## `typedef` {#typedef}

这个不太难理解，但它还有一些你可能在实践中见到的奇怪细微之处。基本上，`typedef` 允许你为某种类型取一个别名，这样你可以用这个名字来引用它。

为什么要这样做呢？最常见的原因是另一个名字有点笨拙，你想要一个更简洁的名字...这种情况最常发生在你有一个想要使用的 `struct` 时。

```{.c}
struct a_structure_with_a_large_name {
    int a;
    float b;
};

typedef struct a_structure_with_a_large_name NAMESTRUCT;

int main(void)
{
    /* 我们可以像这样创建一个结构的变量： */
    struct a_structure_with_a_large_name one_variable;

    /* 或者，我们可以这样做： */
    NAMESTRUCT another_variable;
}
```

在上面的代码中，我们定义了一个类型，`NAMESTRUCT`，可以替代另一个类型，`struct a_structure_with_a_large_name`。请注意，这现在是一个完整的类型；你可以在函数调用或任何你会使用“正常”类型的地方使用它。（不要告诉`typedef`的类型它们不是正常的---这是不礼貌的。）

你可能也想知道为什么新类型名是全大写。在C中，按照传统，`typedef`的类型一直都是用全大写表示（这当然并非必需的）。在C++中，情况已经不再如此，人们更多地使用混合大小写。由于这是一本C指南，我们将坚持老方式。

（你可能经常看到的一个东西是在`typedef`中`struct`标签名前有一个下划线。尽管从技术上讲这是不合法的，许多程序员喜欢为`struct`和新类型使用相同的名称，并在那里加上下划线用来在视觉上区分两者。但你不应该这样做。）

你也可以`typedef`“匿名”的`struct`，就像这样

``` {.c}
typedef struct {
    int a;
    float b;
} someData;
```

然后你就可以将变量定义为类型`someData`。非常令人兴奋。

## `enum` {#enum}

有时你有一系列数字，想用它们代表不同的事物，但对于程序员，通过名称而不是数字来表示这些事物更容易。你可以使用`enum`为整数值创建符号名称，程序员可以在代码中使用这些符号名称代替`int`。

（我应该指出，相对于C++，C在使用`int`和`enum`之间更加宽松。不过在这里我们将遵循C的方式，开心地处理。）

请注意`enum`也是一种类型。你可以将其`typedef`，可以将它们传递给函数等，就像“正常”类型一样。

这是一些枚举和它们的用法。记住---大致上要对待它们就像 `int`s 一样。

``` {.c}
enum fishtypes {
    HALIBUT,
    TUBESNOUT,
    SEABASS,
    ROCKFISH
};

int main(void)
{
    enum fishtypes fish1 = SEABASS;
    enum fishtypes fish2;

    if (fish1 == SEABASS) {
        fish2 = TUBESNOUT;
    }
}
```

不难理解---它们只是唯一数字的符号名称。基本上它们更容易让其他程序员阅读和维护。

现在，你可以使用 `%d` 在`printf()`中打印它们。大部分情况下，你并不需要知道实际的数值；通常你只想要符号表示。

但是，因为我知道你很好奇，我干脆告诉你`enum`默认从零开始增加。所以在上面的例子中，`HALIBUT`将是0，`TUBESNOUT`将是1，`ROCKFISH`将是3。

如果你想的话，你可以重写任何或所有这些：

``` {.c}
enum frogtypes {
    THREELEGGED=3,
    FOUREYED,
    SIXHEADED=6
};
```

在上面的例子中，两个枚举是显式定义的。对于`FOUREYED`（未定义），它只是从上一个定义的值递增一个，所以它的值是4。如果你好奇的话，你可以拥有重复的值，但你为什么要这样呢，变态？

## 更多的 `struct` 声明 {#morestruct}

还记得很久以前我提到过有多种方式去声明`struct`，并且并不都有很大意义。我们已经看到了如何在全局声明一个`struct`以后使用，以及在`typedef`情况下如何声明一个，就像这样：

``` {.c}
/* standalone: */

struct antelope {
    int legcount;
    float angryfactor;
};

/* or with typedef: */
```

``` {.c}
typedef struct _goatcheese {
    char victim_name[40];
    float cheesecount;
} GOATCHEESE;
```

但是你也可以在`struct`声明后直接声明变量:

``` {.c}
struct breadtopping {
    enum toppingtype type; /* BUTTER, MARGARINE or MARMITE */
    float amount;
} mytopping;

/* 就像之后声明的方式一样: */

struct breadtopping mytopping;
```

所以我们将变量定义粘贴在`struct`定义的尾部。相当狡猾，但你会在所谓的“现实生活”中不时看到这种情况。

就在你以为你已经掌握全部内容的时候，实际上在许多情况下你可以省略`struct`的名称。例如:

``` {.c}
typedef struct { /* <--嘿! 我们漏掉了名字! */
    char name[100];
    int num_movies;
} ACTOR_PRESIDENT;
```

尽管只使用`typedef`的名字而不使用正确的名字也是更正确的方式，但你仍然在这里那里看到那些裸露的`struct`s。

## 命令行参数 {#clargs}

我一直在欺骗你，我必须承认。我以为我能隐瞒不被发现，但你意识到了一些不对劲的地方...为什么`main()`函数没有返回类型或参数列表？

其实，很久以前，出于某种原因，!!!TODO 研究一下!!! 这是完全可以接受的。并且一直延续至今。随意这样做，事实上， 但这并没有告诉你整个故事，现在是时候让你知道“整个真相”了！

欢迎来到现实世界:

``` {.c}
int main(int argc, char **argv)
```

哇！那是什么东西？在我告诉你之前，你必须意识到，当程序从命令行执行时，它接受来自命令行程序的参数，并将结果返回给命令行程序。在许多Unix shell中，你可以通过shell变量 `$?` 获取程序的返回值。（这甚至在Windows命令行中无法使用---用 !!!TODO查看Windows返回变量!!! 替代）。你可以在程序名之后的命令行上指定参数给程序。所以如果你有一个叫做 "makemoney" 的程序，你可以用参数运行它，然后检查返回值，就像下面这样：

```shell
$ makemoney fast alot
$ echo $?
2
```

在这种情况下，我们传递了两个命令行参数，"fast" 和 "alot"，并且在变量 `$?` 中获得了一个返回值，我们使用了Unix的 `echo` 命令打印了出来。程序是如何读取这些参数，并返回那个值的呢？

让我们先来做简单的部分：返回值。你可能已经注意到了上面 `main()` 的原型返回一个 `int`。好了！所以你只需要从 `main()` 中的某个地方 `return` 这个值，或者，作为替代，你可以调用带有退出值作为参数的函数 `exit()`：

``` {.c}
int main(void)
{
    int a = 12;

    if (a == 2) {
        exit(3); /* 就像运行（从 main() 中） "return 3;" 一样 */
    }

    return 2; /* 就像调用 exit(2); 一样 */
}
```

出于历史原因，退出状态码为 `0` 表示成功，而非零表示失败。其他程序可以检查你的程序的退出状态并做出相应的反应。

好的，这是返回状态。那么这些参数呢？嗯，整个`argv`的定义看起来太吓人，不适合初学者。那么这个`argc`呢？只是一个`int`，而且还是一个很简单的。它包含了命令行中参数的总数，_包括程序自身的名称_。例如：

```shell
$ makemoney fast alot         # <-- argc == 3
$ makemoney                   # <-- argc == 1
$ makemoney 1 2 3 4 5         # <-- argc == 6
```

（上面的美元符号是常见的Unix命令提示符。井号(`#`)是Unix中的命令提示符注释字符。我是Unix迷，所以你得接受。如果你有问题，去找那些友好的冲锋队员们吧。）

很好，很好。`argc`的事情也不难。现在轮到大问题了：`argv`。你可能已经猜到，这里存储着参数本身。但是那个`char**`类型怎么办？你要怎么使用它？幸运的是，你通常可以在解引用的地方使用数组表示法，因为你可能记得数组和指针是相关的。在这种情况下，你可以将`argv`看作是指向字符串的指针数组，其中每个指向的字符串都是命令行参数之一：

```shell
$ makemoney   somewhere  somehow
$ # argv[0]    argv[1]   argv[2]   (且 argc 为 3)
```

这些数组元素，`argv[0]`、`argv[1]`等等，都是字符串。 （记住一个字符串只是`char`指针，或者是`char`数组，其名称是数组的第一个元素的指针。）

我还没有告诉你关于字符串的许多用法，但是请查看参考部分获取更多信息。你已经知道如何使用"`%s`"格式说明符进行字符串的`printf()`，也知道如何使用循环。因此，让我们编写一个程序，简单地打印出其命令行参数，然后将退出状态值设置为4：

请注意，我们从索引1开始打印参数，因为在此之前我们已经打印了`argv[0]`。假设我们将此编译成一个名为`showargs`的程序，这是示例运行和输出：

```shell
$ showargs alpha bravo
There are 3 things on the command line
The program name is "showargs"
The arguments are:
    alpha
    bravo

$ showargs
There are 1 things on the command line
The program name is "showargs"
The arguments are:

$ showargs 12
There are 2 things on the command line
The program name is "showargs"
The arguments are:
    12
```

（`argv[0]`中的实际内容在不同系统中可能有所不同。有时它会包含一些路径信息或其他内容。）

这就是从命令行将东西传递到程序中的秘诀！

## 多维数组

欢迎来到......第 N 维度！ 你肯定没想到会看到这个吧。嗯，我们就在这里。是的。第 N 维度。

好的。那么，你已经看到了如何使用数组在内存中排列数据序列。它看起来是这样的：

现在，想象一下，您会看到一个元素的 _grid_，而不仅仅是一个单独的行：

这是一个 _二维数组_ 的示例，可以通过提供行号和列号作为索引来索引它，就像这样：`a[2][10]`。您可以在数组中拥有任意多个维度，但我不打算绘制它们，因为二维已经超出了我的艺术技能的限制。

所以看看这段代码---它创建了一个二维数组，在定义中进行了初始化（看如何在初始化期间嵌套了花括号），然后使用 _嵌套循环_（也就是，在另一个循环内部的循环）来遍历所有元素并将其漂亮地打印到屏幕上。

``` {.c}
#include <stdio.h>

int main(void)
{
    int a[2][5] = { { 10, 20, 30, 40, 55 },  /* [2][5] == [行][列] */
                    { 10, 18, 21, 30, 44 } };

    int i, j;

    for(i = 0; i < 2; i++) {     /* 对于所有的行... */
        for(j = 0; j < 5; j++) { /* 打印所有的列！ */
            printf("%d ", a[i][j]);
        }

        /* 在行末尾，打印一个换行符，表示新的一行 */
        printf("\n"); 
    }
}
```

正如您可能想象的那样，由于这个程序实在太简单了，没有出人意料的结尾，输出会类似于这样：

```shell
10 20 30 40 55
10 18 21 30 44
```

稍等片刻，因为我们将对这个概念进行探讨，学习更多关于数组在内存中是如何存储的，并一些访问它们的技巧。首先，您需要知道，在上一个示例中，即使数组有两行且是多维的，数据是按顺序存储在内存中的，顺序为：10, 20, 30, 40, 55, 10, 18, 21, 30, 44。

看到这个了吗？编译器就像一个接一个地放置一行并继续进行。

但是嘿！那不就像一维数组吗？是的，从技术上讲大部分都是！很多程序员根本就不会去烦恼多维数组，只使用一维数组，手动计算来找到特定的行和列。从技术上讲，你不能随心所欲地切换维度，Buccaroo Bonzai，因为类型是不同的。而且这样做也是不好的。

例如...别管“例如”。让我们再用单维数组做同样的例子：

``` {.c}
#include <stdio.h>

int main(void)
{
    int a[10] = {   10, 20, 30, 40, 55,  /* 10个元素 (2x5) */
                    10, 18, 21, 30, 44 };

    int i, j;

    for(i = 0; i < 2; i++) {     /* 对于所有行... */
        for(j = 0; j < 5; j++) { /* 打印所有列！ */
            int index = i*5 + j; /* 计算索引 */
            printf("%d ", a[index]);
        }

        /* 在行末，为下一行打印一个换行符 */
        printf("\n"); 
    }
}
```

所以在循环的中间我们声明了一个局部变量`index`（是的，你可以这样做——记住局部变量是局限于它们所在的块内（也就是说，局限于它们周围的花括号）），我们使用`i`和`j`来计算它。仔细看看这个计算确保它是正确的。这从技术上讲就是在你使用多维数组表示法访问数组时编译器在你背后做的事情。

## 强制转换和提升 {#cast}

有时你有一个类型，你希望它成为另一种类型。这里有一个很好的例子：

``` {.c}
    struct Company *cp;  /* declares a pointer to Company */
```

在这里，我们声明了一个指向 `Company` 结构体的指针，但实际上并没有在 `main()` 函数中定义 `Company` 结构体。【cp:指向 Company 结构体的指针】

【打印输出的代码块中的注释：计算 5 除以 10】

``` {.c}
struct foo;  /* 不完整的类型！注意它是不完整的。 */

int main(void)
{
    struct foo *w;

    w = get_next_wombat(); /* 抓取一只袋獾 */
    process_wombat(w);     /* 在某处使用它 */
}
```

为了告诉你，假如你发现自己试图包含一个包含另一个包含相同头文件的头文件，或者你的构建持续很久是因为你包含太多头文件，或者...更有可能的是你会看到类似"不能引用不完整的类型"的错误。这个错误意味着你尝试对不完整的类型做太多事情（比如尝试解引用它或使用其中的字段），你需要`#include`正确的包含了完整声明`struct`的头文件。

## `void` 指针 {#voidp}

欢迎来到 _虚空_！就像 Neo Anderson 会说的那样，"……哇。" 这个`void`是什么东西？

停下！在你困惑之前，`void`指针并不等同于函数返回值的`void`或参数列表中的`void`。我知道这可能会让人困惑，但就是这样。等我们讨论所有你可以使用`static`关键字的方式之后再说吧。

`void`指针是 _指向任意类型的指针_。它会自动转换为你分配给它的类型，或者从中赋值给其他类型。为什么会想要使用这样的东西呢？我的意思是，如果你要解引用一个指针以获取原始值，难道编译器不需要知道指针的类型以便正确使用吗？

是的。是的，它需要。因此，你不能解引用`void`指针。这是违法的，C 警察会比你说个没完的 Jack Robinson 更快地赶到你家门口。在你使用之前，你必须将其转换为另一种指针类型。

这究竟有什么用？为什么你会想要一个你不知道类型的指针呢？

规格说明:编写一个函数，可以将 _ 任何类型 _ 的指针附加到数组中。还要编写一个可以为特定索引返回特定指针的函数。

因此，在这种情况下，我们将编写一些有用的小函数来存储指针，并稍后返回它们。这个函数必须是 _ 类型不可知 _ 的，也就是说，它必须能够存储任何类型的指针。这在许多用于操控数据的代码库中是一种相当常见的特性---很多函数使用 `void` 指针，这样它们可以与程序员可能想要的任何类型的指针一起使用。

通常，我们会编写一个链表或类似的东西来保存这些指针，但这超出了本书的范围。因此，在这个简单的示例中，我们将使用一个数组。嗯。也许我应该写一本关于数据结构入门的书...

总之，规格要求两个函数，那么我们就在这里着手实现它们：

``` {.c}
#include <stdio.h>

void *pointer_array[10]; /* 我们可以保存最多 10 个 void 指针 */
int index=0;

void append_pointer(void *p)
{
    pointer_array[index++] = p;
}

void *get_pointer(int i)
{
    return pointer_array[i];
}
```

因为我们需要将这些指针存储在某个地方，所以我提前创建了一个全局指针数组，可以从这两个函数中访问它们。此外，我创建了一个全局索引变量，以记住下一个附加到数组中的指针存储位置。

看看 `append_pointer()` 函数的代码。怎么把所有内容挤在一行里呢？好吧，当我们追加时需要做两件事：存储当前索引处的数据，并将索引移动到下一个可用位置。我们使用赋值运算符复制数据，然后注意到我们使用了 _后自增_ 运算符(`++`) 来增加索引。记住 _后_ 自增的意思吗？这意味着增量在表达式的其余部分被评估之后才会执行，包括那个赋值。

另一个函数 `get_pointer` 简单地返回指定索引 `i` 处的 `void*`。要注意的是这两个函数的返回类型之间微妙的差异。其中一个声明为 `void`，意味着它不返回任何东西，另一个声明了返回类型为 `void*`，意味着它返回一个 `void` 指针。我知道，我知道，重复的使用有点麻烦，但你会很快习惯的。要不然！

最后，我们已经编写了代码——现在我们该如何真正使用它呢？让我们编写一个 `main()` 函数，来使用这些函数：

``` {.c}
int main(void)
{
    char *s = "一些数据！";  /* s 指向一个常量字符串 (char*) */
    int a = 10;
    int *b;

    char *s2;  /* 在调用 get_pointer() 后我们将把它们存储在这里 */
    int *b2;

    b = &a; /* b 是指向 a 的指针 */

    /* 现在让我们把它们都存储起来，尽管它们是不同的类型 */
    append_pointer(s);
    append_pointer(b);

    /* 它们已经存储了！让我们把它们拿回来！ */
    s2 = get_pointer(0); /* 这是在索引 0 处的数据 */
    b2 = get_pointer(1); /* 这是在索引 1 处的数据 */
}
```

看看通过 `void*` 可互换指针类型？C 将允许你毫不留情地将 `void*` 转换为任何其他指针，确保将它们转换回原始类型取决于你。是的，你可能犯错导致程序崩溃，你最好相信这一点。就像人们说的那样，“C 提供足够的绳子让你自己去绞死自己。”


## `NULL` 指针

我想我在飞机降落前有足够时间谈谈关于指针的 `NULL`。

`NULL` 简单地表示指向空的指针。有时候知道指针是否有效或者是否需要初始化很有用。`NULL` 可以用作各种不同情况下的标记值。记住：它的意思是“这个指针指向空”！例如：

``` {.c}
int main(void)
{
    int *p = NULL;

    if (p == NULL) {
        printf("p 尚未初始化！\n");
    } else {
        printf("p 指向 %d\n", *p);
    }
}
```

请注意，在声明指针时，指针并没有预先初始化为 `NULL`，你必须明确地进行初始化。（所有非静态局部变量都不会被预初始化，包括指针。）


## 更多关于静态

现代技术已经安全地将我带到了 LAX，我可以在等待前往爱尔兰的飞机时继续写作。告诉我你至少在某种程度上不嫉妒，否则我是不会相信的。

但足够谈到我了；让我们继续谈论编程。（对于一个极客的搭讪方式来说怎么样？如果你用了，做我一个忙就是不要归功于我。）

你已经看到了如何使用`static`关键字来使局部变量在其所属函数的多次调用之间保持不变。但是，`static`还有其他令人兴奋且完全无关的用途，这些用途可能值得有自己的关键字，但实际上没有。你只需习惯于这样一个事实，即`static`（以及C语言中的许多其他内容）在不同的语境中具有不同的含义。

那么，如果你在全局范围将某个东西声明为`static`呢，而不是在函数的局部范围？毕竟，全局变量已经在程序的整个生命周期中存在，所以这里的`static`不能意味着相同的事情。相反，在全局范围中，`static`意味着声明为`static`的变量或函数_仅在这个特定的源文件中可见_，并且不能从其他源文件引用。再次强调，这个`static`的定义仅适用于全局范围。在函数的局部范围中，`static`仍然具有相同的旧含义。

你会发现，你的大型项目本身也可以分解为更大的、可以容纳小的片段的片段（就像那幅小鱼被大鱼吞掉，而大鱼又被更大的鱼吞掉的图片一样）。当你有足够多相关的小片段时，将它们放在自己的源文件中通常是有意义的。

我将从关于[`void`指针](#voidp)部分中提取示例，在那里我们有一对可以用来存储任何类型指针的函数。

该示例程序存在许多问题（存在各种缺陷和错误）。我们声明了一个名为 `index` 的全局变量。现在，“index”是一个非常常见的词，很可能在项目的其他地方，某人会自己新建一个同名的变量。这可能会引发各种问题，其中之一是他们可以修改你的 `index` 值，而这对你非常重要。

一个解决方法是将所有内容放在一个源文件中，然后将 `index` 声明为 `static` 全局变量。这样，除了在你的源文件中，外部没有人可以使用它。你是王者！`static` 是一种保留代码实现细节不被他人知晓的方式。相信我，如果让其他人干预你的代码，他们会肆意嬉戏！巨锤砸！

这里是对代码的快速重写，将其放入独立的文件中：

``` {.c}
/** 文件 parray.c **/

static void *pointer_array[10]; /* 现在除了本文件，其他人都无法看见它！ */
static int index=0; /* 对于这个变量也一样！ */

/* 但这些函数不是 static 的， */
/* 所以它们可以从其他文件中使用： */

void append_pointer(void *p)
{
    pointer_array[index++] = p;
}

void *get_pointer(int i)
{
    return pointer_array[i];
}

/** 文件 parray.c 结束 **/
```

接下来合适的做法是创建一个名为 `parray.h` 的文件，里面放置这两个函数的函数原型。然后包含有 `main()` 的文件可以 `#include` `parray.h` 并在链接时使用这些函数。

## 典型的多文件项目{#multifile}

就像我经常说的那样，项目通常会变得过于庞大，无法放在一个文件中，非常类似于《黏怪物》（The Blob）变得巨大，并且必须被史蒂夫·麦奎因（Steve McQueen）击败。不幸的是，麦奎因已经成功逃离到天堂，无法在这里帮助你处理你的代码。对不起。

所以当你拆分项目时，你应该尝试将其分成合适的、适合放在单独文件中的模块。例如，负责计算快速傅里叶变换（对于不熟悉的人来说，这是一个数学概念）的所有代码，可以成为拥有自己源文件的良好候选。或者，控制特定游戏中某个AI机器人的所有代码可以放在自己的文件中。这更像是一个指导方针，而不是一个规则，但如果某些东西与你当前所在的特定源文件中的内容没有至少某种关联，也许它应该放到其他地方。对于这种情况，一个完美的说明性问题可能是："3D渲染代码为什么出现在声音驱动程序代码中间？"

当你将代码移到它自己的源文件中时，几乎总会有一个相应的头文件需要编写。新源文件中的代码（将是一堆函数）需要有原型和其他内容对其他文件可见，以便它们可以被使用。其他源文件使用其他文件的方式是通过`#include`它们的头文件。

所以例如，我们来编写一组小函数，并将它们放在一个名为`simplemath.c`的文件中：

``` {.c}
/** 文件 simplemath.c **/

int plusone(int a)
{
    return a+1;
}

int minusone(int a)
{
    return a-1;
}

/**  simplemath.c 文件结尾  **/
```

一些简单的函数。没有什么太复杂的，对吧？但是单独来说，它们没有太多用处，为了让其他人能够使用它们，我们需要在一个头文件中分发它们的原型。准备好接受这个...你应该能够在其中识别出原型，但我添加了一些新内容：

``` {.c}
/** 文件 simplemath.h **/

#ifndef _SIMPLEMATH_H_
#define _SIMPLEMATH_H_

/* 这里是原型： */

int plusone(int a);
int minusone(int a);

#endif

/** end of file simplemath.h **/
```

令人讨厌。那些 `#ifndef` 是什么意思？ 还有 `#define` 和 `#endif`？它们是_样板代码（即，通常会粘贴在一个文件中的代码）_，用于防止头文件被多次包含。

逻辑的简单版本是这样的：如果符号 `_SIMPLEMATH_H_` 没有定义，则定义它，然后执行所有正常的头部工作。否则，如果符号 `_SIMPLEMATH_H_` 已经定义了，就不做任何操作。这样一来，头文件的大部分内容只会在构建时被包含一次，无论有多少其他文件尝试包含它。这是个好主意，因为重新包含它充其量是多余的时间浪费，最糟糕的情况下，可能会导致编译时错误。

好了，我们有头文件和源文件，现在是时候编写一个带有 `main()` 的文件了，这样我们就可以真正使用这些东西：

``` {.c}
/** 文件 main.c **/

#include "simplemath.h"

int main(void)
{
    int a = 10, b;

    b = plusone(a);  /* 让处理器动起来！ */
}

/** end of file main.c **/
```

看这个！我们在`#include`中使用双引号而不是尖括号！这告诉预处理器，“包含当前目录中的这个文件，而不是标准系统目录中的文件。” 我假设你为了这个练习的目的将所有这些文件放在同一个地方。

回想一下，包含一个文件就像在那个地方引入它一样，因此，我们在那里将原型引入源文件，然后函数就可以自由地在`main()`中使用了。太棒了！

最后一个问题！我们如何实际构建整个项目？从命令行：

```shell
$ cc -o main main.c simplemath.c
```

您可以在命令行上一次性列出所有源文件，它们将一起构建，非常简单。

## 万能的C预处理器 {#cpp}

还记得大约一百万年前，你刚开始阅读这篇指南时我提到过菠菜的事吗？没错——你还记得菠菜如何与整个计算过程相关联吗？

当然你不记得。我刚编了一个故事；我从来没有在这篇指南中提到过菠菜。我是说，得了吧。菠菜跟什么有关系啊？唉！

让我带你转移到一个不那么叶绿的话题：C预处理器。顾名思义，这个小程序将在C编译器看到源代码之前处理源代码。这样你就可以更多地控制编译哪些内容以及如何编译。

你已经看到了最常见的预处理指令之一：`#include`。指南的其他部分已经涉及到了各种其他指令，但我们将它们全部列在这里，以供娱乐。

### `#include` {#cppinclude}

众所周知的`#include`指令是从另一个文件中引入源代码。这另一个文件在几乎每种情况下都应该是一个头文件。

在每个系统上，有许多标准的包含文件，可以用于各种任务。最流行的是，你可能见过`stdio.h`被使用。系统如何知道在哪里找到它呢？
每个编译器都有一组目录，当你在尖括号中指定文件名时，它会在这些目录中寻找头文件。（在Unix系统上，它通常会搜索`/usr/include`目录。）

如果你想包含与源文件在同一目录中的文件，在文件名周围使用双引号。下面是一些示例：

``` {.c}
/* 从系统包含目录中包含： */

#include <stdio.h>
#include <sys/types.h>

/* 从本地目录中包含： */

#include "mutants.h"
#include "fishies/halibut.h"
```

从这个示例中你可以看到，你还可以指定一个相对路径到主目录之外的子目录。（在Unix中，再次，有一个名为`types.h`的文件在目录`/usr/include/sys`中。）

### `#define` {#cppdefine}

`#define` 是C语言中功能较为强大的一个预处理指令。通过它，你可以声明常量，在编译器看到源代码之前就将其替换进去。假设你的程序中到处都散落着很多常量，每个数字都是_硬编码_进去的（也就是说，数字是直接在代码中明确写出的，比如 "2"）。

现在，当你写下这个数字时，你认为它是一个常量，因为你得到这个规范的人对你发誓，如果这个数字不是 "2"，就判处他们终生盲目并遭受酷刑。

听起来不错。而且如果这个数字真的改变了，你甚至有人可以指责，而且看起来它可能永远不会改变，因为他们看起来如此确信。

_不要犯傻。_

规格将会改变，在你大概把数字“2”放在源代码的三十万处后，他们会说，“你知道吗？数字二不够用——我们需要三。这是一个难以修改的改变吗？”

不管是谁的责任，最终都是你必须去修改。一个好的程序员会意识到像这样硬编码数字并非一个好主意，解决方案之一是使用 `#define` 指令。看看这个例子：

``` {.c}
#define PI 3.14159265358979  /* 比你能想象的派还多 */

int main(void)
{
    float r =10.0;

    printf("pi: %f\n", PI);
    printf("pi/2: %f\n", PI/2);
    printf("area: %f\n", PI*r*r);
    printf("circumference: %f\n", 2*PI*r);
}
```
（按照约定，通常 `#define` 全部使用大写字母。） 所以，嘿，我们刚刚把那个东西打印出来就像它是一个 float一样。嗯，它确实是一个 float。记住——C 预处理器在编译器看到之前就替换了 `PI` 的值。这就如同你自己在那里键入一样。

现在假设你在所有地方都使用了 `PI`，现在你几乎准备好发布了，设计师们来找你说，“所以，这个派的东西，嗯，我们觉得应该是四而不是三点一什么的。这个修改难吗？”

在这种情况下没有问题，不管修改请求多么不合常理。你所需要做的就是修改顶部的一个 `#define`，然后当 C 预处理器运行时，整个代码中的值会自动更改：

``` {.c}
#define PI 4.0  /* 不管你说什么的都行 */
```

挺酷的，是吧。嗯，也许不如“酷”那么好，
但你还没有见识到完全可运行的预处理器指令的毁灭力量！你实际上可以使用 `#define` 来编写一些小的 _宏_，
它们就像预处理器在C编译器看到代码之前要评估的微型函数一样。要创建这样一个宏，你需要提供一个参数列表（没有类型，因为预处理器对类型一无所知），
然后列出如何使用它。例如，如果我们想要一个宏，它会计算通过传入的数字乘以3490的结果，我们可以这样做：

``` {.c}
#define TIMES3490(x) ((x)*3490)    /* 注意，没有分号！ */

void evaluate_fruit(void)
{
    printf("40 * 3490 = %d\n", TIMES3490(40));
}
```

在这个例子中，预处理器将会将该宏 _展开_，使其对编译器看起来像这样：

``` {.c}
void evaluate_fruit(void)
{
    printf("40 * 3490 = %d\n", ((40)*3490));
}
```

（实际上，预处理器可以进行基本的数学运算，所以它可能会直接简化为“139600”。但这是我的示例，我愿意如何来做！）

现在给你一个问题：你是不是盲目相信需要在宏中使用所有这些括号，就像是某种LISP超级英雄，还是在想，“为什么我要浪费宝贵的时间输入所有这些括号呢？”

嗯，_应该_ 要考虑这个问题！事实证明，在一些情况下，你可能会在毫无察觉的情况下通过宏实际生成一些 _邪恶_ 代码。看看下面这个编译无问题的例子：

``` {.c}
#define TIMES3490(x) x*3490

void walrus_discovery_unit(void)
{
    int tuskcount = 7;

    printf("(tuskcount+2) * 3490 = %d\n", TIMES3490(tuskcount + 2));
}
```

这里有什么问题？我们在计算`tuskcount+2`，然后通过`TIMES3490()`宏。但看看它展开成什么：

``` {.c}
printf("(tuskcount+2) * 3490 = %d\n", tuskcount+2*3490);
```

我们实际计算的是`tuskcount+(2*3490)`，因为乘法在运算顺序中位于加法之前！加上这么多额外的括号可以防止这种情况发生。因此，有良好编程习惯的程序员会自动在宏中参数变量的每次使用及宏外部加上一对括号。

### `#if` 和 `#ifdef`

C预处理器可以使用一些条件语句来丢弃代码块，使编译器看不到它们。 `#if` 指令类似于C中的 `if`，你可以向它传递一个要评估的表达式。 当你不希望构建时，它通常用于阻止大量代码块的构建，类似于注释：

``` {.c}
void set_hamster_speed(int warpfactor)
{
#if 0
    哎呀，这部分代码还没有写。真应该有人写一下。
#endif
}
```

在C中不能嵌套注释，但你可以随意嵌套 `#if` 指令，因此对此非常有帮助。

另一种条件语句 `#ifdef` 在所需宏已经定义的情况下为真。还有一个负向版本的指令叫 `#ifndef`（"如果未定义"）。 `#ifndef` 在头文件中常用于避免多次包含：

``` {.c}
/** 文件 aardvark.h **/

#ifndef _AARDVARK_H_
#define _AARDVARK_H_

int get_nose_length(void);
void set_nose_length(int len);

#endif

/** 文件末尾 aardvark.h **/
```

第一次包含这个文件时，`_AARDVARK_H_` 还未定义，因此它继续到下一行，并定义它，然后进行一些函数原型声明，在结尾处你会看到整个`#if`类型指令以`#endif`语句结束。现在如果再次包含文件（在许多头文件包含其他头文件 _ad infinininini---_cough! 的情况下可能发生），宏`_AARDVARK_H_`将已经被定义，因此`#ifndef`会失败，直到`#endif`的文件将被预处理器丢弃。

另一个极其有用的功能是为特定平台编译特定代码，并为不同平台编译其他代码。许多人喜欢为他们所在平台的类型定义一个宏，例如`LINUX`或`WIN32`。你可以巧妙地使用这个功能，让你的代码可以在不同类型的系统上编译和工作：

``` {.c}
void run_command_shell(void)
{
#ifdef WIN32
    system("COMMAND.EXE");
#elifdef LINUX
    system("/bin/bash");
#else
#error We don't have no steenkin shells!
#endif
}
```

还有一些新东西，最显著的是`#elifdef`。这是"else ifdef"的缩写，必须在那种情况下使用。如果你使用了`#if`，那么你会使用对应的`#elif`。

还有一个`#error`指令。这将导致预处理器立即中止，并显示给定消息。

有几个很好的理由解释为什么我们想要有一个指向指针的指针，我们会先给您最简单的一个：您想将一个指针作为参数传递给一个函数，让函数修改它，并将结果反映给调用者。

请注意，这正是我们在函数调用中使用指针的原因：我们希望函数能够修改指针所指向的东西。不过，在这种情况下，我们希望它修改的是另一个指针。例如：

``` {.c}
void get_string(int a, char **s)
{
    switch(a) {
        case 0:
            *s = "大家";
            break;

        case 1:
            *s = "都在";
            break;

        case 2:
            *s = "功夫打斗";
            break;

        default:
            *s = "错误!";
    }
}

int main(void)
{
    char *s;

    get_string(2, &s);

    printf("s is \"%s\"\n", s);  /* 's is "功夫打斗"' */
}
```

以上是一段代码，将通过指向指针的指针向调用者提供一个字符串（指向`char`的指针）。请注意，在`main()`函数中，我们传递了指针`s`的地址。这使得函数`get_string()`拥有了指向`s`的指针，因此它可以解引用该指针以更改其指向的内容，即`s`本身。

这里真的没有什么神秘的地方。您有一个指向一个东西的指针，所以您可以解引用指针以更改这个东西。这与以前的情况类似，只不过现在我们操作的是指针，而不仅仅是普通的基本类型。

我们还可以用指向指针的指针做什么？你可以使用它们动态制作类似于二维数组的结构。以下示例依赖于你知道函数调用 `malloc()` 返回一块连续的内存字节，并且你可以按照你的需要使用它们。在这种情况下，我们将使用它们来创建一些 `char*`。而且，我们将拥有一个指向它的指针，因此它的类型为 `char**`。

``` {.c}
int main(void)
{
    char **p;

    p = malloc(sizeof(char*) * 10);  // 分配 10 个 char*
}
```

很好。现在我们可以用这些做什么呢？嗯，它们还没有指向任何东西，但我们可以依次为它们调用 `malloc()`，然后我们将有一大块内存可以用来存储字符串。

``` {.c}
int main(void)
{
    char **p;
    int i;

    p = malloc(sizeof(char*) * 10);  // 分配 10 个 char* 大小的字节

    for(i = 0; i < 10; i++) {
        *(p+i) = malloc(30); // 每个指针分配 30 字节

        // 或者，我们可以这样写：
        //   p[i] = malloc(30);
        // 但我们没有这样写。

        sprintf(*(p+i), "这是第 %d 个字符串", i);
    }

    for(i = 0; i < 10; i++) {
        printf("%d: %s\n", i, p[i]); // p[i] 和 *(p+i) 相同
    }
}
```

好了，正如你可能在想的那样，这是事情变得完全疯狂的地方。让我们看看那行第二个 `malloc()` 的代码，并逐步解析它。

你知道 `p` 是一个指向指向 `char` 的指针，或者换句话说，它是一个指向 `char*` 的指针。记住这一点。

然后我们知道这个`char*`是一个连续块中的第一个，因为在循环之前我们刚刚使用`malloc()`分配了这么多内存空间。通过这个了解，我们知道可以使用指针算术来在不同字符指针之间跳转。我们通过将`i`的值加到`char**`上来实现这一点，这样当我们解引用它时，就会指向块中的下一个`char*`。在循环的第一次迭代中，`i`是零，所以我们只是在引用第一个`char*`。

当我们有了这个`char*`之后，我们该怎么处理呢？我们指向`malloc()`的返回值，这将指向新分配的30字节内存空间。

那我们用这块内存做什么（天哪，这个可以永无止境！）-- 嗯，我们使用`printf()`的一个变种称为`sprintf()`，它会将结果写入一个字符串而不是控制台。

这就是全部。最后，为了好玩，我们使用数组表示法打印出结果，而不是使用指针算术访问这些字符串。

## 函数指针 {#ptfunc}

你完全掌握了所有指针相关的内容，对吧？我是说，你就是_指针大师_！不，真的，我坚持这么说！

所以，请记住，我们将把整个指针和地址的概念提升到下一个阶段，并学习一些关于编译器生成的机器代码的知识。我知道这似乎与本小节“函数指针”毫无关联，但这些背景知识将让你更强大。只要这不会先把你搞死。诚然，试图理解这一部分而导致死亡的可能性很小，但作为预防措施，最好在带有防护设施的房间里阅读这部分内容。

很久以前我提到过编译器会将你的C源代码转换成_机器码_，这些机器码是处理器可以执行的。这些机器码指令很小（通常占用一到四个字节的内存，每个指令可选地拥有最多32个字节的参数---这些数字根据具体的处理器而有所不同）。重要的不是指令的大小，而是这些指令必须要存储在某个地方。猜猜在哪里。

你以为这是一个修辞性的命令，但不，我真的想让你猜猜指令通常存储在哪里。

你有猜测了吗？很好。是动物、植物还是矿物？你可以在里面飞吗？是火箭吗？耶！

但是，除了脑力飞跃，是的，你猜对了，这些指令被存储在内存中，就像变量被存储在内存中一样。指令本身有地址，CPU中的一个特殊变量（通常在CPU术语中被称为“寄存器”）指向当前执行指令的地址。

什么？我说这个变量“指向”和“地址”！突然间又回到了指针和所有那些...熟悉的地方。但是我刚才说了什么？我说：指令存储在地址中，因此，你可以有一个指向一块指令的指针。在C中，一块指令存储在一个函数中，因此，你可以有一个指向函数的指针。_哇_！

好了，如果你有一个函数，你怎么获得函数的地址？是的，你可以使用 `&`，但大多数人不这样做。这类似于数组的情况，数组名称没有方括号时是指向数组第一个元素的指针；函数名称没有括号时是指向函数第一个指令的指针。这是简单的部分。

困难的部分是声明一个变量为"指向函数的指针"类型。这很难是因为语法很奇怪：

``` {.c}
// 声明 p 为一个接受两个 int 参数并返回 float 的函数指针：

float (*p)(int, int);
```

再次说明，这是一个指向函数的声明。它还没有指向特定的任何函数。也请注意，在声明指针变量时不必在参数中放置虚拟参数名称。好的，让我们写一个函数，指向它，并调用它：

``` {.c}
int deliver_fruit(char *address, float speed)
{
    printf("将水果送到 %s，速度为 %.2f\n", address, speed);

    return 3490;
}

int main(void)
{
    int (*p)(char*,float);  // 声明一个函数指针变量

    p = deliver_fruit; // p 现在指向 deliver_fruit() 函数

    deliver_fruit("我的家", 5280.0); // 正常调用

    p("我的家", 5280.0); // 使用指针进行相同的调用
}
```

这有什么用？通常的原因有：

- 你想在运行时更改调用的函数。
- 你有一个包含函数指针的大型数据数组。
- 你在编译时不知道要调用的函数；也许它在一个共享库中，在运行时加载并查询以找到函数，而该查询返回函数的指针。我知道这有点超出本节的范围，但请耐心听我解释。

例如，很久以前，我的一个朋友和我写了一个程序，模拟了一群生物在方格中奔跑。每个生物都有一个关联的结构体，包含它们的位置、健康状况和其他信息。结构体还包含一个指向函数的指针，这个函数是它们的行为，就像这样：

``` {.c}
struct creature {
    int xpos;
    int ypos;
    float health;
    int (*behavior)(struct useful_data*);
};
```

因此，在模拟的每一轮中，我们将遍历生物的列表，并调用它们的行为函数（传递一个指向一堆有用数据的指针，使函数能够看到其他生物，了解自己等）。通过这种方式，编写有不同行为的错误变得容易。

事实上，我写了一个名为“洗脑者”的生物，当它靠近另一个生物时，会将该生物的行为指针更改为指向洗脑者的行为代码！当然，很快他们都成为洗脑者，然后被饿死并相互 cannibalized 到死亡。让这成为给你的一个教训。


## 可变参数列表 {#varargs}

在闲暇时，你是否曾想过，在你躺在床上、思考 C 语言时，像 `printf()` 和 `scanf()` 这样的函数似乎可以接受任意数量的参数，而其他函数则需要特定数量的参数？如何为接受可变数量参数的函数编写函数原型？

（别被术语搞混了---我们这里不是在谈论变量。在这种情况下，“变量”保留其通常的意思，即“任意数量”）。

好吧，在这种情况下，已为你设置一些小技巧。记得所有的参数在传递给函数时都被推送到堆栈上吗？嗯，一些宏已经被设置来帮助你沿着堆栈遍历并逐个提取参数。通过这种方式，你无需在编译时知道参数列表的样子---你只需要知道如何解析它。

举个例子，让我们编写一个函数，用于求任意数量正数的平均值。我们可以逐个从栈中取出数字并计算平均值，但是我们需要知道何时停止从栈中取东西。一种方法是设置一个标志值，当遇到这个值时就停止。另一种方法是在必选的第一个参数中放入某种信息。让我们选择方案 B，在函数的第一个参数中放入要求平均值的参数数量。

这是该函数的原型——这是我们如何声明可变参数列表。第一个参数（至少）必须被指定，但仅限于此：

``` {.c}
float average(int count, ...);
```

这就是神奇的 "`...`"，明白了吗？这让编译器知道第一个参数后面可能还有更多参数，但不需要告诉编译器具体是什么参数。所以，这是我们如何能够将多个或少量（但至少是一个，即第一个参数）参数传递给函数的方法。

但如果我们在函数头中没有为变量指定名称，那么如何在函数中使用它们呢？哦，我们是那么挑剔，真的想要在函数中 _使用_ 变量！好的，我告诉你！

在头文件 `stdarg.h` 中有一种特殊声明的类型叫做 `va_list`。它存储有关堆栈和迄今为止已解析的参数的数据。但首先，您必须告诉它这个函数的堆栈从哪里开始，幸运的是，我们刚好在 `average()` 函数的开头有一个变量：`a`。

我们使用一系列预处理宏（如果您还没有阅读关于宏的部分，可以将其视为迷你函数）来操作我们的 `va_list` 。首先，我们使用 `va_start()` 告诉我们的 `va_list` 堆栈从哪里开始。然后我们重复使用 `va_arg()` 从堆栈中取出参数。最后，我们使用 `va_end()` 告诉我们的 `va_list` 我们处理完毕了。（语言规范要求我们 _必须_ 调用 `va_end()`，而且我们必须在调用 `va_start()` 的同一个函数中调用它。这使得编译器可以执行任何必要的清理操作，并避免了可变参数警察来敲门。）

接下来举个例子！让我们编写那个 `average()` 函数。记住：`va_start()`，`va_arg()`，`va_arg()`，`va_arg()`，等等，然后 `va_end()`！

### `vprintf()` 和类似函数 {#varargsvp}

有一些函数可以接受一个 `va_list` 作为参数。这使您可以轻松地将这些函数包装在接受可变数量参数的自己的函数中。例如：

> 
**作业:** 实现一个名为 `timestamp_printf()` 的 `printf()` 版本，其功能与 `printf()` 完全相同，只是在输出指定的 `printf()` 风格格式字符串之前打印时间和一个换行符。

天啊！乍一看，好像你将不得不实现一个 `printf()` 的克隆才能在前面输出时间戳！而 `printf()` 就像我们在行业中说的那样是“繁琐的”！明年见！

等等，然而---等等，等等......肯定有一种简单的方法来做到这一点，否则这个作者要么完全疯了才给你这个作业，但事实不可能是这样的。水果！我的奶酪在哪里！Blalalauugh！！

啊咳。真的没事，法官大人。我要看看我的水晶球，我看到了......在你的未来会有一个叫做 `va_list` 的类型。事实上，如果我们取出我们的可变参数列表，用 `va_start()` 处理它并得到我们的 `va_list`，如果有这么一个东西，我们实际上可以将其传递给已经编写好的接受这种类型的 `printf()`。

欢迎来到 `vprintf()` 的世界！它就是这么回事，天哪！这是一个可爱的原型：

``` {.c}
int vprintf(const char *format, va_list args);
```

好的，那么我们为这个任务需要哪些构建块呢？规格说明说我们需要做类似于 `printf()` 的事情，所以我们的函数，就像 `printf()` 一样，首先会接受一个格式字符串，然后是可变数量的参数，类似于这样：

``` {.c}
int timestamp_printf(char *format, ...);
```

但在打印内容之前，它需要输出一个时间戳，然后换行。分配中没有明确指定时间戳的确切格式，所以我将假设采用类似“星期 月份 日 时:分:秒 年”的格式。令人惊讶的是，存在一个名为`ctime()`的函数，可以返回当前系统时间的字符串，恰好符合这种格式。

所以计划是先打印一个时间戳，然后取得我们的可变参数列表，通过`va_start`处理以获取一个`va_list`，然后将该`va_list`传递给`vprintf()` 并让它执行已经编写好的`printf()` 魔法。然后...开始！

``` {.c}
#include <stdio.h>
#include <stdarg.h>
#include <time.h>  // 用于 time() 和 ctime();

int timestamp_printf(char *format, ...)
{
    va_list args;
    time_t system_time;
    char *timestr;
    int return_value;

    system_time = time(NULL); // 自纪元以来的系统时间（秒）
    timestr = ctime(&system_time); // 准备打印的时间戳

    // 输出时间戳:
    printf("%s", timestr); // timestr 已经附带换行符

    // 获取 va_list:
    va_start(args, format);

    // 用我们的参数列表调用 vprintf():
    return_value = vprintf(format, args);

    // 使用完列表后，必须调用 va_end():
    va_end(args);

    // 因为我们希望完全像 printf() 一样，所以我们保存了它的返回值，然后将其传递过来:
    return return_value;
}

int main(void)
{
    // 示例调用:
    timestamp_printf("由数字 %d 带来", 3490);
}
```

这样就完成了！你拥有自己类似`printf()`的功能！

现在，并不是每个函数都在名称前面加上一个"v"，用于处理可变参数列表，但尤其是所有的`printf()`和`scanf()`变体都有，所以请随意使用它们！



# 宽字符注释

源字符集
    基本字符集 | 扩展字符集
    扩展字符

执行字符集
    基本字符集 | 扩展字符集
    扩展字符

字符，char：适配一个字节

多字节字符：由一个或多个字节表示扩展字符集中成员的序列（S或E）

    'x'

宽字符，wchar_t：值可以表示本地环境中的任何字符。这些是用于表示字符的代码点的32位值。

    L'x'  wchar_t
    u'x'  char16_t
    U'x'  char32_t

char16_t
char32_t

本地环境

\unnnn
\Unnnnnnnn

字符串编码前缀：

    UTF-8字符串文字
        u8"foo" char

    宽字符串文字
        L"foo"  wchar_t
        u"foo"  char16_t
        U"foo"  char32_t

mblen
mbtowc
mbstowcs

wctomb
wcctombs

宽输出只在流是宽向的情况下起作用 fwide()
    定位在第一次写入时被设置
    其他定位不起作用

## 类型

wchar_t

mbstate_t
* 用于mb<->宽转换
* Shift状态

wint_t

* 这是一个整数类型，默认参数传递不会改变其，可以容纳与扩展字符集成员对应的任何值，以及至少一个与任何扩展字符集成员都不对应的值

WEOF

    宽EOF

## 函数组:

* 执行宽字符、多字节字符或两者输入和输出的函数；
* 提供宽字符串数字转换的函数；
* 执行一般宽字符串操作的函数；
* 用于宽字符串日期和时间转换的函数；以及
* 在多字节字符和宽字符序列间提供扩展转换能力的函数。

## 输入/输出：

* int fwprintf(FILE * restrict stream, const wchar_t * restrict format, ...);
  * 字符数组中的字符会被转换，就好像通过多次调用 mbrtowc 函数进行转换一样，转换状态由一个初始化为零的 mbstate_t 对象描述，在转换第一个多字节字符之前
* int fwscanf(FILE * restrict stream, const wchar_t * restrict format, ...);
* int swprintf(wchar_t * restrict s, size_t n, const wchar_t * restrict format, ...);
* int swscanf(const wchar_t * restrict s, const wchar_t * restrict format, ...);
* int vfwprintf(FILE * restrict stream, const wchar_t * restrict format, va_list arg);
* int vfwscanf(FILE * restrict stream, const wchar_t * restrict format, va_list arg);
* int vswprintf(wchar_t * restrict s, size_t n, const wchar_t * restrict format, va_list arg);
* int vswscanf(const wchar_t * restrict s, const wchar_t * restrict format, va_list arg);
* int vwprintf(const wchar_t * restrict format, va_list arg);
* int vwscanf(const wchar_t * restrict format, va_list arg);
* int wprintf(const wchar_t * restrict format, ...);
* int wscanf(const wchar_t * restrict format, ...);
* wint_t fgetwc(FILE *stream);
* wchar_t *fgetws(wchar_t * restrict s, int n, FILE * restrict stream);
* wint_t fputwc(wchar_t c, FILE *stream);
* int fputws(const wchar_t * restrict s, FILE * restrict stream);
* int fwide(FILE *stream, int mode);
* wint_t getwc(FILE *stream);
* wint_t getwchar(void);
* wint_t putwc(wchar_t c, FILE *stream);
* wint_t putwchar(wchar_t c);
* wint_t ungetwc(wint_t c, FILE *stream);

## 转换函数

* double wcstod(const wchar_t * restrict nptr, wchar_t ** restrict endptr);
* float wcstof(const wchar_t * restrict nptr, wchar_t ** restrict endptr);
* long double wcstold(const wchar_t * restrict nptr, wchar_t ** restrict endptr);

* long int wcstol(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);
* long long int wcstoll(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);
* unsigned long int wcstoul(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);
* unsigned long long int wcstoull(const wchar_t * restrict nptr, wchar_t ** restrict endptr, int base);

## 复制

* wchar_t *wcscpy(wchar_t * restrict s1, const wchar_t * restrict s2);

* wchar_t *wcsncpy(wchar_t * restrict s1, const wchar_t * restrict s2, size_t n);
* wchar_t *wmemcpy(wchar_t * restrict s1, const wchar_t * restrict s2, size_t n);

* wchar_t *wmemmove(wchar_t *s1, const wchar_t *s2, size_t n);
* wchar_t *wcscat(wchar_t * restrict s1, const wchar_t * restrict s2);
* wchar_t *wcsncat(wchar_t * restrict s1, const wchar_t * restrict s2,
  size_t n);

## 比较

* int wcscmp(const wchar_t *s1, const wchar_t *s2);
* int wcscoll(const wchar_t *s1, const wchar_t *s2);

* int wcsncmp(const wchar_t *s1, const wchar_t *s2, size_t n);
* size_t wcsxfrm(wchar_t * restrict s1, const wchar_t * restrict s2, size_t n);
* int wmemcmp(const wchar_t *s1, const wchar_t *s2, size_t n);

## 搜索

* wchar_t *wcschr(const wchar_t *s, wchar_t c); // 在宽字符字符串中查找宽字符 c
* size_t wcscspn(const wchar_t *s1, const wchar_t *s2); // 计算宽字符字符串 s1 中不包含 s2 中任何字符的初始子串的长度
* wchar_t *wcspbrk(const wchar_t *s1, const wchar_t *s2); // 在宽字符字符串 s1 中查找 s2 中的任何字符
* wchar_t *wcsrchr(const wchar_t *s, wchar_t c); // 从宽字符字符串末尾向前查找宽字符 c
* size_t wcsspn(const wchar_t *s1, const wchar_t *s2); // 计算宽字符字符串 s1 中包含 s2 中任何字符的长度
* wchar_t *wcsstr(const wchar_t *s1, const wchar_t *s2); // 在宽字符字符串 s1 中查找宽字符字符串 s2
* wchar_t *wcstok(wchar_t * restrict s1, const wchar_t * restrict s2, wchar_t ** restrict ptr); // 使用宽字符字符串 s2 中的分隔符对宽字符字符串 s1 进行分词
* wchar_t *wmemchr(const wchar_t *s, wchar_t c, size_t n); // 在宽字符字符串的前 n 个字符中查找宽字符 c

## 长度和其他

* size_t wcslen(const wchar_t *s); // 返回宽字符字符串的长度
* wchar_t *wmemset(wchar_t *s, wchar_t c, size_t n); // 将宽字符 c 设置到宽字符字符串 s 的前 n 个字符中
* size_t wcsftime(wchar_t * restrict s, size_t maxsize, const wchar_t * restrict format, const struct tm * restrict timeptr);  // 格式化时间信息并将结果存储到宽字符字符串 s 中

## 字符串转换

* wint_t btowc(int c); // 将单字节字符转换为宽字符
* int wctob(wint_t c); // 将宽字符转换为单字节字符
* int mbsinit(const mbstate_t *ps); // 检查多字节转换状态是否处于初始状态
* size_t mbrlen(const char * restrict s, size_t n, mbstate_t * restrict ps); // 返回下一个多字节字符中包含的字节数
* size_t mbrtowc(wchar_t * restrict pwc, const char * restrict s, size_t n, mbstate_t * restrict ps);  // 在多字节字符串中查找下一个宽字符并将其转换
* size_t wcrtomb(char * restrict s, wchar_t wc, mbstate_t * restrict ps); // 将宽字符转换为多字节字符
* size_t mbsrtowcs(wchar_t * restrict dst, const char ** restrict src, size_t len, mbstate_t * restrict ps); // 将多字节字符串转换为宽字符字符串
* size_t wcsrtombs(char * restrict dst, const wchar_t ** restrict src, size_t len, mbstate_t * restrict ps); // 将宽字符字符串转换为多字节字符串

## 字符分类

`<wctype.h>`

```c
// 检查wc是否为数字或字母
int iswalnum(wint_t wc);
// 检查wc是否为字母
int iswalpha(wint_t wc);
// 检查wc是否为空白字符
int iswblank(wint_t wc);
// 检查wc是否为控制字符
int iswcntrl(wint_t wc);
// 检查wc是否为数字字符
int iswdigit(wint_t wc);
// 检查wc是否为可打印字符
int iswprint(wint_t wc);
// 检查wc是否为小写字母
int iswlower(wint_t wc);
// 检查wc是否为可打印字符（包括空格）
int iswprint(wint_t wc);
// 检查wc是否为标点符号
int iswpunct(wint_t wc);
// 检查wc是否为空白字符
int iswspace(wint_t wc);
// 检查wc是否为大写字母
int iswupper(wint_t wc);
// 检查wc是否为十六进制数字字符
int iswxdigit(wint_t wc);
// 根据描述符desc检查字符wc是否符合相应的字符类型
int iswctype(wint_t wc, wctype_t desc);

// 转换成对应的小写字符
wint_t towlower(wint_t wc);
// 转换成对应的大写字符
wint_t towupper(wint_t wc);
// 根据描述符desc进行字符转换
wint_t towctrans(wint_t wc, wctrans_t desc);

// 获取相应属性的描述符
wctype_t wctype(const char *property);
// 获取相应属性的转换描述符
wctrans_t wctrans(const char *property);

// 从当前位置s开始，将n个字节转换成utf-16字符
size_t mbrtoc16(char16_t * restrict pc16, const char * restrict s, size_t n, mbstate_t * restrict ps);
// 将utf-16字符转换成多字节字符
size_t c16rtomb(char * restrict s, char16_t c16, mbstate_t * restrict ps);
// 从当前位置s开始，将n个字节转换成utf-32字符
size_t mbrtoc32(char32_t * restrict pc32, const char * restrict s, size_t n, mbstate_t * restrict ps);
// 将utf-32字符转换成多字节字符
size_t c32rtomb(char * restrict s, char32_t c32, mbstate_t * restrict ps);
```

这是 C11 的一个有趣特性，允许你创建一个没有名字的对象。可能会在一些情况下有用，比如需要将一个一次性的 `struct` 传递给一个函数，但只想让它作为参数存在，而不是像普通变量那样存在。

首先，让我们看一些牵强和无用的语法。

``` {.c}
int a = (int){2};
```

在赋值右边，我们有一个未命名的 `int`，初始化为 `2`。然后我们立即将其分配给一个变量 `a`。

``` {.c}
int a = (int){2};
int a = 2;         // 同样的事情
```

如果它们是相同的，为什么还要麻烦使用这个语法呢？这样更难阅读，冗长。

好吧，让我们尝试使用 `struct` 看看会发生什么。

未完成的类型

6.2.5p22

一个未知大小的数组类型是一个未完成的类型。在稍后用具有内部或外部链接的大小指定该类型的标识符的声明中（）完成。

一个未知内容的结构或联合体类型（如描述在6.7.2.3中）是一种不完整类型。在同一作用域中的所有该类型的声明中，通过在后面声明具有其定义内容的相同结构或联合标签来完成。

6.3.2.1p1

可修改的左值是一个不具有数组类型、不是不完整类型、不具有 const 限定类型的左值，并且如果它是一个结构或联合体，则没有任何成员（包括递归地，所有包含的聚合或联合体的所有成员或元素）具有 const 限定类型。

6.3.2.1p2

如果左值具有不完整类型并且没有数组类型，则行为是未定义的。

6.5.3.4p1

sizeof运算符不得应用于具有函数类型或不完整类型的表达式，不得应用于此类类型的带括号的名称，或不得应用于指定位域成员的表达式。_Alignof运算符不得应用于函数类型或不完整类型。

fn129

只有在不需要该类型对象的大小时，才可以使用不完整类型。例如，在将typedef名称声明为结构或联合的说明符时，或者在声明指向结构或联合的指针或返回结构或联合的函数时，不需要（参见6.2.5中的不完整类型）。在调用或定义此类函数之前，规范必须是完整的。

6.7.6.2p4

如果尺寸不存在，则数组类型是不完整类型。

6.7.6.2p8

例2请注意以下声明之间的区别

    extern int *x;
    extern int y[];

第一个声明x为指向int的指针；第二个声明y为未指定大小的int数组（不完整类型），其存储在其他地方定义。

6.7.9p31

例7完成数组类型的一种初始化形式涉及typedef名称。给定声明

    typedef int A[]; // OK - 在块作用域中声明

声明

    A a = { 1, 2 }, b = { 3, 4, 5 };

与

    int a[] = { 1, 2 }, b[] = { 3, 4, 5 };

由于不完整类型的规则，相同。

6.9.2p3

如果对对象的标识符进行的声明是具有内部链接的试探性定义，声明的类型不得为不完整类型。

6.9.2p5

例2如果在包含以下内容的翻译单位结束时

    int i[];

数组i仍然具有不完整类型，则隐式初始化程序使其具有一个元素，该元素在程序启动时被设置为零。

6.2.5p1

在翻译单元的各个点，对象类型可能是不完整的（缺少足够的信息来确定该类型对象的大小），也可能是完整的（具有足够的信息）。

空类型包含一组空值；它是一个不完整的对象类型，无法完成。

结构或联合体不得包含具有不完整或函数类型的成员（因此，结构不应包含其自身的实例，但可以包含指向其自身实例的指针），除非具有多个命名成员的结构的最后一个成员可以具有不完整的数组类型；这样的结构（以及可能递归包含此类结构成员的任何包含该结构成员的联合体）不得是结构体的成员或数组的元素。

结构类型在终止列表的 } 后立即之前是不完整的，之后是完整的。

作为特殊情况，在具有多个命名成员的结构的最后一个元素可能具有不完全的数组类型；这被称为灵活数组成员。在大多数情况下，灵活数组成员会被忽略。特别是，在结构的大小方面，灵活数组成员被视为被省略，除非它可能具有比省略暗示的更多尾随填充。然而，当一个 .（或->）操作符的左操作数是（指向）具有灵活数组成员的结构，并且右操作数命名该成员时，它的行为就好像该成员被替换为不会使结构大于被访问对象的最长数组（具有相同的元素类型）；数组的偏移量应保持灵活数组成员的偏移量，即使这可能与替换数组的偏移量不同。如果该数组没有元素，它的行为就好像它有一个元素，但如果尝试访问该元素或生成一个指向该元素之后的指针，则行为是未定义的。

每个枚举类型应与 char、有符号整数类型或无符号整数类型兼容。类型的选择是实现定义的，但应能够表示枚举的所有成员的值。枚举类型在终止枚举声明列表的 } 之后立即之前是不完整的，之后是完整的。

如果形式为 struct-or-union identifier 的类型指示符出现在不是作为上述形式之一的部分的其他位置，并且标识符作为标签的其他声明不可见，则它声明为不完整的结构或联合类型，并将该标识符声明为该类型的标签。

评估方法确定涉及所有浮点类型的表达式的评估格式，而不仅仅是实型。例如，如果FLT_EVAL_METHOD为1，则两个float_Complex操作数的乘积以double_Complex格式表示，并且其部分被评估为double。

有三种复合类型，分别为float_Complex、double_Complex和long double_Complex。（复合类型是一个条件特性，实现不必支持；参见6.10.8.3。）实浮点类型和复合类型统称为浮点类型。

对于每种浮点类型，都有一个对应的实型，它始终是一个实浮点类型。对于实浮点类型，它是相同的类型。对于复合类型，它是通过从类型名称中删除关键字_Complex 得到的类型。

每种复合类型都具有与包含恰好两个相应实型元素的数组类型相同的表示和对齐要求；第一个元素等于复数的实部，第二个元素等于虚部。


STDC_NO_COMPLEX
__STDC_IEC_559_COMPLEX__

complex == _Complex


float complex
double complex
long double complex

_Complex_I

_Imaginary
_Imaginary_I

如果_I存在，则I扩展为_Imaginary_I；否则为_Complex_I

https://en.cppreference.com/w/c/numeric/complex/imaginary

#pragma STDC CX_LIMITED_RANGE

所有的数学函数

CMPLX