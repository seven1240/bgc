```c
// Beej的C指南

# vim: ts=4:sw=4:nosi:et:tw=72

```

# 变量与语句

> _"这个世界需要各种各样的人，不是吗，牧师？"_ \
> _"当然，我的孩子，当然。"_
>
> ---海盗船长托马斯·巴塞罗缪·雷德对牧师说，海盗

在C程序中可能会有很多东西。

对啊。

出于各种原因，我们最好对程序中可能遇到的一些类型进行分类，这样我们谈论问题时就能更清楚明白。

## 变量

变量被说成是“存储值”的。但另一种理解方式是，变量是指向内存中某些数据的易读名称。

我们暂停一下，来看看指针这个复杂的话题。不用担心。

你可以将内存看作是一组字节的大数组。数据存储在这个“数组”中。如果一个数字大于一个字节，它会被存储在多个字节中。因为内存就像一个数组，每个字节的内存可以用它的索引来引用。也可以称为这个内存索引为_地址_，或_位置_，或_指针_。

```c
当你在C中有一个变量时，那个变量的值会存储在内存的某个地址中。当然。毕竟，不然还能在哪里呢？但是，通过数字地址来引用一个值很痛苦，所以我们给它起个名字，这就是变量的作用。

我提到这些的原因有两个：

1. 这将使得后面理解指针变量更容易---它们是保存其他变量地址的变量！
2. 同样，这将使得后面理解指针更容易。

因此，变量就是一些数据在内存中某个地址上的名字。

### 变量名

您可以在变量名中使用0-9、A-Z、a-z和下划线范围内的任何字符，使用以下规则：

* 不能以数字0-9开头。
* 不能以两个下划线开头。
* 不能以下划线后面跟大写A-Z字母开头。

对于Unicode，试一试就知道了。在规范的§D.2部分有一些规则，讨论了哪些Unicode代码点范围允许在标识符的哪些部分中使用，但这太多了，在这里写起来太多了，而且你可能永远也不用考虑这些。

### 变量类型

[i[Types]]根据您已掌握哪些编程语言，您可能或可能不熟悉类型的概念。但是C对类型有些挑剔，因此我们应该做一个复习。

一些示例类型，一些最基本的：

[i[`int` 类型]][i[`float` 类型]][i[`char` 类型]][i[`char *` 类型]]
```

```c
#include <stdio.h>

int main(void)
{
    int i;    // 保存有符号整数，例如 -3、-2、0、1、10
    float f;  // 保存有符号浮点数，例如 -3.1416

    printf("Hello, World!\n");  // 啊，美妙的熟悉感
}
```

```c
[i[Variables-->uninitialized]]未初始化的变量具有不确定的值^[口语上，我们说它们具有"随机"值，但它们并不真正---甚至伪随机---是随机数字。]. 它们必须被初始化，否则你必须假设它们包含一些无意义的数字。

> 这是 C 语言中会"套你的"地方之一。在我的经验中，大部分时间，不确定的值是零... 但是它可能会在每次运行时变化！永远不要假设该值将为零，即使你看到它是零。_始终_在使用之前明确地将变量初始化为某个值^[这并不是绝对百分之百正确。当我们开始学习静态存储期后，你会发现有些变量会自动初始化为零。但最安全的做法始终是将它们初始化。]。

这是什么？你想在这些变量中存储一些数字？疯了！

让我们继续：
[i[`=` 赋值运算符]]

``` {.c .numberLines}
int main(void)
{
    int i;

    i = 2; // 将值 2 赋给变量 i

    printf("Hello, World!\n");
}
```

解决了。我们已经存储了一个值。让我们打印出来。

[i[`printf()` 函数]<]我们将通过向 `printf()` 函数传递 _两个_ 了不起的参数来实现这一点。第一个参数是一个字符串，描述了要打印什么以及如何打印（称为 _格式字符串_），第二个参数是要打印的值，即变量 `i` 中的内容。

`printf()` 在格式字符串中寻找各种特殊序列，这些序列以百分号（`%`）开头，告诉它要打印什么。例如，如果它找到 `%d`，它会查找传递的下一个参数，并将其作为整数打印出来。如果找到 `%f`，它将以浮点数形式打印该值。如果找到 `%s`，它将打印一个字符串。
```

如此一来，我们可以这样打印出各种类型的值：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i = 2;
    float f = 3.14;
    char *s = "Hello, world!";  // char *（"char pointer"）是字符串类型

    printf("%s  i = %d and f = %f!\n", s, i, f);
}
```

输出结果将是：

``` {.default}
Hello, world!  i = 2 and f = 3.14!
```

这样一来，`printf()` 可能类似于其他你熟悉的语言中不同类型的格式化字符串或参数化字符串。[i[`printf()`函数]>]

### 布尔类型

[i[布尔类型]<]C有布尔类型，true还是false?

`1`!

历史上，C并没有布尔类型，有人可能会争辩它现在还没有。

在C中，`0`代表"false"，非零表示"true"。

所以`1`是true。而`-37`是true。而`0`是false。

你可以将布尔类型声明为`int`：

``` {.c}
int x = 1;

if (x) {
    printf("x is true!\n");
}
```

如果你`#include <stdbool.h>`[i[`stdbool.h` 头文件]]，你也会获得一些符号名，让代码看起来更熟悉，即`bool`[i[`bool` 类型]]类型以及`true`[i[`true` 值]]和`false`[i[`false` 值]]值：

``` {.c .numberLines}
#include <stdio.h>
#include <stdbool.h>

int main(void) {
    bool x = true;

    if (x) {
        printf("x is true!\n");
    }
}
```

但这些和使用整数值表示true和false是一样的。它们只是为了让代码看起来更好看。[i[Boolean types]>]

## 运算符与表达式 {#operators}

C的操作符应该对你来说很熟悉，来自其他语言。让我们快速浏览一下其中一些。

（这里包含了比这个更多的细节，但我们将在本节中完成足够的内容来开始。）

### 算术

希望这些你已经熟悉了：
[`+` 加法运算符] [`-` 减法运算符]
[`*` 乘法运算符] [`/` 除法运算符]
[`%` 取模运算符]

``` {.c}
i = i + 3;  // 加法（+）和赋值（=）运算符，给 i 加 3
i = i - 8;  // 减法，从 i 减去 8
i = i * 9;  // 乘法
i = i / 2;  // 除法
i = i % 5;  // 取余（除法余数）
```

对于上述每种运算符都有一种更简洁的变体。这些行可以更简洁地写成：
[`+=` 赋值运算符] [`-=` 赋值运算符]
[`*=` 赋值运算符] [`/=` 赋值运算符]
[`%=` 赋值运算符]

``` {.c}
i += 3;  // 等同于 "i = i + 3"，给 i 加 3
i -= 8;  // 等同于 "i = i - 8"
i *= 9;  // 等同于 "i = i * 9"
i /= 2;  // 等同于 "i = i / 2"
i %= 5;  // 等同于 "i = i % 5"
```

没有指数运算。你将需要使用`math.h`中的`pow()`[i[pow()]T]函数变体之一。

让我们进入一些你可能在其他语言中没有的更奇怪的东西！[i[Arithmetic Operators]>]

### 三元运算符

C语言还包括_三元运算符_。这是一个取决于其内嵌的条件结果的表达式。

``` {.c}
// 如果 x > 10，则将 17 加到 y 上。否则将 37 加到 y 上。

y += x > 10? 17: 37;
```

有点乱！你会在阅读更多之后逐渐习惯的。为了帮助理解，我将使用`if`语句重新编写上面的表达式：

``` {.c}
// 这个表达式：

y += x > 10? 17: 37;

// 等同于这个非表达式：

if (x > 10)
    y += 17;
else
    y += 37;
```

比较这两者，直到你看到三元运算符的各个组件。

或者，另一个示例，打印存储在 `x` 中的数字是奇数还是偶数：

``` {.c}
printf("数字 %d 是 %s。\n", x, x % 2 == 0? "偶数": "奇数");
```

`printf()` 函数中的 `%s` 格式说明符表示打印一个字符串。如果表达式 `x % 2` 的值为 `0`，整个三元表达式的值就是字符串 `"偶数"`。否则就是字符串 `"奇数"`。挺酷的！

重要的是要注意，三元运算符不像 `if` 语句那样用于流程控制。它只是一个会评估出一个值的表达式。

### 前后置自增和自减

现在，让我们来研究另一个可能你没见过的东西。

这就是传奇的后置自增和后置自减运算符：

``` {.c}
i++;        // 将 i 加一（后置自增）
i--;        // 将 i 减一（后置自减）
```

很常见，它们只是上面的这种方式的缩写：

``` {.c}
i += 1;        // 将 i 加一
i -= 1;        // 将 i 减一
```

但它们比那更微妙些，这些聪明的家伙。

让我们看看这种形式，前置自增和前置自减：

``` {.c}
++i;        // 将 i 加一（前置自增）
--i;        // 将 i 减一（前置自减）
```

使用前置自增和前置自减时，变量的值在表达式求值之前就会被递增或递减。然后用新值求值表达式。

而使用后置自增和后置自减时，表达式的值首先根据现值计算，然后在确定了表达式的值之后才递增或递减。

你实际上可以将它们嵌入到表达式中，像这样：

``` {.c}
i = 10;
j = 5 + i++;  // 先计算 5 + i，然后再递增 i
```

```c
printf("%d, %d\n", i, j);  // 输出 11, 15
```

让我们将这与预递增操作符进行比较：

```c
i = 10;
j = 5 + ++i;  // 先递增 i，_然后_计算 5 + i

printf("%d, %d\n", i, j);  // 输出 11, 16
```

这种技术经常用于数组和指针的访问和操作。它让你可以使用变量中的值，并且在使用之前或之后递增或递减该值。

但迄今为止，你最常见到的地方就是`for`循环中：

```c
for (i = 0; i < 10; i++)
    printf("i is %d\n", i);
```

但稍后我们会详细讨论。
[i[`++` 递增操作符]>] [i[`--` 递减操作符]>]

### 逗号操作符

[i[`,` 逗号操作符]<]
这是一种不常用的方法，用于按从左到右的顺序分隔表达式：

```c
x = 10, y = 20;  // 先将 10 赋给 x，然后 20 赋给 y
```

这似乎有点愚蠢，因为你可以用分号代替逗号，是吧？

```c
x = 10; y = 20;  // 先将 10 赋给 x，然后 20 赋给 y
```

但这有所不同。后者是两个独立的表达式，而前者是一个单独的表达式！

使用逗号操作符时，逗号表达式的值是最右边表达式的值：

```c
x = (1, 2, 3);

printf("x is %d\n", x);  // 输出 3，因为 3 是逗号列表中最右边的值
```

但即使如此，这还是有些牵强。逗号操作符常用的地方之一是在`for`循环中，以在语句的每个部分执行多个操作：

```c
for (i = 0, j = 10; i < 100; i++, j++)
    printf("%d, %d\n", i, j);
```

稍后再详细讨论。
[i[`,` 逗号操作符]>]

### 条件运算符

``` {.c}
a == b;  // 如果a等于b则为真
a != b;  // 如果a不等于b则为真
a < b;   // 如果a小于b则为真
a > b;   // 如果a大于b则为真
a <= b;  // 如果a小于等于b则为真
a >= b;  // 如果a大于等于b则为真
```

不要混淆赋值 `=` 和比较 `==`！用两个等号进行比较，一个用于赋值。

我们可以在 `if` 语句中使用比较表达式：

``` {.c}
if (a <= 10)
    printf("成功！\n");
```

[i[Conditional Operators]>]

### 布尔运算符

[i[Boolean Operators]<]
我们可以使用布尔运算符来连接或更改条件表达式，如 _and_、_or_ 和 _not_。
[i[`&&` 逻辑与]]
[i[`!` 逻辑非]]
[i[`||` 逻辑或]]

|运算符|布尔意义|
|:------:|:-------------:|
|`&&`|和|
|`||`|或|
|`!`|非|

布尔运算符 "and" 的示例：

``` {.c}
// 如果 x 小于 10 并且 y 大于 20，则执行某些操作：

if (x < 10 && y > 20)
    printf("执行某些操作！\n");
```

布尔运算符 "not" 的示例：

``` {.c}
if (!(x < 12))
    printf("x 不小于12\n");
```

`!` 的优先级高于其他布尔运算符，因此在这种情况下必须使用括号。

当然，这与下面的语句是等价的：

``` {.c}
if (x >= 12)
    printf("x 不小于12\n");
```

但我需要这个示例！
[i[Boolean Operators]>]

### `sizeof` 运算符 {#sizeof-operator}

[i[`sizeof` operator]<]
该运算符告诉您特定变量或数据类型在内存中使用的大小（以字节为单位）。

更具体地说，它会告诉你特定表达式（可能只是一个变量）使用内存的大小（以字节为单位）。

这可能在不同系统上有所不同，除了`char`类及其变体（始终为1字节）。

现在可能看起来不太有用，但我们会在此处和那里提到它，所以值得介绍。

由于这计算了存储类型所需的字节数，你可能会认为它会返回一个`int`。或者…由于大小不可能是负数，也许是一个`unsigned` 类型呢？

但事实证明C有一种特殊类型来表示`sizeof`的返回值。它是`size_t`，发音为“_size tee_”[^（`_t`表示`type`缩写）]。我们只知道它是一种无符号整数类型，可以保存任何传递给`sizeof`的字节数。

`size_t`出现在许多不同的地方，其中需要传递或返回事物计数。将其视为代表计数的值。

你可以对变量或表达式使用 `sizeof`：

``` {.c}
int a = 999;

// %zu是类型size_t的格式说明符

printf("%zu\n", sizeof a);     // 在我的系统上打印4
printf("%zu\n", sizeof(2 + 7)); // 在我的系统上打印4
printf("%zu\n", sizeof 3.14);   // 在我的系统上打印8

// 如果需要打印负的size_t值，请使用％zd
```

记住：它是表达式类型的大小（以字节为单位），而不是表达式本身的大小。这就是为什么`2+7`和`a`的大小相同的原因——它们都是`int`类型。我们将在下一个代码块中重新讨论这个数字`4`...

...在那里，我们会看到你可以对类型使用 `sizeof`（请注意，与表达式不同，需要在类型名称周围加上括号）：

``` {.c}
printf("%zu\n", sizeof(int));   // 在我的系统上输出4
printf("%zu\n", sizeof(char));  // 在所有系统上都输出1
```

需要注意`sizeof`是一个编译时操作^[除了变长数组---但这是另一个故事。]。表达式的结果完全在编译时确定，而不是在运行时。

我们稍后会利用这一点。
[i[`sizeof` 运算符]>]


## 流程控制

[i[流程控制]<]
布尔值非常好，但如果我们不能控制程序流程，那当然一切都不行。让我们来看看几种结构：`if`、`for`、`while`和`do-while`。

首先，由您本地友好的C开发者带来的关于语句和语句块的前瞻性说明：

在`if`或`while`语句之类的东西后面，您可以放一个要执行的单个语句，也可以放一个要按顺序执行的语句块。

[i[`if` 语句]<]
我们从一个单个语句开始：

``` {.c}
if (x == 10) printf("x is 10\n");
```

有时也可以写在单独的一行上。（在C中，空格并不重要---它不像Python那样）

``` {.c}
if (x == 10)
    printf("x is 10\n");
```

但如果由于条件需要发生多个事情呢？您可以使用花括号来标记一个_块_或_复合语句_。

``` {.c}
if (x == 10) {
    printf("x is 10\n");
    printf("当 x 是 10 时也发生这个\n");
}
```

通常的风格是_总是_使用花括号，即使它们并不是必需的：

``` {.c}
if (x == 10) {
    printf("x is 10\n");
}
```

一些开发人员认为这样的代码更易于阅读，避免了像这样的错误，这里的代码在视觉上看起来像在`if`块中，但实际上并不是。

``` {.c}
// 错误示例

```c
if (x == 10)
    printf("如果 x 等于 10 就会发生这种情况\n");
    printf("这种情况总是发生\n");  // 惊喜！！无条件的！

`while` 和 `for` 以及其他循环结构的运行方式与上面的示例相同。如果你想在循环或 `if` 之后执行多个操作，将它们放在花括号中。

换句话说，`if` 将会运行`if` 后面的一个内容。而这一个内容可以是一个单独的语句或一组语句。

### `if`-`else` 语句 {#ifstat}

我们已经在多个示例中使用过 `if` 了，因为很可能你在其他语言中已经见过它，但这里有另一个例子：

``` {.c}
int i = 10;

if (i > 10) {
    printf("是的，i 大于 10。\n");
    printf("如果 i 大于 10，这也会被打印出来。\n");
}

if (i <= 10) printf("i 小于或等于 10。\n");
```

在示例代码中，如果 `i` 大于 10，那么消息将会被打印出来，否则继续执行下一行。请注意在 `if` 语句之后的花括号；如果条件为真，则会执行 `if` 之后的第一个语句或表达式，否则将执行 `if` 后的花括号中的代码集。这种 _代码块_ 行为对所有语句都是通用的。

当然，因为 C 语言有趣，你还可以在 `if` 上使用 `else` 子句来处理条件为假的情况：

``` {.c}
int i = 99;

if (i == 10)
    printf("i 是 10！\n");
else {
    printf("i 明显不是 10。\n");
    printf("这实在有点让我恼火，老实说。\n");
}
```

你甚至可以级联这些条件来测试各种情况，比如这样：
```

```c
else if (i == 99) {
    printf("i is 99! My favorite\n");
    printf("I can't tell you how happy I am.\n");
    printf("Really.\n");
}
    
else
    printf("i is some crazy number I've never heard of.\n");
```

尽管如果你选择这条路线，请务必查看[`switch`](#switch-statement) 语句，可能会有更好的解决方案。问题是`switch`只适用于与常数数字进行相等比较。上述`if`-`else`串联可以检查不等式、范围、变量或其他你可以在条件表达式中构造的任何东西。

### `while` 语句 {#whilestat}

`while`是您平均普通的循环构造。当条件表达式为真时执行某项操作。

让我们来做一个！

``` {.c}
// 打印以下输出:
//
//   i is now 0!
//   i is now 1!
//   [2到7之间的更多内容]
//   i is now 8!
//   i is now 9!

int i = 0;

while (i < 10) {
    printf("i is now %d!\n", i);
    i++;
}

printf("All done!\n");
```

这样就有了一个基本的循环。C语言还有一个`for`循环，对于上面的例子来说可能更简洁。

`while`的一种非常常见的用法是用于无限循环，您可以在条件为真时重复执行:

``` {.c}
while (1) {
    printf("1总是为真，所以这会一直重复。\n");
}
```
[i[`while` 语句]>]

### `do-while` 语句 {#dowhilestat}

[i[`do`-`while` 语句]<]
既然我们已经掌握了`while`语句，现在让我们来看一看它的近亲`do-while`。

它们基本上是一样的，除非在第一次循环条件为false时，`do-while`会执行一次，但`while`根本不会执行。换句话说，用`do-while`时，用于确定是否执行代码块的测试发生在代码块的**末尾**，而用`while`时发生在代码块的**开头**。

让我们通过示例来看：

``` {.c}
// 使用while语句：

i = 10;

// 这部分不会被执行，因为i不小于10：
while(i < 10) {
    printf("while: i is %d\n", i);
    i++;
}

// 使用do-while语句：

i = 10;

// 这部分会被执行一次，因为在循环条件检查之前，代码块的内容已经被执行了：

do {
    printf("do-while: i is %d\n", i);
    i++;
} while (i < 10);

printf("All done!\n");
```

注意，在这两种情况下，循环条件立即变为false。所以在`while`循环中，失败了，后续代码块根本不会被执行。然而，在`do-while`中，条件在代码块执行之后被检查，所以至少会执行一次。在这个例子中，它打印了消息，增加了`i`，然后失败了条件，继续执行到打印 "All done!"。

故事的寓意是：如果想要循环至少执行一次，无论循环条件如何，使用`do-while`。

所有这些例子可能最好使用`for`循环来完成。让我们做一些不那么确定性的事情---重复直到出现某个特定的随机数！

``` {.c .numberLines}
#include <stdio.h>   // 用于printf
#include <stdlib.h>  // 用于rand

int main(void)
{
    int r;

    do {
        r = rand() % 100; // 获取一个0到99之间的随机数
        printf("%d\n", r);
    } while (r != 37);    // 重复直到出现37
}
```

侧记：你运行过那个超过一次吗？如果是的话，你有没有注意到相同的数字序列再次出现了。一遍又一遍。一遍又一遍？这是因为`rand()`是一个伪随机数生成器，必须用不同的数进行“种子化”（seed）才能生成不同的序列。查阅[fl[`srand()`|https://beej.us/guide/bgclr/html/split/stdlib.html#man-srand]]函数以获取更多细节。[i[`do`-`while`语句]>]

### `for`语句 {#forstat}

[i[`for`语句]<]
欢迎来到世界上最受欢迎的循环之一！`for`循环！

如果你事先知道要循环的次数，这是一个很棒的循环。

你可以仅使用`while`循环来做同样的事情，但`for`循环可以帮助保持代码的整洁性。

以下是两段等效代码---注意`for`循环只是更紧凑的表示方法：

``` {.c}
// 打印0到9之间的数，包括0和9...

// 使用while语句：

i = 0;
while (i < 10) {
    printf("i is %d\n", i);
    i++;
}

// 使用for循环完全是一样的事情：

for (i = 0; i < 10; i++) {
    printf("i is %d\n", i);
}
```

没错，朋友们---它们完全做着相同的事情。但你可以看到`for`语句更加紧凑且易读。（此时，JavaScript用户将完全欣赏到它源自C语言的本质。）

`for`语句分成三部分，用分号分隔。第一部分是初始化，第二部分是循环条件，第三部分是在循环条件为真时应该发生的事情。这三部分都是可选的。

``` {.c}
for (初始化; 若这个条件为真则循环; 每次循环后要做的事情)
```

请注意，如果循环条件一开始为假，那么循环不会执行一次。

> **`for`循环有趣事实！**
>
> 你可以使用逗号运算符在`for`循环的每个子句中执行多个操作哦！
>
> ``` {.c}
> for (i = 0, j = 999; i < 10; i++, j--) {
>     printf("%d, %d\n", i, j);
> }
> ```

一个空的`for`循环会无限运行：

``` {.c}
for(;;) {  // "forever"
    printf("我将一遍又一遍地打印这条信息。\n" );
    printf("直到宇宙的热死亡。\n");

    printf("要么直到你按下CTRL+C键。\n");
}
```
[i[`for`语句]>]

### `switch`语句 {#switch-statement}

[i[`switch`语句]<]
根据你之前使用的编程语言不同，你可能对`switch`语句感到陌生，或者C语言的版本可能比你习惯的更加严格。这个语句允许你根据整数表达式的值采取不同的操作。

基本上，它将一个表达式求值为整数值，然后跳转到对应该值的[i[`case`子句]<]。执行将从该点继续。如果遇到`break`[i[`break`语句]<]语句，则执行会跳出`switch`语句。

这里是一个例子，对于给定数量的山羊，我们打印出这是多少只山羊的感觉。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int goat_count = 2;

    switch (goat_count) {
        case 0:
            printf("你没有山羊。\n");
            break;

        case 1:
            printf("你有一只山羊。\n");
            break;

        case 2:
            printf("你有两只山羊。\n");
            break;

        default:
            printf("你拥有众多的山羊！\n");
            break;
    }
}
```

在这个例子中，`switch` 会跳到 `case 2` 并从那里开始执行。当（如果）遇到 `break` 时，会跳出 `switch`。[对 [i[`break` 语句]>]进一步解释]

你也可能会在底部看到 `default` 标签。这表示当没有任何情况符合时会执行这部分代码。

每个 `case`，包括 `default`，都是可选的。它们可以按照任意顺序出现，但通常会将 `default`（如果有的话）排在最后。[对 [i[`case` 语句]>]进一步解释]

因此，整个结构就像一个 `if`-`else` 级联:

``` {.c}
if (goat_count == 0)
    printf("You have no goats.\n");
else if (goat_count == 1)
    printf("You have a singular goat.\n");
else if (goat_count == 2)
    printf("You have a brace of goats.\n");
else
    printf("You have a bona fide plethora of goats!\n");
```

有一些关键区别:

* `switch` 更快，可以跳转到正确的代码（尽管规范并没有做出这样的保证）。
* `if`-`else` 可以处理关系条件（如 `<` 和 `>=`）以及浮点数等其他类型，而 `switch` 不能。

关于 `switch` 还有一个有趣的功能，有时会遇到，那就是 _fall through_。

[i[`break` 语句]<]
记得 `break` 会让我们跳出 `switch` 吗？

[i[Fall through]<]
那么，如果我们 _不_ 使用 `break` 会发生什么？

结果就是我们会继续执行下一个 `case`！示例：

``` {.c}
switch (x) {
    case 1:
        printf("1\n");
        // Fall through!
    case 2:
        printf("2\n");
        break;
    case 3:
        printf("3\n");
        break;
}
```

如果 `x == 1`，这个 `switch` 首先会碰到 `case 1`，打印出 `1`，然后继续执行下一行代码... 打印出 `2`！

最后，当遇到 `break` 时，我们会跳出 `switch`。

```c
if (x == 2) {
    printf("2");
    break; // as normal
}

// Not having a `break` is called _fall through_.

ProTip: _ALWAYS_ put a comment in the code where you intend to fall through, like I did above. It will save other programmers from wondering if you meant to do that.
[i[Fall through]>]

In fact, this is one of the common places to introduce bugs in C programs: forgetting to put a `break` in your `case`. You gotta do it if you don't want to just roll into the next case^[This was considered such a hazard that the designers of the Go Programming Language made `break` the default; you have to explicitly use Go's `fallthrough` statement if you want to fall into the next case.].
[i[`break` statement]>]

Earlier I said that `switch` works with integer types---keep it that way. Don't use floating point or string types in there. One loophole-ish thing here is that you can use character types because those are secretly integers themselves. So this is perfectly acceptable:

``` {.c}
char c = 'b';

switch (c) {
    case 'a':
        printf("It's 'a'!\n");
        break;

    case 'b':
        printf("It's 'b'!\n");
        break;

    case 'c':
        printf("It's 'c'!\n");
        break;
}
```

Finally, you can use [i[`enum` keyword]]`enum`s in `switch` since they are also integer types. But more on that in the `enum` chapter.

[i[`switch` statement]>] [i[`break` statement]>] [i[Flow Control]>]
```