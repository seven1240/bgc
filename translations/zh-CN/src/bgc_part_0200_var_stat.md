<!-- Beej的C指南

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 变量和语句

> _"世界之大，怪事横生，不是吗，神父？"_ \
> _"是的，我的孩子，的确如此。"_
>
> ---海盗船长托马斯·巴塞洛缪·雷德对神父的对话，海盗

在C程序中肯定会有很多东西。

是的。

出于各种原因，如果我们分类程序中可能找到的某些类型的事物，对我们所有人来说会更容易，这样我们就能清楚地知道我们在谈论什么。

## 变量

[i[Variables]<]有人说“变量保存值”。但另一种思考方式是，变量是一个人类可读的名称，指代内存中的某些数据。

我们要停一下，从指针的兔子洞里偷看一眼。别担心。

你可以把内存看作是一个大数组的字节^[“字节”通常是一个8位二进制数。将它视为一个仅能容纳0到255之间值的整数。从技术上讲，C允许字节具有任意位数，如果您想明确地表示一个8位数字，应该使用术语_八位字节_。但程序员会假定你说“字节”时指的是8位，除非你另有说明。]. 数据存储在这个“数组”中^[这里我对现代内存的工作方式进行了极度简化。但这种心智模型是有效的，请原谅我。]. 如果一个数字大于一个字节，它将存储在多个字节中。由于内存像一个数组，所以内存中的每个字节可以通过其索引来引用。这个内存中的索引也称为_地址_、_位置_或_指针_。

当你在C语言中有一个变量时，该变量的值在内存中的某个地址上。当然。 毕竟，它还能在哪里呢？但是按照数字地址引用值是很痛苦的，所以我们给它起个名字，这就是变量的作用。

我提到所有这些的原因有两个：

1. 这会让你更容易理解指针变量，它们是存储其他变量地址的变量！
2. 同样，这会让你更容易理解指针。

因此，变量是存储在内存中某个地址的一些数据的名称。

### 变量名

可以在0-9、A-Z、a-z和下划线范围内使用任何字符来作为变量名，遵循以下规则：

* 不能用数字 0-9 开头一个变量。
* 不能以两个下划线开头作为变量名。
* 不能用下划线后跟大写字母 A-Z 作为变量名的开头。

对于Unicode，尽管试试。 规范中有一些规则在 §D.2 中讨论了标识符的哪些部分允许哪些Unicode代码点范围，但这里写起来太多了，而且很可能你永远也不用考虑这个。 

### 变量类型

根据你已经掌握的编程语言，你可能对类型的概念比较熟悉，也可能不熟悉。 但C语言对类型有些挑剔，因此我们应该来个复习。

一些示例类型，一些基本的：

[i[`int` 类型]][i[`float` 类型]][i[`char` 类型]][i[`char *` 类型]]

|类型|示例|C类型|
|:---|------:|:-----| 
|整数|`3490`|`int`|
|浮点数|`3.14159`|`float`^[这里我有点在撒谎。严格来讲，`3.14159`是`double`类型，但我们还没有讲到那里，我希望你把`float`和"浮点数"联系起来，C语言会自动将这种类型转换为`float`。简而言之，暂时不要担心这个问题，等到后面再说。]|
|字符（单个）|`'c'`|`char`|
|字符串|`"Hello, world!"`|`char *`^[读作“指向一个字符”的意思，或者叫“字符指针”。"Char"代表字符。尽管我找不到相关研究，但据说大多数人读作"char"，少数人读作"car"，还有一小部分人读作"care"。我们稍后会详细讨论指针。]|

当你要求C语言进行类型转换时，它会尽力自动转换大部分数值类型。但除此之外，所有的转换都是手动的，尤其是字符串和数字之间的转换。

C语言中的几乎所有类型都是在这些类型的变体之上的。

在使用变量之前，你必须_声明_该变量，并告诉C变量所持有的类型。一旦声明，变量的类型就不能在运行时改变。你设置的类型就是它的类型，直到它超出作用域并重新吸收到宇宙中。

让我们将之前的“Hello, world”代码稍作修改，添加一些变量进去：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i;    // 保存有符号整数，例如 -3, -2, 0, 1, 10
    float f;  // 保存有符号浮点数，例如 -3.1416

    printf("Hello, World!\n");  // 啊，熟悉的问候
}
```

好了！我们声明了几个变量。我们还没有使用它们，它们都是未初始化的。一个变量保存整数，另一个保存浮点数（实际上是一个实数，如果你有数学背景的话）。

未初始化的变量具有不确定的值。俗称，我们会说它们具有"随机"值，但它们并非真正的——甚至伪真实的——随机数。它们必须被初始化，否则你必须假设它们包含某些无意义的数字。

>这是 C 语言可以"陷害"你的地方之一。在我的经验中，大部分时间，未初始化的值是零……但可能每次运行都不同！永远不要假设值会是零，即使你看到它确实是。在使用变量之前_总是_明确地将它们初始化到某个值。[[This isn't strictly 100% true. When we get to learning about static storage duration, you'll find the some variables are initialized to zero automatically. But the safe thing to do is always initialize them.]]

这是什么？你想在这些变量中存储一些数字吗？疯了！

让我们继续下去：
[i[`=` 赋值运算符]]

``` {.c .numberLines}
int main(void)
{
    int i;

    i = 2; // 将值 2 赋予变量 i

    printf("Hello, World!\n");
}
```

牛X。我们已经存储了一个值。让我们打印它。

[i[`printf()` 函数]<]我们将通过向 `printf()` 函数传递_两个_惊人的参数来做到这一点。第一个参数是描述要打印内容和如何打印它的字符串（称为_格式字符串_），第二个是要打印的值，即变量 `i` 中的任何内容。

`printf()` 在格式字符串中搜索一系列以百分号 (`%`) 开头的特殊序列，以告诉它要打印什么。例如，如果它找到 `%d`，它会查找传递的下一个参数，并将其打印为整数。如果找到 `%f`，它会将值打印为浮点数。如果找到 `%s`，它会打印一个字符串。

因此，我们可以这样打印出各种类型的值：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i = 2;
    float f = 3.14;
    char *s = "Hello, world!";  // char * ("char pointer") 是字符串类型

    printf("%s  i = %d and f = %f!\n", s, i, f);
}
```

输出将是：

``` {.default}
Hello, world!  i = 2 and f = 3.14!
```

通过这种方式，`printf()` 类似于其他您熟悉的语言中各种类型的格式字符串或带参数的字符串。

### 布尔类型

[i[Boolean types]<]C有布尔类型，真或假？

`1`！

历史上，C没有布尔类型，有人可能会认为现在仍然没有。

在C中，`0` 表示“假”，非零表示“真”。

因此，`1` 是真。而 `-37` 是真。而 `0` 是假。

你可以将布尔类型声明为 `int`：

``` {.c}
int x = 1;

if (x) {
    printf("x is true!\n");
}
```

如果您`#include <stdbool.h>`[i[`stdbool.h` header file]]，您也可以获得一些符号名称，这可能会使事情看起来更加熟悉，即 `bool`[i[`bool` type]] 类型以及 `true`[i[`true` value]] 和 `false`[i[`false` value]] 值：

``` {.c .numberLines}
#include <stdio.h>
#include <stdbool.h>

int main(void) {
    bool x = true;

    if (x) {
        printf("x is true!\n");
    }
}
```

但这些与使用整数值表示真和假是相同的，它们只是一个外观上使事情看起来好看的外表。 [i[Boolean types]>]

## 运算符和表达式 {#operators}

C运算符应该对您来说是熟悉的，来自其他语言。 让我们在这里简要介绍一些。

（这里有比这更多的细节，但我们将在本节中做足够多的内容以便入门。）

### 算术操作符

希望这些是熟悉的：
[`+` 加法运算符] [`-` 减法运算符]
[`*` 乘法运算符] [`/` 除法运算符]
[`%` 取模运算符]

``` {.c}
i = i + 3;  // 加法（+）和赋值（=）运算符，将3加到i上
i = i - 8;  // 减法，从i中减去8
i = i * 9;  // 乘法
i = i / 2;  // 除法
i = i % 5;  // 取模（除法余数）
```

对于上述所有运算符都有简写的变体。每一行可以简洁地写为：
[`+=` 赋值运算符] [`-=` 赋值运算符]
[`*=` 赋值运算符] [`/=` 赋值运算符]
[`%=` 赋值运算符]

``` {.c}
i += 3;  // 等同于 "i = i + 3"，在i上加3
i -= 8;  // 等同于 "i = i - 8"
i *= 9;  // 等同于 "i = i * 9"
i /= 2;  // 等同于 "i = i / 2"
i %= 5;  // 等同于 "i = i % 5"
```

并没有指数运算。您将需要使用`math.h`中的`pow()`函数变体之一。

让我们来看一些你可能在其他语言中没有的更奇怪的东西！

### 三元运算符

C语言也包括_三元运算符_。这是一个表达式，其值取决于嵌入其中的条件的结果。

``` {.c}
// 如果 x > 10，则向y添加17。否则向y添加37。

y += x > 10? 17: 37;
```

够乱！阅读次数越多，你会越习惯。为了帮助理解，我将使用`if`语句重新编写上述表达式：

``` {.c}
// 这个表达式:

y += x > 10? 17: 37;

// 等同于这个非表达式:

if (x > 10)
    y += 17;
else
    y += 37;
```

比较这两个，直到你看到三元运算符的各个组成部分。

或者，另一个例子，打印存储在`x`中的数字是奇数还是偶数：

``` {.c}
printf("数字 %d 是 %s。\n", x, x % 2 == 0? "偶数": "奇数");
```

在`printf()`函数中，`%s`格式说明符表示打印一个字符串。如果表达式`x % 2`的结果为`0`，整个三元表达式的值就是字符串`"偶数"`；否则就是字符串`"奇数"`。非常酷！

需要注意的是，三元操作符不像`if`语句那样用于控制流程。它只是一个会求值为一个值的表达式。

### 前缀和后缀递增和递减

现在让我们来看看另一种可能没有看过的操作。

这是传说中的后缀递增和后缀递减操作符：

``` {.c}
i++;        // 将 i 增加一（后缀递增）
i--;        // 将 i 减少一（后缀递减）
```

通常来说，这些只是作为下面代码的简写形式：

``` {.c}
i += 1;        // 将 i 增加一
i -= 1;        // 将 i 减少一
```

但它们比这更微妙，它们是些狡猾的家伙。

让我们再看看这个变种，前缀递增和前缀递减：

``` {.c}
++i;        // 将 i 增加一（前缀递增）
--i;        // 将 i 减少一（前缀递减）
```

使用前缀递增和前缀递减，变量的值会在表达式求值之前进行递增或递减。然后在使用新值求解表达式。

使用后缀递增和后缀递减，表达式的值会先根据当前值计算，然后在确定表达式的值后进行递增或递减。

你实际上可以将它们嵌入到表达式中，就像这样：

``` {.c}
i = 10;
j = 5 + i++;  // 先计算 5 + i，然后再增加 i 的值
```

```c
printf("%d, %d\n", i, j);  // 打印 11, 15
```

让我们与预增量运算符进行比较：

```c
i = 10;
j = 5 + ++i;  // 先增量 i，然后计算 5 + i

printf("%d, %d\n", i, j);  // 打印 11, 16
```

这种技术经常用于数组和指针访问和操作。它让你可以使用变量中的值，并在使用之前或之后递增或递减该值。

但是到目前为止，你最常见到的地方是在 `for` 循环中：

```c
for (i = 0; i < 10; i++)
    printf("i is %d\n", i);
```

但稍后会继续讨论。
[i[`++` 增量运算符]>] [i[`--` 减量运算符]>]

### 逗号运算符

[i[`,` 逗号运算符]<]
这是一种不常用的分隔左到右执行的表达式的方式：

```c
x = 10, y = 20;  // 首先将 10 赋值给 x，然后将 20 赋值给 y
```

看起来有点愚蠢，因为你可以用分号替代逗号，对吗？

```c
x = 10; y = 20;  // 首先将 10 赋值给 x，然后将 20 赋值给 y
```

但这有些不同。后者是两个独立的表达式，而前者是一个单一表达式！

使用逗号运算符时，逗号表达式的值是右侧表达式的值：

```c
x = (1, 2, 3);

printf("x is %d\n", x);  // 打印 3，因为 3 是逗号列表中最右边的值
```

但即使如此，也显得很牵强。逗号运算符经常用于 `for` 循环中在语句的每个部分执行多个操作：

```c
for (i = 0, j = 10; i < 100; i++, j++)
    printf("%d, %d\n", i, j);
```

稍后我们会再讨论。
[i[`,` 逗号运算符]>]

### 条件运算符

条件操作符

对于布尔值，我们有一系列标准操作符：
比较操作符 `==` 相等操作符
不等操作符 `!=`
小于操作符 `<`
大于操作符 `>`
小于或等于操作符 `<=`
大于或等于操作符 `>=`

``` {.c}
a == b;  // 如果 a 等同于 b 则为真
a != b;  // 如果 a 不等同于 b 则为真
a < b;   // 如果 a 小于 b 则为真
a > b;   // 如果 a 大于 b 则为真
a <= b;  // 如果 a 小于或等于 b 则为真
a >= b;  // 如果 a 大于或等于 b 则为真
```

不要将赋值 `=` 和比较 `==` 搞混！使用两个等号进行比较，一个等号进行赋值。

我们可以在 `if` 语句中使用比较表达式：

``` {.c}
if (a <= 10)
    printf("成功！\n");
```
布尔操作符

我们可以使用布尔操作符 _and_、_or_ 和 _not_ 来链接或修改条件表达式。
布尔 AND `&&`
布尔 NOT `!`
布尔 OR `||`

|操作符|布尔意义|
|:------:|:-------------:|
|`&&`|和|
|`||`|或|
|`!`|非|

布尔 "and" 的示例：

``` {.c}
// 如果 x 小于 10 且 y 大于 20，则执行某些操作：
if (x < 10 && y > 20)
    printf("正在执行某些操作！\n");
```

布尔 "not" 的示例：

``` {.c}
if (!(x < 12))
    printf("x 不小于 12\n");
```

`!` 的优先级比其他布尔操作符高，因此在这种情况下我们必须使用括号。

当然，这与以下语句是相同的：

``` {.c}
if (x >= 12)
    printf("x 不小于 12\n");
```

但我需要这个例子！

`sizeof` 操作符

这个操作符告诉您一个特定变量或数据类型在内存中使用的大小（以字节为单位）。

更具体地说，它告诉您特定表达式占用内存空间的大小（以字节为单位）（这可能只是一个变量）。

这个大小在不同系统上可能会有所不同，除了`char`类型及其变体（始终为 1 个字节）。

现在这可能看起来并不是很有用，但我们会在此处和其他地方引用它，所以很值得提一下。

由于这个函数计算存储类型所需的字节数，你可能认为它会返回一个`int`。或者… 因为大小不能为负，也许应该返回一个`unsigned` 型？

但事实证明C语言有一个特殊的类型来表示`sizeof`返回值。它就是`size_t`，发音为“size tee”[‘_t’代表‘type\`（类型）]。我们知道的只有它是一个无符号整数类型，可以存储任何你传递给`sizeof`的东西的大小（以字节为单位）。

`size_t`出现在许多地方，其中传递或返回某种东西的计数。可以将变量或表达式的`sizeof`应用于:

``` {.c}
int a = 999;

// %zu 是类型 size_t 的格式说明符

printf("%zu\n", sizeof a);      // 在我的系统上输出4
printf("%zu\n", sizeof(2 + 7)); // 在我的系统上输出4
printf("%zu\n", sizeof 3.14);   // 在我的系统上输出8

// 如果需要打印负的 size_t 值，请使用 %zd
```

请记住: 它是表达式的_类型_的字节数，而不是表达式本身的大小。这就是为什么`2+7`和`a`的大小相同——它们都是`int`类型。我们将在接下来的代码块中再次提到这个数字`4`…

在接下来的代码块中，您会看到可以获取类型的`sizeof`（请注意括号在类型名字周围是必需的，不像表达式周围那样）:

``` {.c}
printf("%zu\n", sizeof(int));   // 在我的系统上打印4
printf("%zu\n", sizeof(char));  // 在所有系统上打印1
```

需要注意的是 `sizeof` 是一个在编译时进行的操作。该表达式的结果完全在编译时确定，而不是在运行时确定。

我们以后会利用这一点。
[i[`sizeof`运算符]>]


## 流程控制

[i[流程控制]<]
布尔值很好，但当然如果我们无法控制程序流程，那就无从谈起了。让我们看看一些结构：`if`、`for`、`while` 和 `do-while`。

首先，让我们听一下您亲切友好的本地C开发人员关于语句和语句块的一般前瞻性说明：

类似 `if` 或 `while` 语句之后，您可以要么放一个要执行的单个语句，要么放一块要依次执行的语句。

[i[`if`语句]<]
我们先从一个单个语句开始：

``` {.c}
if (x == 10) printf("x is 10\n");
```

有时这也会单独写成一行。（在C中空格并不重要——它不像Python那样。）

``` {.c}
if (x == 10)
    printf("x is 10\n");
```

但是如果您希望由条件触发多个事情发生怎么办？您可以使用花括号来标记一个 _块_ 或 _复合语句_。

``` {.c}
if (x == 10) {
    printf("x is 10\n");
    printf("当 x 为10时也会发生这个\n");
}
```

一种非常常见的风格是 _始终_ 使用花括号，即使它们不是必需的：

``` {.c}
if (x == 10) {
    printf("x is 10\n");
}
```

一些开发人员认为这样的代码更易于阅读，并避免了这种情况的错误，即视觉上看起来像在 `if` 块中，但实际上并不属于。

``` {.c}
// 错误示例
```

如果（x == 10）
    printf（"如果 x 是 10 则发生这个事件\n"）;
    printf（"这总是发生的\n"）; // 惊喜！！无条件的！

`while` 和 `for` 以及其他循环结构的使用方式与上述示例相同。如果您想在循环中或在 `if` 之后执行多个操作，请把它们放在花括号中。

换句话说，`if` 会执行 `if` 后面的一件事。而这件事可以是一个单个语句或一段语句块。

### `if`-`else` 语句 {#ifstat}

我们已经在多个示例中使用了 `if`，因为很可能您在其他语言中已经见过它，但这里是另一个示例：

``` {.c}
int i = 10;

if (i > 10) {
    printf("是的，i 大于 10。\n");
    printf("如果 i 大于 10 也会打印这段内容。\n");
}

if (i <= 10) printf("i 小于或等于 10。\n");
```

在示例代码中，如果 `i` 大于 10 则会打印消息，否则继续执行下一行。注意 `if` 语句后面的花括号；如果条件为真，则将执行 `if` 后面的第一个语句或表达式，或者执行 `if` 后面花括号中的代码集。这种所谓的 _代码块_ 行为对所有语句都是普遍的。

当然，因为 C 语言的这种风格很有趣，您可以通过在 `if` 上使用 `else` 子句来在条件为假时执行一些操作：

``` {.c}
int i = 99;

if (i == 10)
    printf("i 是 10！\n");
else {
    printf("i 明显不是 10。\n");
    printf("这让我有点不爽，老实说。\n");
}
```

您甚至可以级联这些来测试各种条件，如此：

``` {.c}
int i = 99;

if (i == 10)
    printf("i 是 10！\n");

else if (i == 20)
    printf("i 是 20！\n");
```

否则，如果（i == 99）{
    printf("i 是 99！是我的最爱\n");
    printf("我无法告诉你我有多开心。\n");
    printf("真的。\n");
}

否则
    printf("i 是我从未听说过的疯狂数字。\n");

尽管如果你选择这种方式，请确保查看 [`switch`](#switch-statement) 语句以获取潜在更好的解决方案。问题是 `switch` 仅适用于与常数数字进行相等比较。上述 `if`-`else` 级联可以检查不等式、范围、变量或任何您可以在条件表达式中构建的其他内容。

它们基本上是相同的，除非在第一次循环条件为假时，`do-while`将执行一次，但`while`不会执行。换句话说，用 `do-while` 循环时，检查是否执行代码块的测试发生在代码块的_结尾_。而用 `while` 循环时，检查发生在代码块的_开头_。

举个例子来看：

// 使用 while 语句：

i = 10;

// 因为 i 不小于 10，所以这不会被执行：
while(i < 10) {
    printf("while: i is %d\n", i);
    i++;
}

// 使用 do-while 语句：

i = 10;

// 这会执行一次，因为循环条件直到循环体运行后才被检查到：

do {
    printf("do-while: i is %d\n", i);
    i++;
} while (i < 10);

printf("All done!\n");

请注意，在这两种情况下，循环条件立即为假。因此在 `while` 循环中，循环失败，后续代码块永远不会被执行。然而，使用 `do-while`，条件在代码块执行_后_被检查，因此它至少会执行一次。在这个示例中，它打印消息，增加 `i`，然后失败于条件，继续向 "All done!" 输出。

寓言的寓意是：如果希望无论循环条件如何至少执行一次循环，请使用 `do-while`。

所有这些示例可能用 `for` 循环做得更好。让我们做一些不太确定性的事情---重复直到出现某个特定的随机数为止！

``` {.c .numberLines}
#include <stdio.h>   // 用于 printf
#include <stdlib.h>  // 用于 rand

int main(void)
{
    int r;

    do {
        r = rand() % 100; // 获取 0 到 99 之间的随机数
        printf("%d\n", r);
    } while (r != 37);    // 直到出现 37 为止重复
}
```

旁注：你运行了多次吗？如果是的话，你有没有注意到相同的数字序列再次出现。一遍又一遍。这是因为`rand()`是一个伪随机数生成器，必须用不同的种子来初始化，才能生成不同的序列。查看[这里的`srand()`函数](https://beej.us/guide/bgclr/html/split/stdlib.html#man-srand)获取更多详细信息。

### `for`语句 

欢迎来到世界上最流行的循环之一！`for`循环！

如果您预先知道要循环的次数，这是一个非常好的循环。

您也可以使用`while`循环来做同样的事情，但`for`循环可以帮助代码更清晰。

以下是两段等效代码---请注意`for`循环只是更紧凑的表示法：

``` {.c}
// 打印0到9之间的数，包含0和9...

// 使用while语句：

i = 0;
while (i < 10) {
    printf("i is %d\n", i);
    i++;
}

// 使用for循环做完全相同的事情：

for (i = 0; i < 10; i++) {
    printf("i is %d\n", i);
}
```

没错，他们完全做着相同的事情。但你可以看到`for`语句更加简洁、易读。(JavaScript用户此时将完全赞赏其C语言的起源。)

它由三部分组成，用分号分隔。第一部分是初始化，第二部分是循环条件，第三部分是如果循环条件为真应该在块结束时发生的事情。这三部分都是可选的。

``` {.c}
for (初始化事物; 如果这是真的则循环; 每次循环后做这件事)
```

请注意，如果循环条件一开始就为假，循环不会执行一次。

**`for`循环有趣的事实！**

你可以使用逗号操作符在`for`循环的每个子句中执行多个操作！

``` {.c}
for (i = 0, j = 999; i < 10; i++, j--) {
    printf("%d, %d\n", i, j);
}
```

一个空的`for`循环将永远运行：

``` {.c}
for(;;) {  // "永远"
    printf("我将一遍又一遍地打印这个\n" );
    printf("直到宇宙热寂为止。\n");

    printf("或者直到你按下CTRL-C键。\n");
}
```

在这个例子中，`switch`会跳转到`case 2`并从那里执行。当（如果）遇到`break`时，它会跳出`switch`。

此外，您可能会在底部看到`default`标签。这就是当没有任何`case`匹配时会发生什么。

每个`case`，包括`default`，都是可选的，并且它们可以以任何顺序出现，但是通常`default`会被列在最后。

因此，整个结构的行为类似于`if`-`else`的级联结构：

``` {.c}
if (goat_count == 0)
    printf("You have no goats.\n");
else if (goat_count == 1)
    printf("You have a singular goat.\n");
else if (goat_count == 2)
    printf("You have a brace of goats.\n");
else
    printf("You have a bona fide plethora of goats!\n");
```

有一些关键的区别：

- `switch`通常更快地跳转到正确的代码（尽管规范并没有做出此类保证）。
- `if`-`else`可以处理诸如`<`和`>=`之类的关系条件，以及浮点数和其他类型，而`switch`则不行。

关于`switch`还有一个有趣的地方是有时会看到的：_贯穿_。

回忆一下，`break`会导致我们跳出`switch`，那么如果我们_不_使用`break`会发生什么呢？

结果就是我们会继续执行到下一个`case`！示例：

``` {.c}
switch (x) {
    case 1:
        printf("1\n");
        // 贯穿！
    case 2:
        printf("2\n");
        break;
    case 3:
        printf("3\n");
        break;
}
```

如果`x == 1`，这个`switch`首先会命中`case 1`，它会打印出`1`，但然后它会继续执行下一行代码... 打印出`2`！

然后最后，我们遇到一个`break`，从而跳出`switch`。

如果 `x == 2`，那么我们将匹配到 `case 2`，打印 `2`，然后像平常一样使用 `break`。

没有使用 `break` 被称为 _贯穿_。

专业提示：在代码中打算使用贯穿的地方始终加上注释，就像我上面做的那样。这会避免其他程序员疑惑你是否有意这么做。

实际上，这是在 C 程序中引入漏洞的常见地方之一：忘记在 `case` 中加上 `break`。如果你不想执行下一个 `case`，就必须这么做。
[贯穿]

之前我说过 `switch` 只适用于整数类型---保持这种方式。不要在其中使用浮点或字符串类型。但有一个漏洞的例外是你可以使用字符类型，因为它们实际上是整数。因此下面的写法完全合理：

``` {.c}
char c = 'b';

switch (c) {
    case 'a':
        printf("It's 'a'!\n");
        break;

    case 'b':
        printf("It's 'b'!\n");
        break;

    case 'c':
        printf("It's 'c'!\n");
        break;
}
```

最后，你可以在 `switch` 中使用 [枚举] 来处理，因为它们也是整数类型。但更多内容会在枚举章节中讨论。
[switch语句] [break语句] [控制流]