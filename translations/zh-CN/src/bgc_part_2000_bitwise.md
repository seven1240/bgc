<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 位操作

这些数字操作实际上允许您操作变量中的单个位，这很适合，因为C是一种底层语言^[并不是其他语言不做这个---它们做。有趣的是许多现代语言使用与C相同的位操作符]。

如果您对位操作不熟悉，[flw[Wikipedia有一篇很好的位操作文章|Bitwise_operation]]。

## 位与、或、异或和取反

对于这些操作，[通常的算术转换](#usual-arithmetic-conversions) 对操作数进行处理（在本例中必须是整数类型），然后执行适当的位操作。

|操作|运算符|示例|
|-|:-:|-|
|[i[`&` 位与]]AND|`&`|`a = b & c`|
|[i[`|` 位或]]OR|`|`|`a = b | c`|
|[i[`^` 位异或]]XOR|`^`|`a = b ^ c`|
|[i[`~` 位取反]]NOT|`~`|`a = ~c`|

请注意它们与布尔运算符`&&`和`||`的相似之处。

这些具有类似于`+=`和`-=`的赋值简写变体：

|运算符|示例|完整写法等效|
|-|-|-|
|[i[`&=` 赋值]]`&=`|`a &= c`|`a = a & c`|
|[i[`|=` 赋值]]`|=`|`a |= c`|`a = a | c`|
|[i[`^=` 赋值]]`^=`|`a ^= c`|`a = a ^ c`|

## 位移操作

对于这些操作，在每个操作数上执行了 [i[整数提升]] [整数提升](#integer-promotions)，然后执行了位移操作。结果的类型是提升后的左操作数的类型。

新的位使用零填充，下面有可能例外情况的实现定义行为。 

|操作|运算符|示例|
|-|:-:|-|
|[i[`<<` 左移]]左移|`<<`|`a = b << c`|
|[i[`>>` 右移]]右移|`>>`|`a = b >> c`|

还有相同类似的简便写法用于位移操作：

|运算符|示例|完整的写法|
|-|-|-|
|[i[`>>=` assignment]]`>>=`|`a >>= c`|`a = a >> c`|
|[i[`<<=` assignment]]`<<=`|`a <<= c`|`a = a << c`|

注意未定义行为：不要进行负数的位移，也不要进行大于提升后左操作数大小的位移。

同时要注意实现定义的行为：如果对负数进行右移操作，结果是由实现定义的。（对有符号的`int`进行右移是合理的，只需确保为正数。）

[Bitwise operations]