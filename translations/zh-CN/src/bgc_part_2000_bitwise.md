```c
// Beej的C指南

# vim: ts=4:sw=4:nosi:et:tw=72

```

# 位操作

[i[位运算]<]

这些数字操作实际上允许您操纵变量中的单个位，这很合适，因为C是一种低级语言^[不是说其他语言不做这个---它们是。有趣的是现代许多语言使用与C相同的位运算符。]。

如果您对位操作不熟悉，[flw[维基百科有一篇不错的位操作文章|Bitwise_operation]]。

## 位AND、OR、XOR和NOT运算

对于每一个，操作数（在本例中必须是整数类型）会进行[通常的算术转换](#usual-arithmetic-conversions)，然后执行适当的位运算。

|操作|运算符|示例|
|-|:-:|-|
|[i[`&` 位AND运算]]AND|`&`|`a = b & c`|
|[i[`|` 位OR运算]]OR|`|`|`a = b | c`|
|[i[`^` 位XOR运算]]XOR|`^`|`a = b ^ c`|
|[i[`~` 位NOT运算]]NOT|`~`|`a = ~c`|

请注意它们与布尔运算符`&&`和`||`的相似之处。

它们有类似于`+=`和`-=`的简写赋值变体：

|运算符|示例|完整写法等效|
|-|-|-|
|[i[`&=` 赋值]]`&=`|`a &= c`|`a = a & c`|
|[i[`|=` 赋值]]`|=`|`a |= c`|`a = a | c`|
|[i[`^=` 赋值]]`^=`|`a ^= c`|`a = a ^ c`|

## 位移操作

对于这些，会对每个操作数（必须是整数类型）执行[整数提升](#integer-promotions)，然后执行位移操作。结果的类型是所提升的左操作数的类型。

新位用零填充，具体行为可能有实现定义，下面有可能的例外情况。

|操作|运算符|示例|
|-|:-:|-|
|[i[`<<` 左移]]左移|`<<`|`a = b << c`|
|[i[`>>` 右移]]右移|`>>`|`a = b >> c`|
```

```c
...

在进行移位操作时也有类似的简写形式：

|运算符|示例|完整形式|
|-|-|-|
|[i[`>>=` 赋值]]`>>=`|`a >>= c`|`a = a >> c`|
|[i[`<<=` 赋值]]`<<=`|`a <<= c`|`a = a << c`|

注意未定义行为：不要对负数进行左移位操作，也不要左移超过被提升的左操作数的大小。

同时要注意实现定义的行为：如果对一个负数进行右移位操作，结果是实现定义的。（对有符号的`int`进行右移是可以的，只要确保它是正数。）

[i[位运算]>]

```