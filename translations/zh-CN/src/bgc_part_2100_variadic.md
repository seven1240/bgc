<!-- C语言指南

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 可变参数函数

可变参数是指接受任意数量参数的函数。

常规函数接受特定数量的参数，例如：

``` {.c}
int add(int x, int y)
{
    return x + y;
}
```

您只能使用两个参数调用该函数，分别对应参数`x`和`y`。

``` {.c}
add(2, 3);
add(5, 12);
```

但如果您尝试传入更多参数，编译器将不允许：

``` {.c}
add(2, 3, 4);  // 错误
add(5);        // 错误
```

可变参数函数在一定程度上绕过了这种限制。

我们已经在`printf()`中看到了一个著名的例子！您可以向它传递各种各样的参数。

``` {.c}
printf("Hello, world!\n");
printf("The number is %d\n", 2);
printf("The number is %d and pi is %f\n", 2, 3.14159);
```

它似乎不在乎您传递了多少参数！

嗯，这并不完全正确。没有参数会导致错误：

``` {.c}
printf();  // 错误
```

这引出了C语言中可变参数函数的一个限制：它们必须至少有一个参数。

但除此之外，它们相当灵活，甚至允许参数具有不同的类型，就像`printf()`一样。

让我们看看它们是如何工作的！

## 函数签名中的省略号

那么，从语法上讲，它是如何工作的呢？

您要做的事情是将必须首先传递的所有参数（记住，至少要有一个参数）放在首位，然后在后面放上`...`。就像这样：

``` {.c}
void func(int a, ...)   // 这里实际上是3个点
```

以下是用于演示的一些代码：

``` {.c}
#include <stdio.h>

void func(int a, ...)
{
    printf("a is %d\n", a);  // 输出"a is 2"
}

int main(void)
{
    func(2, 3, 4, 5, 6);
}
```

很好，我们可以获得变量 `a` 中的第一个参数，但是其余参数呢？ 如何访问它们？

现在让我们开始！ 

## 获取额外的参数

您需要包含头文件 [i[`stdarg.h` header file]] `<stdarg.h>` 才能使任何此工作。

首先，我们将使用类型为 `va_list`（可变参数列表）的特殊变量来跟踪我们每次访问的变量。

我们首先使用 `va_start()` 调用开始处理参数，然后使用 `va_arg()` 逐个处理每个参数，最后用 `va_end()` 结束处理。

调用 `va_start()` 时，您需要传递_最后一个命名参数_（紧挨着 `...` 的参数），以便它知道从哪里开始查找额外的参数。

调用 `va_arg()` 获取下一个参数时，您需要告诉它要获取的参数类型。

这里有一个演示，它将任意数量的整数相加。第一个参数是要相加的整数数量。我们将利用这个参数来确定我们需要调用 `va_arg()` 多少次。

``` {.c .numberLines}
#include <stdio.h>
#include <stdarg.h>

int add(int count, ...)
{
    int total = 0;
    va_list va;

    va_start(va, count);   // 从 "count" 之后的参数开始

    for (int i = 0; i < count; i++) {
        int n = va_arg(va, int);   // 获取下一个整数

        total += n;
    }

    va_end(va);  // 完成

    return total;
}

int main(void)
{
    printf("%d\n", add(4, 6, 2, -4, 17));  // 6 + 2 - 4 + 17 = 21
    printf("%d\n", add(2, 22, 44));        // 22 + 44 = 66
}
```

翻译成简体中文：

[[i[`va_start()`宏]>]]
[[i[`va_end()`宏]>]]

（请注意，当调用`printf()`时，它使用格式字符串中`%d`（或其他内容）的数量来确定还有多少额外的参数！）

如果`va_arg()`的语法让你感到陌生（因为其中有一个松散的类型名称），你并不是一个人。这些是用预处理器宏实现的，以便在其中包含所有正确的魔法。

## `va_list`功能

我们上面正在使用的`va_list`变量是什么？它是一个不透明变量^[也就是说，我们这些普通开发者不应该知道其中含有什么或代表什么。规范并没有详细要求它的具体内容。]，它保存了关于我们将通过`va_arg()`获取的下一个参数的信息。你看，在这里我们反复调用`va_arg()`？`va_list`变量是一个占位符，迄今为止一直在追踪进展。

[[i[`va_start()`宏]<]]

但是我们必须将该变量初始化为一些明智的值。这就是`va_start()`发挥作用的地方。

当我们调用`va_start(va, count)`时，我们是在说，“将`va`变量初始化为指向`count`之后的变长参数立即之后的位置”。

[[i[`va_end()`宏]<]]

这就是我们需要在我们的参数列表中至少有一个命名变量的原因^[老实说，从语言中删除这种限制是可能的，但是这里的想法是`va_start()`、`va_arg()`和`va_end()`宏应该能够在C中编写。要做到这一点，我们需要某种方式来初始化指向第一个参数位置的指针。为了实现该目标，我们需要第一个参数的_名称_。为了使这成为可能，可能需要语言扩展，迄今为止委员会尚未找到这样做的根据。]。

一旦你有了指向初始参数的指针，你可以通过反复调用 `va_arg()` 轻松地获取后续参数值。在这样做时，你必须传入你的 `va_list` 变量（以便它可以继续跟踪你所在的位置），以及你即将复制的参数类型。

作为程序员，你需要自己决定要传递给 `va_arg()` 的类型。在上面的例子中，我们只处理了 `int`。但在 `printf()` 的情况下，它使用格式说明符来确定下一个要提取的类型。

最后，在完成后，调用 `va_end()` 来结束。你**必须**（规范中说）在决定再次调用 `va_start()` 或 `va_copy()` 之前对特定的 `va_list` 变量调用这个。我知道我们还没有讨论 `va_copy()`。

因此，标准的步骤是：

- `va_start()` 初始化你的 `va_list` 变量
- 重复调用 `va_arg()` 来获取值
- `va_end()` 取消初始化你的 `va_list` 变量

我之前也提到了 `va_copy()`；它会复制你的 `va_list` 变量的当前状态。也就是说，如果你还没有使用 `va_arg()` 开始处理源变量，新的变量也不会开始。如果你已经使用 `va_arg()` 处理了5个变量，复制品也会反映这一点。

如果你需要在参数中向前扫描但同时需要记住当前位置，`va_copy()` 可以派上用场。

## 使用 `va_list` 的库函数

对于这些的另一个很酷的用途是：编写自己定制的 `printf()` 变体。处理所有这些格式说明符会很痛苦吧？所有这么多？

幸运的是，有一些接受工作中的 `va_list` 作为参数的 `printf()` 变体。您可以使用这些来封装并制作自己的自定义 `printf()`！

这些函数以字母 `v` 开头，比如 `vprintf()`、`vfprintf()`、`vsprintf()` 和 `vsnprintf()`。基本上所有您熟悉的 `printf()` 旧版本，只是在前面加上了一个 `v`。

让我们创建一个名为 `my_printf()` 的函数，它的工作方式与 `printf()` 完全相同，只是它在前面接受额外的参数。

``` {.c .numberLines}
#include <stdio.h>
#include <stdarg.h>

int my_printf(int serial, const char *format, ...)
{
    va_list va;

    // 做一些自定义工作
    printf("序列号为：%d\n", serial);

    // 然后将剩余内容传递给 vprintf()
    va_start(va, format);
    int rv = vprintf(format, va);
    va_end(va);

    return rv;
}

int main(void)
{
    int x = 10;
    float y = 3.2;

    my_printf(3490, "x 为 %d, y 为 %f\n", x, y);
}
```

看到我们在第12-14行做了什么了吗？我们创建了一个新的 `va_list` 变量，然后直接将其传递给 `vprintf()`。它知道该怎么处理它，因为它内置了所有 `printf()` 的智能机制。

尽管如此，我们在结束时仍需要调用 `va_end()`，所以别忘记这一点！