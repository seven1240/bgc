<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 变长函数

**变长函数** 是指可以接受任意数量参数的函数。

普通函数只能接受特定数量的参数，例如：

``` {.c}
int add(int x, int y)
{
    return x + y;
}
```

你只能用恰好两个参数调用它，分别对应参数 `x` 和 `y`。

``` {.c}
add(2, 3);
add(5, 12);
```

但如果你试图使用更多参数，编译器会报错：

``` {.c}
add(2, 3, 4);  // 错误
add(5);        // 错误
```

变长函数可以在一定程度上解决这个限制。

我们已经在 `printf()` 函数里见过这样的例子！你可以向它传递各种类型的参数。

``` {.c}
printf("Hello, world!\n");
printf("The number is %d\n", 2);
printf("The number is %d and pi is %f\n", 2, 3.14159);
```

看起来它好像并不在乎你传递了多少参数！

不过，这并非完全正确。不传递参数将导致错误：

``` {.c}
printf();  // 错误
```

这带我们来到 C 语言中变长函数的一个限制之一：必须至少有一个参数。

不过除此之外，变长函数还是相当灵活的，甚至允许参数具有不同的类型，就像 `printf()` 一样。

让我们看看它们是如何工作的！

## 函数签名中的省略号

那么从语法上来说，它是如何工作的呢？

**[`...` 变长参数]**

你需要将所有**必须**传递的参数放在第一个（记住至少要有一个），然后在其后加上 `...`。就像这样：

``` {.c}
void func(int a, ...)   // 这里确实有3个点
```

下面是一个演示代码：

``` {.c}
#include <stdio.h>

void func(int a, ...)
{
    printf("a is %d\n", a);  // 输出 "a is 2"
}

int main(void)
{
    func(2, 3, 4, 5, 6);
}
```

```markdown
[i[`...`可变参数]>]

所以，太棒了，我们可以获得变量`a`中的第一个参数，但是其他参数呢？如何访问它们呢？

现在有趣的部分开始了！

## 获取额外的参数

您需要包括[i[`stdarg.h`头文件]] `<stdarg.h>`才能使任何参数都起作用。

[i[`va_list`类型]<]

首先，我们将使用`va_list`类型（可变参数列表）的特殊变量来跟踪我们每次访问的变量。

[i[`va_start()`宏]<]
[i[`va_arg()`宏]<]
[i[`va_end()`宏]<]

我们首先通过调用`va_start()`开始处理参数，在每个参数上使用`va_arg()`逐个处理参数，然后在结束时用`va_end()`结束。

当您调用`va_start()`时，需要传入“最后一个命名参数”（就是`...`之前的参数），以便它知道从哪里开始查找额外的参数。

当您调用`va_arg()`获取下一个参数时，您必须告诉它要获取的参数类型。

这是一个演示，将任意数量的整数相加。第一个参数是要相加的整数数量。我们将利用这一点来确定我们需要调用`va_arg()`多少次。

``` {.c .numberLines}
#include <stdio.h>
#include <stdarg.h>

int add(int count, ...)
{
    int total = 0;
    va_list va;

    va_start(va, count);   // 从“count”后的参数开始

    for (int i = 0; i < count; i++) {
        int n = va_arg(va, int);   // 获取下一个整数

        total += n;
    }

    va_end(va);  // 完成

    return total;
}

int main(void)
{
    printf("%d\n", add(4, 6, 2, -4, 17));  // 6 + 2 - 4 + 17 = 21
    printf("%d\n", add(2, 22, 44));        // 22 + 44 = 66
}
```

```c
[i[`va_start()` 宏]<]
[i[`va_end()` 宏]<]

（请注意，当调用 `printf()` 时，它会根据格式字符串中 `%d` 的数量（或其他内容）来确定有多少额外的参数！）

若 `va_arg()` 的语法看起来很奇怪（因为里面有松散的类型名称漂浮在那里），你并不孤单。这些是通过预处理器宏来实现的，以便在其中包含所有正确的魔法。

## `va_list` 功能

那个我们在上面使用的 `va_list` 变量是什么？它是一个不透明变量，^[也就是说，我们这些低级开发人员不该知道里面有什么或是它的含义。规范没有详细说明它是什么。] 用来保存关于接下来我们要用 `va_arg()` 获取哪个参数的信息。你看，我们是如何一遍又一遍地调用 `va_arg()` 的？`va_list` 变量就是一个占位符，记录了迄今为止的进展。

[i[`va_start()` 宏]<]

但是我们必须将那个变量初始化为一些合理的值。这就是 `va_start()` 起作用的地方。

当我们上面调用 `va_start(va, count)` 时，我们是在说，“将 `va` 变量初始化为指向`count` 之后的第一个可变参数”。

[i[`va_end()` 宏]<]

这就是我们为什么需要在我们的参数列表中至少有一个命名变量的原因^[老实说，从语言上去除这种限制是可能的，但是这些宏 `va_start()`、`va_arg()` 和 `va_end()` 应该能够以 C 语言编写。为了实现这一点，我们需要一种方法来初始化指向第一个参数的指针。为了做到这一点，我们需要第一个参数的_名称_。这需要进行语言扩展才能实现，并且迄今为止委员会还没有找到这样做的理由。]。
```

```c
一旦你得到了指向初始参数的指针，你可以通过反复调用 `va_arg()` 轻松地获取后续的参数值。在这个过程中，你需要传入你的 `va_list` 变量（这样它才能继续跟踪你的位置），以及你要复制的参数类型。

作为程序员，你需要自己确定要传递给 `va_arg()` 的类型。在上面的例子中，我们只传递了 `int`。但在 `printf()` 的情况下，它使用格式说明符来决定下一个要取出的参数类型。

当一切完成时，调用 `va_end()` 来结束它。**必须**（规范要求）在决定再次调用 `va_start()` 或 `va_copy()` 之前，要在特定的 `va_list` 变量上调用这个函数。我知道我们还没有讨论 `va_copy()`。

所以标准的进展顺序是:

* `va_start()` 初始化你的 `va_list` 变量
* 反复使用 `va_arg()` 来获取值
* `va_end()` 来取消初始化你的 `va_list` 变量

[i[`va_start()` 宏]>]
[i[`va_end()` 宏]>]
[i[`va_arg()` 宏]>]

[i[`va_copy()` 宏]<]

我也提到了 `va_copy()`；它会复制你的 `va_list` 变量，复制品处于完全相同的状态。也就是说，如果你还没有用源变量开始执行 `va_arg()`，新的变量也不会开始。如果你已经使用 `va_arg()` 消耗了5个变量，复制品也会反映这一点。

`va_copy()` 可以在你需要查看参数但又需要记住当前位置时很有用。

[i[`va_copy()` 宏]>]

## 使用 `va_list` 的库函数

[i[将 `va_list` 类型-->传递给函数]<]

其中另一个很酷的用途是：编写你自己的自定义 `printf()` 变体。处理所有这些格式说明符会很繁琐对吧？成千上万个？
```

幸运的是，有`printf()`的变体可接受工作中的`va_list`作为参数。您可以使用这些来封装并创建自定义的`printf()`！

[*[`vprintf()`函数]<]

这些函数以字母`v`开头，比如`vprintf()`、`vfprintf()`、`vsprintf()`和`vsnprintf()`。基本上是您熟悉的所有`printf()`老朋友，只是前面加了个`v`。

让我们创建一个名为`my_printf()`的函数，其用法与`printf()`完全相同，只是额外接受一个参数作为开头。

``` {.c .numberLines}
#include <stdio.h>
#include <stdarg.h>

int my_printf(int serial, const char *format, ...)
{
    va_list va;

    // 自定义处理
    printf("序列号是：%d\n", serial);

    // 然后将剩余工作交给vprintf()
    va_start(va, format);
    int rv = vprintf(format, va);
    va_end(va);

    return rv;
}

int main(void)
{
    int x = 10;
    float y = 3.2;

    my_printf(3490, "x是%d，y是%f\n", x, y);
}
```

看到我们做了什么了吗？在12-14行，我们创建了一个新的`va_list`变量，然后直接传递给`vprintf()`。它知道如何处理它，因为内置了所有`printf()`的智能功能。

[*[`vprintf()`函数]>]

不过，当完成时我们仍然需要调用`va_end()`，所以别忘了这一步！

[*[`va_list`类型-->传递给函数]<]
[*[`va_list`类型]<]
[*[可变参数函数]>]