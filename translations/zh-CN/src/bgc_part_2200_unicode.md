<!-- C语言指南

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# Unicode、宽字符和相关内容

在我们开始之前，请注意C语言在不断发展中，解决一些... 嗯， "成长的烦恼"。当C2x发布时，这里的更新是可能的。

大多数人基本上对一个看似简单的问题感兴趣，即，“我如何在C中使用某个字符集？”我们将会讨论这个问题。但正如我们将看到的，它可能已经在你的系统上运行了。或者你可能不得不转向第三方库。

在本章中，我们将讨论很多内容---有些是跨平台的，有些是特定于C语言的。

首先让我们得到一个概述，我们将要看的内容有：

* Unicode背景
* 字符编码背景
* 源和执行字符集
* 使用Unicode和UTF-8
* 使用其他字符类型，如`wchar_t`，`char16_t` 和 `char32_t`

让我们开始吧！

## 什么是Unicode？

早些时候，美国和世界大部分地区使用7位或8位编码来表示内存中的字符。这意味着我们可以总共有128或256个字符（包括不可打印字符）。这对于以美国为中心的世界来说没问题，但事实证明，实际上还有其他字母表存在---谁知道呢？ 汉字有超过50,000个字符，这是无法放入一个字节中的。

所以人们想出了各种各样的替代方式来表示他们自己的自定义字符集。这没问题，但最终变成了一个兼容性的噩梦。

为了应对这个问题，Unicode 应运而生。一个字符集来统治它们所有。
它一直延伸至无穷（实际上），因此我们永远不会用完空间来存储新的字符。它包含了中文、拉丁文、希腊文、楔形文字、国际象棋符号、表情符号……几乎包括所有的内容！而且不断有新内容被添加进来！

## 代码点

[i[Unicode-->代码点]<]

我想在这里谈论两个概念。这有点令人困惑，因为它们都是数字…… 不同的数字代表同一件事情。但请跟着我走。

让我们宽泛地定义 _代码点_ 为表示一个字符的数值。（代码点也可以代表不可打印的控制字符，但请假设我说的是像字母 "B" 或字符 "π" 这样的东西。）

每个代码点代表一个唯一字符。而每个字符都有一个与之关联的唯一数值代码点。

例如，在 Unicode 中，数值 66 代表 "B"，而 960 代表 "π"。其它不是 Unicode 的字符映射可能使用不同的值，但让我们忘记它们，专注于 Unicode，未来的发展吧！

所以这是一个事实：每个字符都有一个代表它的数值。在 Unicode 中，这些数值范围从 0 到 100 万以上。

[i[Unicode-->代码点]>]

明白了吗？

因为我们马上要稍微改变话题。

## 编码

[i[Unicode-->编码]<]

如果你还记得，一个 8 位字节可以存储的值范围从 0 到 255。对于 "B" 来说非常适用，因为它的值是 66——可以放进一个字节。但是对于 "π" 来说，它的值是 960，一个字节容纳不下！我们需要另一个字节。我们该如何在内存中存储所有这些呢？又或者像 195,024 这样更大的数值呢？这将需要多个字节来存储。

最大的问题是：这些数值如何在内存中表示？这就是我们所谓的字符 _编码_。

因此，我们有两个要素：一个是代码点，有效地告诉我们特定字符的序号。另一个是编码，告诉我们如何在内存中表示这个序号。

有很多种编码方式。如果你愿意，你现在可以自己创造一个编码方式[例如，我们可以将代码点存储在大端 32 位整数中。直接明了！我们刚刚创造了一个编码方式！实际上不是这样；这就是 UTF-32BE 编码方式。唉——回到原点！]。但我们将会看一些与 Unicode 一起使用的非常常见的编码方式。

[Unicode-->UTF-8]
[Unicode-->UTF-16]
[Unicode-->UTF-32]

|编码方式|描述|
|:-----------------:|:--------------------------------------------------------------|
|UTF-8|一个以字节为单位的编码方式，每个字符使用可变数量的字节。这是应该使用的编码方式。|
|UTF-16|一个每字符 16 位的编码方式。|
|UTF-32|一个每字符 32 位的编码方式。|

技术上讲，UTF-16 和 UTF-32 是可变宽度的——有一种方法可以通过将两个 UTF-16 字符结合在一起来表示大于 $2^{16}$ 的代码点。

对于 UTF-16 和 UTF-32，字节顺序很重要，因此你可能会看到 UTF-16BE 代表大端和 UTF-16LE 代表小端。UTF-32 同样如此。技术上，如果没有指定，应该假设为大端。但由于 Windows 广泛使用 UTF-16 且为小端，有时可能会被认定为小端。

让我们看一些示例。我会用十六进制写出数值，因为每个 8 位字节正好是两位十六进制数，这样更容易看出内存中的排列方式。

|字符|代码点|UTF-16BE|UTF-32BE|UTF-16LE|UTF-32LE|UTF-8|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|`A`|41|0041|00000041|4100|41000000|41|
|`B`|42|0042|00000042|4200|42000000|42|
|`~`|7E|007E|0000007E|7E00|7E000000|7E|
|`π`|3C0|03C0|000003C0|C003|C0030000|CF80|
|`€`|20AC|20AC|000020AC|AC20|AC200000|E282AC|

在这里寻找模式。请注意，UTF-16BE 和 UTF-32BE 简单地将代码点直接表示为 16 位和 32 位的值。[[pagebreak]]

小端序是相同的，只是字节按小端序排列。

然后是 UTF-8。首先你可能注意到单字节的代码点被表示为单个字节。这很好。你可能还注意到不同的代码点需要不同字节数。这是一种可变长度编码。

一旦超过某个数值，UTF-8 就开始使用额外的字节来存储数值。它们似乎也不与代码点值相关联。

[flw[UTF-8 编码的细节|UTF-8]] 超出了本指南的范围，但知道每个代码点有不同数量的字节，这些字节的值与代码点不匹配（除了前 128 个代码点）就足够了。如果你确实想了解更多，[fl[Computerphile 有一部由 Tom Scott 主讲的关于 UTF-8 的出色视频|https://www.youtube.com/watch?v=MijmeoH9LT4]]。

关于 Unicode 和 UTF-8 的一个有趣之处是，从北美的角度看，UTF-8 是与 7 位 ASCII 编码向后兼容的！因此，如果你习惯 ASCII，UTF-8 也一样！每个 ASCII 编码的文档也是 UTF-8 编码的！（但反之则不一定）。

这可能是推动UTF-8占领世界的最后一个要点，胜过其他任何因素。

## 源码和执行字符集

在使用C语言编程时，至少有三个字符集在起作用：

* 存储在磁盘上源码所在的字符集。
* 编译器编译开始时将源码翻译成的字符集（源字符集）。这可能与存储在磁盘上的字符集相同，也可能不同。
* 编译器将源字符集转换为执行时的字符集（执行字符集）。这可能与源字符集相同，也可能不同。

您的编译器可能有选项可以在构建时选择这些字符集。

基本的源码和执行字符集将包含以下字符：

``` {.default}
A B C D E F G H I J K L M
N O P Q R S T U V W X Y Z
a b c d e f g h i j k l m
n o p q r s t u v w x y z
0 1 2 3 4 5 6 7 8 9
! " # % & ' ( ) * + , - . / :
; < = > ? [ \ ] ^ _ { | } ~
space tab vertical-tab
form-feed end-of-line
```

这些是您可以在源码中使用且保持100%可移植性的字符。

执行字符集还会额外包含响铃、退格、回车和换行等字符。

但大多数人不会如此极端，并且自由地在源码和可执行文件中使用扩展字符集，特别是现在Unicode和UTF-8变得更加普遍。我是说，基本字符集甚至不允许使用`@`、`$`或`` ` ``！

值得注意的是，仅使用基本字符集输入Unicode字符是一件痛苦的事情（尽管通过转义序列是可能的）。

## 在C中的Unicode

在我讲述C中的编码之前，让我们从字符代码点的角度谈谈Unicode。在C中有一种方法可以指定Unicode字符，这些字符将被编译器转换为执行字符集^[很可能编译器会尽最大努力将代码点转换为输出编码，但在规范中我找不到任何保证]。

那么我们该怎么做呢？

比如欧元符号，代码点为0x20AC。（我用十六进制写出来是因为在C中有两种方式表示它，都需要用到十六进制。）我们怎样将它放入我们的C代码中呢？

使用`\u`转义将其放入字符串中，比如 `"\u20AC"`（大小写对于十六进制没有影响）。在`\u`后必须精确地加上**四个**十六进制数字，必要时用前导零填充。

这里有一个例子：

``` {.c}
char *s = "\u20AC1.23";

printf("%s\n", s);  // €1.23
```

`\u`适用于16位Unicode代码点，那么大于16位的怎么处理呢？对于这种情况，我们需要用大写字母：`\U`。

例如：

``` {.c}
char *s = "\U0001D4D1";

printf("%s\n", s);  // 打印数学字母"B"
```

和`\u`一样，只是使用32位而不是16位。以下两个是等价的：

``` {.c}
\u03C0
\U000003C0
```

再次强调，这些在编译期间被转换为[i[Character sets-->execution]]执行字符集。它们代表Unicode代码点，而不是任何特定编码。此外，如果一个Unicode代码点无法在执行字符集中表示，编译器可以任意处理它。

现在，您可能会想为什么不能直接这样做：

``` {.c}
char *s = "€1.23";

printf("%s\n", s);  // €1.23
```

可能您可以这样做，使用现代编译器。[i[Character sets-->source]]源字符集会被编译器转换为[i[Character sets-->execution]]执行字符集。但是，如果编译器发现任何不在其扩展字符集中的字符，它们可以选择报错，而€符号显然不在[i[Character sets-->basic]]基本字符集中。

[i[`\u` Unicode escape]<]
[i[`\U` Unicode escape]<]

在规范中有一条警告：不能使用 `\u` 或 `\U` 来编码小于 0xA0 的任何代码点，除了 0x24（`$`）、0x40（`@`）和 0x60（``` ）——是的，这恰好是基本字符集中缺失的三个常见标点符号。显然，这种限制在即将发布的规范的上一版本中有所放宽。

[i[`\u` Unicode escape]>]
[i[`\U` Unicode escape]>]

最后，您也可以在代码中的标识符中使用这些，但有一些限制。但我不想在这里深入讨论。在本章中，我们只讨论字符串处理。

这基本上就是关于C语言中的Unicode的全部内容（除了编码）。

## 在我们深入细节之前，简要介绍UTF-8 {#utf8-quick}

[i[Unicode-->UTF-8]<]

磁盘上的源文件，扩展源字符和扩展执行字符都可能是UTF-8格式。您使用的库也期望是UTF-8。这就是UTF-8无处不在的光明未来。

如果是这种情况，并且您不介意在不支持这种格式的系统上不可移植，那就继续。随意在您的源代码和数据中放入Unicode字符。使用普通的C字符串，保持快乐。

许多事情会正常工作（虽然不可移植），因为UTF-8字符串可以像任何其他C字符串一样安全地以NUL结尾。但也许为了更容易处理字符，您愿意牺牲移植性也是值得的。

但是也有一些注意事项：

* 像`strlen()`这样的函数报告字符串中的字节数，而不一定是字符数。（在将其转换为宽字符时，[i[`mbstowcs()`函数-->使用UTF-8]]`mbstowcs()`返回字符串中的字符数。POSIX将其扩展，这样您可以将第一个参数设为`NULL`，如果您只想获得字符计数的话。）

* 以下函数不适用于多字节字符： [i[`strtok()`函数-->使用UTF-8]]`strtok()`， [i[`strchr()`函数-->使用UTF-8]]`strchr()`（改用[i[`strstr()`函数-->使用UTF-8]]`strstr()`），`strspn()`类型函数， [i[`toupper()`函数-->使用UTF-8]] `toupper()`， [i[`tolower()`函数-->使用UTF-8]]`tolower()`， [i[`isalpha()`函数-->使用 UTF-8]]`isalpha()`-类型函数，可能还有其他。注意任何操作字节的函数。

* `printf()`变种函数允许以一种只打印字符串的多少个字节的方式打印^[例如，使用格式说明符"%.12s"。]。您需要确保打印正确数量的字节以在字符边界结束。

* 如果您想为字符串`malloc()`空间，或为其声明一个`char`数组，要注意最大大小可能会超出您的预期。每个字符最多可能占用[i[`MB_LEN_MAX`宏]]`MB_LEN_MAX`字节（来自`<limits.h>`）---除了基本字符集中保证为一个字节的字符。

可能还有其他一些我还没发现的漏洞。让我知道有哪些陷阱……

[i[Unicode-->UTF-8]>]

## 不同字符类型

我想介绍更多字符类型。我们习惯了`char`，对吧？

但那太简单了。让我们把事情变得更加困难！耶！

### 多字节字符

首先，我想潜在地改变一下您对字符串（`char`数组）的理解。这些是由_多字节字符_组成的_多字节字符串_。

没错---您日常使用的字符串是多字节的。当有人说"C字符串"时，他们指的是"C多字节字符串"。

即使字符串中的特定字符只有一个字节，或者字符串仅由单个字符组成，它也被称为多字节字符串。

例如：

``` {.c}
char c[128] = "Hello, world!";  // 多字节字符串
```

这里我们在说的是特定字符可能由多个字节组成，这些字节不在基本字符集中。最多可以有 [i[`MB_LEN_MAX` 宏]`MB_LEN_MAX` 个字节（来自 `<limits.h>`）。当然，在屏幕上看起来只有一个字符，但实际可能有多个字节。

你也可以插入Unicode值，就像我们之前看到的那样：

``` {.c}
char *s = "\u20AC1.23";

printf("%s\n", s);  // €1.23
```

但这里有点奇怪，因为看看这个：

[i[`strlen()` 函数-->使用UTF-8]<]

``` {.c}
char *s = "\u20AC1.23";  // €1.23

printf("%zu\n", strlen(s));  // 7!
```

字符串 `"€1.23"` 的长度是 `7`？！是的！在我的系统上是的！记住 `strlen()` 返回的是字符串的字节数，而不是字符数。（当我们开始讨论“宽字符”时，我们将看到如何获取字符串中的字符数。）

[i[`strlen()` 函数-->使用UTF-8]>]

请注意，虽然 C 允许单个多字节 `char` 常量（而不是 `char*`），但其行为因实现而异，你的编译器可能会发出警告。

例如，GCC 对以下两行发出多字符字符常量的警告（在我的系统上，会打印出UTF-8编码）：

``` {.c}
printf("%x\n", '€');
printf("%x\n", '\u20ac');
```

[i[多字节字符]>]

### 宽字符 {#wide-characters}

[i[宽字符]<]

如果你不是多字节字符，那么就是_宽字符_。

宽字符是一个单个值，可以唯一表示当前区域设置中的任何字符。这类似于Unicode代码点。但有可能不是。或者可能是。

基本上，多字节字符字符串是一系列字节的数组，而宽字符字符串是一系列_字符_的数组。因此，您可以开始基于逐字符的基础来思考，而不是基于逐字节的基础（后者在字符开始占用可变数量的字节时变得混乱）。

宽字符可以用多种类型来表示，但最突出的是`wchar_t`。这是主要的一个。它类似于`char`，只是宽字符。

您可能会想要知道，如果无法判断它是否是Unicode，那么在编写代码方面如何让您具备很大的灵活性呢？`wchar_t`打开了其中一些大门，因为有一套丰富的函数可以用来处理`wchar_t`字符串（例如获取长度等），而不需要关心编码。

## 使用宽字符和`wchar_t`

是时候引入一种新类型了：`wchar_t`。这是主要的宽字符类型。记得`char`只有一个字节吗？字节可能不足以表示所有字符，对吗？那这个足够了。

要使用`wchar_t`，包含`<wchar.h>`。

它有多少字节？嗯，这不是完全清楚的。可能是16位。也可能是32位。

但等等，你可能会说---如果只有16位，那不足以容纳所有Unicode代码点，对吗？你是对的---不够。规范并没有要求它这样做。它只需能够表示当前区域设置中的所有字符。

在使用具有16位`wchar_t`的平台上的Unicode可能会带来麻烦（咳咳---Windows）。但这超出了本指南的范围。

您可以使用`L`前缀声明此类型的字符串或字符，并使用`%ls`（读作"ell ess"）格式说明符打印它们。或者用`%lc`打印单个`wchar_t`。

``` {.c}
wchar_t *s = L"Hello, world!";
wchar_t c = L'B';

printf("%ls %lc\n", s, c);
```

现在---这些字符存储为 Unicode 码点还是不是？
这取决于具体实现。但你可以通过宏 [`__STDC_ISO_10646__`] 来测试它们是否是 Unicode。
如果此宏已定义，则答案是 “是的，是 Unicode！”

更详细地说，该宏中的值是一个形式为 `yyyymm` 的整数，让你知道你可以依赖于什么 Unicode 标准---不管在那个日期生效。

但是你该如何使用它们呢？

### 多字节转 `wchar_t` 转换

那么我们如何从面向字节的标准字符串转换为面向字符的宽字符串，以及反过来呢？

我们可以使用一些字符串转换函数来实现这个过程。

首先，关于这些函数你会看到一些命名约定:

* `mb`: 多字节
* `wc`: 宽字符
* `mbs`: 多字节字符串
* `wcs`: 宽字符字符串

那么如果我们想将一个多字节字符串转换为宽字符字符串，我们可以使用 `mbstowcs()`。反之亦然：`wcstombs()`。

|转换函数|描述|
|-|-|
|[`mbtowc()` 函数]`mbtowc()`|将一个多字节字符转换为宽字符。|
|[`wctomb()` 函数]`wctomb()`|将一个宽字符转换为多字节字符。|
|[`mbstowcs()` 函数]`mbstowcs()`|将一个多字节字符串转换为宽字符串。|
|[`wcstombs()` 函数]`wcstombs()`|将一个宽字符串转换为多字节字符串。|

让我们做一个快速演示，在这个演示中我们将一个多字节字符串转换为宽字符字符串，并使用它们各自的函数比较两个字符串的长度。

[`mbstowcs()` 函数]

``` {.c .numberLines}
#include <stdio.h>
#include <stdlib.h>
#include <wchar.h>
#include <string.h>
#include <locale.h>
```

``` {.c}
int main(void)
{
    // 退出C区域，进入一个可能包含欧元符号的区域
    setlocale(LC_ALL, "");

    // 带有欧元符号的原始多字节字符串（Unicode点20ac）
    char *mb_string = "The cost is \u20ac1.23";  // €1.23
    size_t mb_len = strlen(mb_string);

    // 用于存储转换后字符串的宽字符数组
    wchar_t wc_string[128];  // 最多可容纳128个宽字符

    // 将MB字符串转换为WC；这会返回宽字符的数量
    size_t wc_len = mbstowcs(wc_string, mb_string, 128);

    // 打印结果--注意宽字符字符串使用%ls
    printf("多字节字符串: \"%s\"（%zu字节）\n", mb_string, mb_len);
    printf("宽字符: \"%ls\"（%zu字符）\n", wc_string, wc_len);
}
```

在我的系统上，这会输出:

``` {.default}
多字节字符串: "The cost is €1.23"（19字节）
宽字符: "The cost is €1.23"（17字符）
```

（根据您的区域设置，字节数可能会有所不同。）

值得注意的一点是，`mbstowcs()` 除了将多字节字符串转换为宽字符外，还会返回宽字符字符串的长度（以字符计）。在兼容POSIX的系统上，您可以利用特殊模式，仅返回给定多字节字符串的字符长度：只需将目标指针设为 `NULL`，将要转换的最大字符数设为 `0`（此值将被忽略）。

（在下面的代码中，我使用了扩展的源字符集--您可能需要将其替换为 `\u` 转义字符。）

``` {.c}
setlocale(LC_ALL, "");

// 以下字符串有7个字符
size_t len_in_chars = mbstowcs(NULL, "§¶°±π€•", 0);

printf("%zu", len_in_chars);  // 7
```

再次强调，这是一个不具有可移植性的 POSIX 扩展。
```

当然，如果你想要进行相反的转换，可以使用`wcstombs()`函数。

## 宽字符功能

一旦我们进入宽字符领域，就会发现我们可以使用各种各样的功能。我在这里简要总结了一堆函数，但基本上我们这里有的是我们熟悉的多字节字符串函数的宽字符版本。（例如，我们知道对于多字节字符串有`strlen()`函数；对于宽字符字符串有`wcslen()`函数。）

### `wint_t`

很多这些函数使用`wint_t`来保存单个字符，无论是传入还是返回。

它的性质与`wchar_t`相关。`wint_t`是一个整数，可以表示扩展字符集中的所有值，也可以表示特殊的文件结束符字符`WEOF`。

这被许多面向单个字符的宽字符函数所使用。

### I/O 流取向 {#io-stream-orientation}

简而言之，不要混合使用面向字节的函数（如`fprintf()`）和面向宽字符的函数（如`fwprintf()`）。决定一个流是面向字节还是面向宽字符，并坚持使用那种类型的 I/O 函数。

更详细地说：流可以是面向字节或者面向宽字符的。当一个流被创建时，它没有取向，但第一次读取或写入会设置取向。

如果你首先使用宽字符操作（如`fwprintf()`），它会使流取向为宽字符。

如果你首先使用字节操作（如`fprintf()`），它会使流取向为字节。

您可以通过调用 `fwide()` 函数手动设置流的方向，向任何一侧。您也可以使用相同的函数来获取流的方向。

如果需要在流程中间改变方向，可以使用 `freopen()` 函数。

### 输入/输出函数

通常需要包含 `<stdio.h>` 和 `<wchar.h>` 头文件。

|I/O 函数|描述|
|-|-|
|`wprintf()`函数|格式化控制台输出。|
|`wscanf()`函数|格式化控制台输入。|
|`getwchar()`函数|基于字符的控制台输入。|
|`putwchar()`函数|基于字符的控制台输出。|
|`fwprintf()`函数|格式化文件输出。|
|`fwscanf()`函数|格式化文件输入。|
|`fgetwc()`函数|基于字符的文件输入。|
|`fputwc()`函数|基于字符的文件输出。|
|`fgetws()`函数|基于字符串的文件输入。|
|`fputws()`函数|基于字符串的文件输出。|
|`swprintf()`函数|格式化字符串输出。|
|`swscanf()`函数|格式化字符串输入。|
|`vfwprintf()`函数|变参格式化文件输出。|
|`vfwscanf()`函数|变参格式化文件输入。|
|`vswprintf()`函数|变参格式化字符串输出。|
|`vswscanf()`函数|变参格式化字符串输入。|
|`vwprintf()`函数|变参格式化控制台输出。|
|`vwscanf()`函数|变参格式化控制台输入。|
|`ungetwc()`函数|将一个宽字符推回到输出流中。|
|`fwide()`函数|获取或设置流的多字节/宽字符方向。|

### 类型转换函数

通常包含`<wchar.h>`头文件。

|转换函数|描述|
|-|-|
|[i[`wcstod()` 函数]]`wcstod()`|将字符串转换为`double`。|
|[i[`wcstof()` 函数]]`wcstof()`|将字符串转换为`float`。|
|[i[`wcstold()` 函数]]`wcstold()`|将字符串转换为`long double`。|
|[i[`wcstol()` 函数]]`wcstol()`|将字符串转换为`long`。|
|[i[`wcstoll()` 函数]]`wcstoll()`|将字符串转换为`long long`。|
|[i[`wcstoul()` 函数]]`wcstoul()`|将字符串转换为`unsigned long`。|
|[i[`wcstoull()` 函数]]`wcstoull()`|将字符串转换为`unsigned long long`。|

### 字符串和内存复制函数

通常包含`<wchar.h>`头文件。

|复制函数|描述|
|----|----------------------------------------------|
|[i[`wcscpy()` 函数]]`wcscpy()`|复制字符串。|
|[i[`wcsncpy()` 函数]]`wcsncpy()`|复制字符串，指定长度。|
|[i[`wmemcpy()` 函数]]`wmemcpy()`|复制内存。|
|[i[`wmemmove()` 函数]]`wmemmove()`|复制内存，处理可能重叠的情况。|
|[i[`wcscat()` 函数]]`wcscat()`|连接字符串。|
|[i[`wcsncat()` 函数]]`wcsncat()`|连接字符串，指定长度。|

### 字符串和内存比较函数

通常包含`<wchar.h>`头文件。

|比较函数|描述|
|-------------------|---------------------------------------------------------------|
|`wcscmp()`函数|按词典顺序比较字符串。|
|`wcsncmp()`函数|按指定长度的词典顺序比较字符串。|
|`wcscoll()`函数|按区域设置中的词典顺序比较字符串。|
|`wmemcmp()`函数|按词典顺序比较内存。|
|`wcsxfrm()`函数|将字符串转换成一种使`wcscmp()`的行为类似 `wcscoll()`[^97d0] 的版本。|

[^97d0]: `wcscoll()` 相当于先调用 `wcsxfrm()` 再调用 `wcscmp()`。

### 字符串搜索函数

通常为这些函数包含头文件 `<wchar.h>`。

|搜索函数|描述|
|-|-|
|`wcschr()`函数|在字符串中查找字符。|
|`wcsrchr()`函数|从后向前在字符串中查找字符。|
|`wmemchr()`函数|在内存中查找字符。|
|`wcsstr()`函数|在字符串中查找子串。|
|`wcspbrk()`函数|在字符串中查找任意一个字符集合中的字符。|
|`wcsspn()`函数|查找包含任意一个字符集合中的字符的子串长度。|
|`wcscspn()`函数|查找在任意一个字符集合中出现之前的子串长度。|
|`wcstok()`函数|在字符串中查找标记。|

### 长度/其他函数

通常为这些函数包含头文件 `<wchar.h>`。

|长度/其他函数|描述|
|-|-|
|`wcslen()`函数|返回字符串的长度。|
|`wmemset()`函数|在内存中设置字符。|
|`wcsftime()`函数|格式化的日期和时间输出。|

### 字符分类函数

这些函数需要包含头文件 `<wctype.h>`。

|长度/杂项函数|描述|
|-|-|
|`iswalnum()`函数|如果字符是字母数字，则为真。|
|`iswalpha()`函数|如果字符是字母，则为真。|
|`iswblank()`函数|如果字符是空白（类似空格，但不是换行符），则为真。|
|`iswcntrl()`函数|如果字符是控制字符，则为真。|
|`iswdigit()`函数|如果字符是数字，则为真。|
|`iswgraph()`函数|如果字符是可打印字符（除了空格），则为真。|
|`iswlower()`函数|如果字符是小写字母，则为真。|
|`iswprint()`函数|如果字符是可打印字符（包括空格），则为真。|
|`iswpunct()`函数|如果字符是标点符号，则为真。|
|`iswspace()`函数|如果字符是空白字符，则为真。|
|`iswupper()`函数|如果字符是大写字母，则为真。|
|`iswxdigit()`函数|如果字符是十六进制数字，则为真。|
|`towlower()`函数|将字符转换为小写。|
|`towupper()`函数|将字符转换为大写。|

## 解析状态，可重启函数

我们将对多字节转换的内部进行稍微探讨，
但这是一个很重要的概念需要理解。

想象一下你的程序如何将一系列多字节字符转换成宽字符，或者反之。在某些情况下，
程序可能正在解析一个字符的一部分，或者在确定最终值之前可能需要等待更多字节。

这个解析状态存储在类型为`mbstate_t`的不透明变量中，并且每次进行转换时都会使用它。这就是转换函数跟踪工作进度所依赖的方式。

如果在转换过程中改变了字符序列，或者试图移动到输入序列的不同位置，它可能会因此而感到困惑。

现在你可能会对这一点提出质疑：我们刚刚在上面进行了一些转换，但我从来没有在任何地方提到`mbstate_t`。

这是因为像`mbstowcs()`、`wctomb()`等的转换函数各自有自己的`mbstate_t`变量。但每个函数只有一个，所以如果你在编写多线程代码，它们使用起来就不安全了。

幸运的是，C定义了这些函数的_可重新启动_版本，在这些版本中，如果需要，你可以按每个线程的基础传入自己的`mbstate_t`。如果你在进行多线程处理，记得使用这些版本！

关于初始化`mbstate_t`变量的一个简短说明：只需用`memset()`将其清零。没有内置函数可以强制进行初始化。

``` {.c}
mbstate_t mbs;

// 将状态设置为初始状态
memset(&mbs, 0, sizeof mbs);
```

以下是可重新启动转换函数的列表---请注意在“源”类型后面加上“`r`”的命名约定：

* `mbrtowc()`---多字节转为宽字符
* `wcrtomb()`---宽字符转为多字节
* `mbsrtowcs()`---多字节字符串转为宽字符字符串
* `wcsrtombs()`---宽字符字符串转为多字节字符串

这些函数与它们的不可重新启动对应函数非常相似，不同之处在于它们要求你传入一个指向自己的`mbstate_t`变量的指针。而且它们还会修改源字符串指针（以帮助你处理无效字节），因此保存原始副本可能会很有用。

这里是本章前面的例子进行修改，以便传入我们自己的 `mbstate_t`。

``` {.c .numberLines}
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <wchar.h>
#include <string.h>
#include <locale.h>

int main(void)
{
    // 退出 C 语言环境，进入一个可能含有欧元符号的地区
    setlocale(LC_ALL, "");

    // 包含欧元符号的原始多字节字符串（Unicode 位置 20ac）
    char *mb_string = "The cost is \u20ac1.23";  // €1.23
    size_t mb_len = strlen(mb_string);

    // 将转换后的字符串存储在宽字符数组中
    wchar_t wc_string[128];  // 最多可容纳 128 个宽字符

    //设置转换状态
    mbstate_t mbs;
    memset(&mbs, 0, sizeof mbs);  // 初始状态

    // mbsrtowcs() 会修改输入指针，指向第一个无效字符，
    // 或者在成功时指向 NULL。我们复制一个指向 mb_string 的指针，
    // 供 mbsrtowcs() 使用，以免影响原始字符串。
    //
    // 此示例可能会成功，但我们稍后会进行检查。
    const char *invalid = mb_string;

    // 将 MB 字符串转换成 WC; 返回宽字符数
    size_t wc_len = mbsrtowcs(wc_string, &invalid, 128, &mbs);

    if (invalid == NULL) {
        printf("未发现无效字符\n");

        // 输出结果--注意 %ls 用于宽字符字符串
        printf("多字节: \"%s\" (%zu 字节)\n", mb_string, mb_len);
        printf("宽字符: \"%ls\" (%zu 字符)\n", wc_string, wc_len);
    } else {
        ptrdiff_t offset = invalid - mb_string;
        printf("偏移量 %td 处有无效字符\n", offset);
    }
}
```

对于管理自身状态的转换函数，你可以通过将它们的 `char*` 参数设为 `NULL` 来将内部状态重置为初始状态，例如：

``` {.c}
mbstowcs(NULL, NULL, 0);   // 重置 mbstowcs() 的解析状态
mbstowcs(dest, src, 100);  // 解析一些内容
```

对于I/O，每个宽字符流都管理着自己的 `mbstate_t` 并在进行输入和输出转换时使用它。

一些面向字节的 I/O 函数，如 `printf()` 和 `scanf()` 在执行工作时会保持自身的内部状态。

最后，这些可重新启动的转换函数实际上拥有自己的内部状态，如果将 `mbstate_t` 参数设为 `NULL`，则它们会表现得更像不可重新启动的对应函数。

## Unicode 编码与 C

在本部分，我们将看到在三种特定的 Unicode 编码：UTF-8、UTF-16 和 UTF-32 方面，C 可以（和不能）做些什么。

### UTF-8

[i[Unicode-->UTF-8]<]

在查看本部分之前，可以阅读上面的 [UTF-8 快速说明](#utf8-quick) 进行复习。

除此之外，C 对 UTF-8 有哪些能力呢？

很不幸，并不多。

[i[`u8` UTF-8 前缀]<]

你可以告诉 C 你明确希望一个字符串常量被编码为 UTF-8，然后它就会为你做这件事。你可以在字符串前加上 `u8` 前缀：

``` {.c}
char *s = u8"Hello, world!";

printf("%s\n", s);   // Hello, world!--如果你可以输出 UTF-8
```

那么，是否可以在其中放入 Unicode 字符呢？

``` {.c}
char *s = u8"€123";
```

[i[`u8` UTF-8 前缀]>]

当然可以！如果扩展的源字符集支持的话（gcc 支持）。

如果不支持呢？你可以使用友好的 `\u` 和 `\U` 指定 Unicode 代码点，[如上所述](#unicode-in-c)。

但这就是全部。在标准库中，除非你的区域设置为 UTF-8，否则没有一种便捷的方法可以将任意输入转换为 UTF-8。也不能解析 UTF-8，除非你的区域设置为 UTF-8。

因此，如果你想要这样做，要么设置为 UTF-8 区域并使用：

``` {.c}
setlocale(LC_ALL, "");
```

要么在你的本地机器上找出一个 UTF-8 区域的名称并显式设置，就像这样：

``` {.c}
setlocale(LC_ALL, "en_US.UTF-8");  // 非便携式名称
```

或者使用[第三方库](#utf-3rd-party)。

[i[Unicode-->UTF-8]>]

### UTF-16、UTF-32、`char16_t` 和 `char32_t`

[i[Unicode-->UTF-16]<]
[i[Unicode-->UTF-32]<]
[i[`char16_t` 类型]<]
[i[`char32_t` 类型]<]

`char16_t` 和 `char32_t` 是另外两种可能的宽字符类型，分别为 16 位和 32 位。不一定是宽字符，因为如果它们无法表示当前区域设置中的每个字符，它们就失去了宽字符特性。但规范中到处都将它们称为“宽字符”类型，所以我们就这样了。

这些类型在一定程度上使事情更加友好于 Unicode。     

要使用它们，包含 `<uchar.h>`。（这是“u”，而不是“w”。）

这个头文件在 macOS 中不存在——挺糟糕的。如果你只想要这些类型，可以这样做：

``` {.c}
#include <stdint.h>

typedef int_least16_t char16_t;
typedef int_least32_t char32_t;
```

但如果你还想要函数，那就全靠你了。

[i[`u` Unicode 前缀]<]
[i[`U` Unicode 前缀]<]

假设你还能继续进行，你可以使用 `u` 和 `U` 前缀声明这些类型的字符串或字符：

``` {.c}
char16_t *s = u"Hello, world!";
char16_t c = u'B';

char32_t *t = U"Hello, world!";
char32_t d = U'B';
```

[i[`char32_t` 类型]>]
[i[`u` Unicode 前缀]>]
[i[`U` Unicode 前缀]>]

现在--- 这些值是以UTF-16还是UTF-32存储的？这取决于实现。

但你可以测试一下。如果宏[i[`__STDC_UTF_16__`宏]] `__STDC_UTF_16__`或[i[`__STDC_UTF_32__宏`]] `__STDC_UTF_32__`被定义为`1`，则意味着类型分别保存UTF-16或UTF-32。

如果你好奇，我知道你是，这些值，如果是UTF-16或UTF-32，会按照本地字节序存储。也就是说，你应该能够直接将它们与Unicode代码点值进行比较：

``` {.c}
char16_t pi = u"\u03C0";  // π符号

#if __STDC_UTF_16__
pi == 0x3C0;  // 总是为真
#else
pi == 0x3C0;  // 可能不为真
#endif
```

[i[`char16_t`类型]>]
[i[Unicode-->UTF-16]>]
[i[Unicode-->UTF-32]>]

### 多字节转换

你可以使用许多辅助函数将你的多字节编码转换为`char16_t`或`char32_t`。

（正如我所说，结果可能不是UTF-16或UTF-32，除非相应的宏设置为`1`。）

所有这些函数都是可重启的（即你传入自己的`mbstate_t`），并且所有这些函数都是逐字符操作^[有点复杂---对于多`char16_t` UTF-16编码来说会有点问题。]。

|转换函数|描述|
|-|-|
|[i[`mbrtoc16()`函数]]`mbrtoc16()`|将多字节字符转换为`char16_t`字符。|
|[i[`mbrtoc32()`函数]]`mbrtoc32()`|将多字节字符转换为`char32_t`字符。|
|[i[`c16rtomb()`函数]]`c16rtomb()`|将`char16_t`字符转换为多字节字符。|
|[i[`c32rtomb()`函数]]`c32rtomb()`|将`char32_t`字符转换为多字节字符。|

### 第三方库 {#utf-3rd-party}

针对不同特定编码之间的大规模转换，有几个成熟的库值得检查。请注意，我未使用过以下两个：

* [flw[iconv|Iconv]]---国际化转换，是一个常见的 POSIX 标准 API，在主要平台上可用。
* [fl[ICU|http://site.icu-project.org/]]---Unicode 的国际组件。至少有一位博主发现这个库易于使用。

如果您有更值得注意的库，请告诉我。