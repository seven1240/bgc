<!-- Beej's guide to C

# vim: ts=4:sw=4:nosi:et:tw=72
-->

# 不完整类型

会让你感到惊讶的是，这段代码居然能编译通过而不报错：

``` {.c}
extern int a[];

int main(void)
{
    struct foo *x;
    union bar *y;
    enum baz *z;
}
```

我们从未为`a`指定大小。而且我们有指向从未似乎在任何地方声明的`struct` `foo`、`bar` 和 `baz` 的指针。

而我收到的唯一警告是`x`、`y` 和 `z` 未被使用。

这些是不完整类型的例子。

不完整类型是指其大小（即从`sizeof`中获得的大小）未知的类型。另一种思考方式是一种你还没声明完整的类型。

你可以拥有一个指向不完整类型的指针，但你不能对它进行解引用或进行指针运算。你也无法使用`sizeof`运算。

那么你可以对它做什么呢？

## 应用案例：自指向结构体

我只知道一个真实用例：对具有自指向或相互依赖结构的`struct`或`union`进行前向引用。（接下来我会一直使用`struct`作为示例，但同样适用于`union`。）

让我们先来看经典例子。

但在此之前，要知道！当你声明一个`struct`时，直到达到结束大括号之前，这个`struct`是不完整的！

``` {.c}
struct antelope {              // 此处`struct antelope`是不完整的
    int leg_count;             // 仍然不完整
    float stomach_fullness;    // 仍然不完整
    float top_speed;           // 仍然不完整
    char *nickname;            // 仍然不完整
};                             // 现在它是完整的了。
```

那么怎么了？看起来挺正常的。

但是如果我们正在使用链表怎么办？每个链表节点都需要引用另一个节点。但是如果我们甚至还没有声明节点，我们怎么能创建对另一个节点的引用呢？

C语言允许不完整类型，这使得这种情况成为可能。我们无法声明一个节点，但是我们确实可以声明一个指向节点的指针，即使它是不完整的！

``` {.c}
struct node {
    int val;
    struct node *next;  // struct node是不完整的，但没关系！
};
```

即使在第3行`struct node`是不完整的，我们仍然可以声明一个指向节点的指针。^[这能成立是因为在C中，指针的大小不受其指向的数据类型的影响。因此，编译器此时不需要知道`struct node`的大小，它只需要知道指针的大小。]。

如果我们有两个相互引用的不同`struct`，我们也可以做同样的事情：

``` {.c}
struct a {
    struct b *x;  // 引用了`struct b`
};

struct b {
    struct a *x;  // 引用了`struct a`
};
```

如果没有松散的不完整类型规则，我们将无法创建这一对结构。

[i[不完整类型-->自引用的`struct`]》]

## 不完整类型错误消息

你是否碰到这样的错误？

``` {.default}
对不完整类型的sizeof运算无效

对未定义类型的无效使用

解引用指向不完整类型的指针
```

最有可能的原因是：你可能忘记了`#include`声明该类型的头文件。

## 其他不完整类型

声明一个没有主体的`struct`或`union`将产生一个不完整类型，例如`struct foo;`。

`enum`在闭合括号之前是不完整的。

`void`是一个不完整类型

以`extern`声明并且没有指定大小的数组是不完整的，例如：

``` {.c}
extern int a[];
```

如果是一个非`extern`且没有大小的数组，并且后面跟着初始化器，那么在初始化器的闭合大括号之前，这个数组是不完整的。

## 用例：头文件中的数组

在头文件中声明不完整的数组类型是很有用的。在这种情况下，实际的存储（完整数组声明的地方）应该在一个单独的`.c`文件中。如果你把它放在`.h`文件中，每次包含头文件时都会重复声明。

你可以这样做：创建一个头文件，声明一个引用数组的不完整类型，如下所示：

``` {.c .numberLines}
// 文件：bar.h

#ifndef BAR_H
#define BAR_H

extern int my_array[];  // 不完整类型

#endif
```

然后在`.c`文件中，实际定义数组：

``` {.c .numberLines}
// 文件：bar.c

int my_array[1024];     // 完整类型！
```

然后你可以从任意地方包含这个头文件，并且每个地方都会引用同一个基础的`my_array`。

``` {.c .numberLines}
// 文件：foo.c

#include <stdio.h>
#include "bar.h"    // 包含对my_array的不完整类型

int main(void)
{
    my_array[0] = 10;

    printf("%d\n", my_array[0]);
}
```

当编译多个文件时，记得向编译器指定所有的`.c`文件，而不是`.h`文件，例如：

``` {.zsh}
gcc -o foo foo.c bar.c
```

## 完成不完整类型

如果你有一个不完整类型，你可以通过在同一作用域中定义完整的`struct`、`union`、`enum`或数组来完成它。

``` {.c}
struct foo;        // 不完整类型

struct foo *p;     // 指针，没问题

// struct foo f;   // 错误：不完整类型！

struct foo {
    int x, y, z;
};                 // 现在struct foo已完整！

struct foo f;      // 成功！
```

请注意，尽管`void`是一个不完整的类型，但没有办法完成它。没有人会考虑去做那种奇怪的事情。但这解释了为什么你可以这样做：

``` {.c}
void *p;             // OK: 指向不完整类型的指针
```

而不能这样做：

``` {.c}
void v;              // Error: 声明不完整类型的变量

printf("%d\n", *p);  // Error: 解引用不完整类型
```

知识就是力量...