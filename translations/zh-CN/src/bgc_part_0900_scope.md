## 作用域

作用域是关于哪些变量在什么上下文中可见的。

### 块作用域

这是开发人员定义的几乎所有变量的作用域。其中包括其他语言可能称为“函数作用域”的内容，即在函数内部声明的变量。

基本规则是，如果在由花括号限定的块中声明了一个变量，则该变量的作用域为该块。

如果一个块中包含另一个块，则在内部块中声明的变量仅在该块中可见，并且在外部作用域中无法看到。

一旦变量的作用域结束，该变量就不再可以引用，您可以认为其值已经消失在天空中的大 [flw[bit bucket|Bit_bucket]] 中。

嵌套作用域的示例：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int a = 12;         // 局部于外部块，但在内部块中可见

    if  (a == 12) {
        int b = 99;     // 局部于内部块，外部块中不可见

        printf("%d %d\n", a, b);  // 正确: "12 99"
    }

    printf("%d\n", a);  // 正确，我们仍在 a 的作用域内

    printf("%d\n", b);  // 非法，超出 b 的作用域
}
```

### 变量定义的位置

另一个有趣的事实是，您可以在块中的任何地方定义变量，合理范围内---它们的作用域在该块内，但在定义之前不能使用。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i = 0;

    printf("%d\n", i);     // 正确: "0"

    //printf("%d\n", j);   // 非法--不能在定义之前使用 j

    int j = 5;

    printf("%d %d\n", i, j);   // 正确: "0 5"
}
```

在历史上，C语言要求所有变量在代码块中的任何代码之前都要进行定义，但这不再是C99标准中的情况。

### 变量隐藏

如果在内部作用域中有一个与外部作用域中的变量同名的变量，那么在内部作用域运行时，内部作用域中的变量会优先使用。也就是说，在其生命周期内，它_隐藏_了外部作用域中的变量。

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    int i = 10;

    {
        int i = 20;

        printf("%d\n", i);  // 内部作用域 i, 20（外部 i 被隐藏）
    }

    printf("%d\n", i);  // 外部作用域 i, 10
}
```

您可能已经注意到在该示例中，我仅在第7行加入了一个代码块，并没有 `for` 或 `if` 语句来启动它！这是完全合法的。有时开发人员会想要将一系列局部变量组合在一起进行快速计算，就会这样做，但很少见。

## 文件作用域

如果在代码块外定义了一个变量，那么该变量具有 _文件作用域_。它在其后的所有函数中都可见，并在它们之间共享。（一个例外是，如果一个代码块定义了一个同名变量，则会隐藏文件作用域中的变量。）

这与其他编程语言中您可能认为是“全局”作用域最接近。

例如：

``` {.c .numberLines}
#include <stdio.h>

int shared = 10;    // 文件作用域！在此之后整个文件都可见！

void func1(void)
{
    shared += 100;  // 现在 shared 为 110
}

void func2(void)
{
    printf("%d\n", shared);  // 输出 "110"
}

int main(void)
{
    func1();
    func2();
}
```

请注意，如果在文件底部声明`shared`，它将不会编译。它必须在任何函数使用它之前声明。

有一些进一步修改文件范围内项目的方法，分别是使用`static`和`extern`，但我们稍后会更详细地讨论这些。

## `for`循环范围

实际上我不知道该如何称呼这个，在C11 §6.8.5.3¶1中没有为其提供合适的名称。在本指南中我们已经多次这样做了。当你在`for`循环的第一个子句中声明一个变量时就会遇到这种情况：

``` {.c}
for (int i = 0; i < 10; i++)
    printf("%d\n", i);

printf("%d\n", i);  // 非法--i只在`for`循环内作用域内
```

在这个例子中，`i`的生命周期从一开始定义开始，持续到循环结束。

如果循环体被封闭在一个块中，那么在`for`循环中定义的变量可以从内部作用域中访问。

当然，除非这个内部作用域将它们隐藏。这个疯狂的例子打印了五次`999`：

``` {.c .numberLines}
#include <stdio.h>

int main(void)
{
    for (int i = 0; i < 5; i++) {
        int i = 999;  // 隐藏了`for`循环作用域中的i
        printf("%d\n", i);
    }
}
```

## 函数作用域的一点说明

C语言规范确实提到了_函数作用域_，但它仅与_标签_一起使用，这是我们目前尚未讨论的内容。待以后详谈。